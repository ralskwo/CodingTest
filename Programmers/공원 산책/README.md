# 공원 산책 문제 풀이 및 설명

<https://school.programmers.co.kr/learn/courses/30/lessons/172928>

<https://mayquartet.com/python-programmers-172928-공원-산책/>

## 문제 이해

이 문제는 로봇 강아지가 주어진 공원에서 주어진 명령에 따라 산책을 하는 상황을 모델링한 것입니다. 공원은 직사각형 격자 형태로 표현되며, 로봇 강아지는 특정 시작 지점(S)에서 시작하여 주어진 명령에 따라 이동합니다. 이동할 수 있는 경로는 'O'로 표시되고, 장애물은 'X'로 표시됩니다. 로봇 강아지는 명령을 수행하기 전에 명령을 수행할 수 있는지 두 가지 조건을 먼저 확인합니다. 첫 번째는 공원을 벗어나지 않는지, 두 번째는 장애물을 만나지 않는지입니다. 이 두 조건을 만족하지 못할 경우 해당 명령을 무시하고 다음 명령으로 넘어갑니다. 이러한 방식으로 모든 명령을 처리한 후 로봇 강아지의 최종 위치를 구하는 것이 문제의 핵심입니다.

## 입출력 조건

- 입력으로는 `park`라는 문자열 배열과 `routes`라는 명령어 배열이 주어집니다.
  - `park`는 공원의 상태를 나타내며, 각 요소는 'S', 'O', 'X' 중 하나로 이루어진 문자열입니다.
  - 'S'는 시작 지점, 'O'는 로봇이 지나갈 수 있는 길, 'X'는 장애물을 의미합니다.
  - `routes`는 로봇 강아지가 이동할 방향과 거리를 나타내며, `"방향 거리"` 형식의 문자열로 이루어져 있습니다. 예를 들어 `"E 5"`는 로봇이 동쪽으로 5칸 이동한다는 의미입니다.
- 출력은 로봇 강아지가 모든 명령을 수행한 후의 최종 위치로, `[세로 방향 좌표, 가로 방향 좌표]` 형태의 배열로 반환합니다.
- 좌표는 공원의 좌측 상단이 `(0, 0)`이고, 우측 하단이 `(H - 1, W - 1)`로 정의됩니다.

## 접근 방식

이 문제를 해결하기 위해서는 먼저 로봇 강아지의 시작 지점을 찾아야 합니다. 시작 지점을 찾은 후에는 주어진 명령어를 하나씩 처리하면서, 로봇이 공원을 벗어나지 않는지, 또는 장애물을 만나지 않는지 확인하는 과정이 필요합니다. 각 명령은 방향과 거리로 구성되어 있으므로, 해당 방향으로 몇 칸 이동할지를 계산하고, 이동 중에 장애물이나 공원 경계를 넘는 상황이 발생하면 그 명령을 무시해야 합니다. 이를 위해 이동할 때 좌표의 변화를 계산하고, 명령이 유효한지 확인하는 단계가 필요합니다.

또한, 공원의 좌표는 2차원 배열 형태로 표현되기 때문에, 방향에 따라 좌표의 변화를 계산하는 방식을 알고 있어야 합니다. 예를 들어 북쪽으로 이동하면 세로 좌표가 감소하고, 동쪽으로 이동하면 가로 좌표가 증가하는 식입니다. 각 명령에 따라 로봇의 위치를 갱신하면서 최종적으로 로봇이 도착한 위치를 반환하면 됩니다.

## 풀이 과정

1. 먼저, 공원의 크기를 확인하고, `park` 배열을 순회하면서 시작 지점(S)을 찾습니다. 이때 찾은 좌표를 변수 `x`, `y`에 저장합니다.
2. 주어진 명령어 배열 `routes`를 순차적으로 탐색합니다. 각 명령어는 `"방향 거리"` 형식이므로, `split()` 함수를 사용해 방향과 거리를 분리하고, 거리는 정수형으로 변환합니다.
3. 방향에 따른 좌표 변화는 미리 정의해둔 `direction` 딕셔너리를 사용해 처리합니다. 각 방향(N, S, W, E)에 따라 좌표가 어떻게 변할지 저장해 두고, 이를 통해 로봇이 이동할 때의 좌표 변화를 계산합니다.
4. 각 명령에 대해 해당 방향으로 이동할 때, 주어진 거리를 하나씩 이동하면서 공원의 범위를 벗어나는지, 장애물을 만나는지를 확인합니다. 만약 조건을 만족하지 못하면 해당 명령을 무시하고 다음 명령으로 넘어갑니다.
5. 이동이 유효하다면 로봇의 좌표를 갱신하고, 명령이 끝난 후 최종 위치를 반환합니다.
6. 마지막으로, 로봇 강아지가 도착한 최종 위치를 `[세로 좌표, 가로 좌표]` 형태로 출력합니다.

이 과정에서 주의할 점은 명령어를 처리할 때 유효한 범위 내에서만 이동할 수 있도록 공원의 경계와 장애물 여부를 항상 체크해야 한다는 것입니다.

## 코드 구현

```python
def solution(park, routes):
    H = len(park)  # 공원의 세로 길이를 변수 H에 저장
    W = len(park[0])  # 공원의 가로 길이를 변수 W에 저장

    for i in range(H):  # 공원의 모든 행을 순차적으로 탐색
        for j in range(W):  # 각 행의 모든 열을 순차적으로 탐색
            if park[i][j] == 'S':  # 시작 지점을 찾으면
                x, y = i, j  # 시작 지점의 좌표를 x, y로 설정

    direction = {  # 각 방향에 따른 좌표 변화를 정의
        'N': (-1, 0),  # 북쪽으로 이동: x축 -1, y축 변화 없음
        'S': (1, 0),   # 남쪽으로 이동: x축 +1, y축 변화 없음
        'W': (0, -1),  # 서쪽으로 이동: y축 -1, x축 변화 없음
        'E': (0, 1)    # 동쪽으로 이동: y축 +1, x축 변화 없음
    }

    for route in routes:  # 각 명령어를 순차적으로 처리
        dir, n = route.split()  # 명령어에서 방향과 이동 칸 수를 분리
        n = int(n)  # 이동할 거리를 정수형으로 변환

        dx, dy = direction[dir]  # 이동할 방향에 따른 좌표 변화량을 설정
        nx, ny = x, y  # 현재 좌표를 임시로 nx, ny에 저장
        valid_move = True  # 이동 가능 여부를 체크하는 플래그 변수

        for _ in range(n):  # 이동할 거리만큼 반복
            nx += dx  # x 좌표를 이동
            ny += dy  # y 좌표를 이동

            if not (0 <= nx < H and 0 <= ny < W) or park[nx][ny] == 'X':  # 공원을 벗어나거나 장애물을 만나면
                valid_move = False  # 해당 이동은 불가능하므로 플래그를 False로 설정
                break  # 이동을 중단하고 명령을 무시

        if valid_move:  # 만약 유효한 이동이라면
            x, y = nx, ny  # 최종 좌표를 갱신

    return [x, y]  # 로봇 강아지의 최종 위치를 반환
```
