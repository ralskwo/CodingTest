# 시계 사진들 문제 풀이 및 설명

<https://www.acmicpc.net/problem/10266>

<https://mayquartet.com/python-백준-10266-시계-사진들/>

## 문제 이해

이 문제는 두 개의 시계 사진이 같은 시각을 나타낼 수 있는지를 판단하는 문제입니다. 두 시계는 각도를 나타내는 바늘들만 있고, 숫자는 희미하여 정확한 숫자 위치는 보이지 않으므로 시계의 바늘 위치만으로 판단해야 합니다. 두 시계의 바늘 위치를 각각 하나의 리스트로 주며, 이 위치는 0부터 359,999까지의 범위 내에서 시계 방향 각도로 주어집니다. 이때 각 시계 바늘의 위치를 회전하면서 두 시계가 같은 시각을 표현할 수 있는지 판단하는 것이 목표입니다. 이 문제에서 중요한 것은 각도가 주어지는 순서는 무작위이며, 각도를 정렬하여 간격 차이를 통해 두 시계의 상태가 동일해질 수 있는지를 판단하는 것입니다. 단순히 위치가 같은지 보는 것이 아니라 시계의 회전이 가능하므로, 주어진 두 시계 바늘의 각도 차이 패턴이 동일하게 반복되는지를 확인해야 합니다.

## 입출력 조건

- **입력 조건**

  - 첫 번째 줄에 시계 바늘의 개수 `n`이 주어집니다. `2 ≤ n ≤ 200,000`의 범위를 가지며, 이는 매우 많은 바늘의 위치를 다룰 수 있음을 의미합니다.
  - 다음 두 줄에는 각각 `n`개의 정수로 이루어진 시계 바늘의 각도가 주어집니다. 각 바늘의 각도는 `0 ≤ ai < 360,000`의 범위에 있습니다. 이 각도는 순서 없이 주어지며, 같은 각도가 두 번 이상 주어지지 않습니다.

- **출력 조건**
  - 두 시계가 회전하여 같은 시각을 나타낼 수 있다면 `possible`을 출력하고, 그렇지 않으면 `impossible`을 출력합니다.

## 접근 방식

이 문제를 해결하기 위해 다음과 같은 접근 방식을 사용해야 합니다.

1. **각도 정렬 및 간격 계산**:
   두 시계의 각도를 정렬하여 각각의 연속된 각도 간격을 계산합니다. 이렇게 하면 두 시계의 각도 차이가 순서대로 같은 패턴을 이루는지를 확인할 수 있습니다. 예를 들어, 각도가 `[1, 2, 4]`라면, 각도 간격은 `[1, 2, 1]`로 계산됩니다. 마지막과 첫 번째 각도 간에도 간격이 있어야 원형 시계처럼 회전 패턴을 이룰 수 있습니다.

2. **리스트 회전 패턴 확인**:
   시계 두 개의 각도 간격 리스트가 단순히 동일한 패턴으로 이루어진다면 두 시계는 회전을 통해 같은 시각을 나타낼 수 있습니다. 이를 위해 한 리스트를 두 배로 확장하여 원형 회전된 상태를 표현할 수 있게 합니다. 그리고 이를 다른 간격 리스트와 비교하여 회전 시 같은 패턴을 이루는지를 확인합니다.

3. **KMP 알고리즘 적용**:
   두 배로 확장된 리스트 내에서 두 번째 시계의 간격 리스트가 존재하는지를 KMP 알고리즘을 통해 탐색합니다. KMP 알고리즘은 `O(n + m)`의 복잡도로 패턴 탐색이 가능하기 때문에, 주어진 문제의 조건인 `n`이 최대 200,000인 경우에도 효율적으로 비교할 수 있습니다.

## 풀이 과정

1. **간격 리스트 계산 함수** `calculate_gaps` 정의:

   - 두 시계 바늘의 각도 리스트를 정렬합니다. 정렬된 리스트로부터 각도 간격을 계산하여 두 시계의 상태를 일정한 패턴으로 표현합니다. 각도 간격을 저장할 리스트를 만들어 연속된 각도 간의 차이를 계산하여 저장합니다.
   - 마지막 바늘과 첫 번째 바늘의 간격도 계산하여 리스트에 추가해 원형 시계에서의 각도 차이를 표현합니다.

2. **KMP 패턴 매칭 알고리즘 함수** `kmp_search` 정의:

   - 텍스트 리스트(`doubled_gaps1`) 내에서 패턴 리스트(`gaps2`)가 존재하는지를 찾기 위해 KMP 알고리즘을 구현합니다. KMP 알고리즘은 패턴이 불일치할 때 이동할 접두사 위치를 계산하여 불필요한 비교를 줄이는 방식으로 동작합니다.
   - KMP 알고리즘을 위해 LPS(Longest Prefix Suffix) 배열을 계산하여 패턴 매칭 중간중간에 불일치가 발생할 경우 효율적으로 검색을 이어갑니다. 이때 `lps` 배열은 각 패턴이 얼마나 겹칠 수 있는지 정보를 담고 있어, 비교를 다시 처음부터 하지 않고 특정 위치로 이동할 수 있게 합니다.

3. **입력 처리** 및 **간격 리스트 생성**:

   - 입력으로 주어진 각도 수 `n`과 두 시계의 각도를 받아 리스트 `angles1`, `angles2`에 저장합니다. 각도 리스트는 무작위 순서로 주어지기 때문에 정렬하여 사용합니다.
   - 두 각도 리스트 `angles1`과 `angles2`에 대해 `calculate_gaps` 함수를 호출하여 간격 리스트 `gaps1`과 `gaps2`를 계산합니다.

4. **간격 리스트의 회전 가능성 확인**:
   - 첫 번째 시계의 간격 리스트 `gaps1`을 두 배로 확장하여 `doubled_gaps1`을 생성합니다. 두 배로 확장된 리스트를 통해 `gaps2`가 `gaps1`의 회전된 형태로 존재하는지 확인할 수 있습니다.
   - `kmp_search` 함수를 통해 `doubled_gaps1` 리스트 내에 `gaps2`가 존재하는지를 탐색합니다. 이 탐색이 성공하면 두 시계의 회전으로 같은 시각을 나타낼 수 있으므로 "possible"을 출력합니다. 탐색이 실패하면 "impossible"을 출력합니다.

## 코드 구현

```python
def calculate_gaps(angles):
    # 각도를 정렬하여 시계방향 순서로 정리
    angles.sort()
    # 각도의 개수를 n에 저장
    n = len(angles)
    # 각도 간의 간격을 저장할 리스트 생성
    gaps = []
    # 정렬된 각도 리스트에서 인접한 각도 간의 차이를 계산하여 gaps 리스트에 추가
    for i in range(n - 1):
        gaps.append(angles[i + 1] - angles[i])
    # 마지막 각도와 첫 번째 각도의 차이(원형 구조를 고려한 간격)를 계산하여 gaps에 추가
    gaps.append(360000 - angles[-1] + angles[0])
    # 간격 리스트 반환
    return gaps

def kmp_search(text, pattern):
    # 텍스트와 패턴의 길이를 각각 n, m에 저장
    n, m = len(text), len(pattern)
    # LPS(Longest Prefix Suffix) 배열을 초기화
    lps = [0] * m
    # 패턴 비교 인덱스를 나타내는 j를 0으로 초기화
    j = 0
    # LPS 배열을 채우기 위한 초기 인덱스를 1로 설정
    i = 1
    # LPS 배열을 구축하는 과정
    while i < m:
        # 패턴의 현재 문자와 비교 인덱스가 가리키는 문자가 같을 때
        if pattern[i] == pattern[j]:
            # 접두사와 접미사의 길이를 증가시키고 lps 배열에 기록
            j += 1
            lps[i] = j
            i += 1
        else:
            # 문자가 일치하지 않을 경우
            if j != 0:
                # 이전 접두사 길이로 이동
                j = lps[j - 1]
            else:
                # 초기 접두사 길이로 설정
                lps[i] = 0
                i += 1

    # 패턴 검색을 위한 초기 인덱스 설정
    i = 0
    j = 0
    # 텍스트 내에서 패턴을 찾기 위한 탐색 과정
    while i < n:
        # 패턴과 텍스트의 문자가 일치할 경우
        if pattern[j] == text[i]:
            i += 1
            j += 1
        # 패턴 전체를 찾았을 때
        if j == m:
            return True
        # 문자 불일치가 발생할 때
        elif i < n and pattern[j] != text[i]:
            if j != 0:
                # LPS 배열을 참고하여 j의 위치 조정
                j = lps[j - 1]
            else:
                i += 1
    # 패턴이 텍스트에 존재하지 않는 경우 False 반환
    return False

# 입력된 각도 수를 n에 저장
n = int(input())
# 첫 번째 시계의 각도들을 angles1에 저장
angles1 = list(map(int, input().split()))
# 두 번째 시계의 각도들을 angles2에 저장
angles2 = list(map(int, input().split()))

# 첫 번째 시계의 각도 간격 계산
gaps1 = calculate_gaps(angles1)
# 두 번째 시계의 각도 간격 계산
gaps2 = calculate_gaps(angles2)

# 첫 번째 시계의 간격 리스트를 두 배로 확장하여 회전 가능한 모든 경우 고려
doubled_gaps1 = gaps1 + gaps1

# 첫 번째 시계의 확장된 간격 리스트에서 두 번째 시계의 간격 리스트가 발견되면 같은 시각이 가능한 것으로 판단
if kmp_search(doubled_gaps1, gaps2):
    print("possible")
else:
    print("impossible")
```
