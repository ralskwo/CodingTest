# 컵라면 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1781>

<https://mayquartet.com/python-파이썬-백준-1781-컵라면/>

## 문제 이해

이 문제는 주어진 여러 문제들을 시간 내에 최대한 풀어, 가장 많은 컵라면을 얻는 것이 목표입니다. 각 문제는 `데드라인`과 `컵라면 수`가 주어집니다. 동호는 각 문제를 푸는 데 단위 시간 1을 사용하며, 데드라인이 지나면 해당 문제를 풀 수 없습니다. 따라서, 문제들을 제한된 시간 안에 최적으로 선택하여 최대한 많은 컵라면을 얻을 수 있는 전략을 세우는 것이 중요합니다.

이 문제를 해결하기 위해서는 `데드라인`과 `컵라면 수`를 모두 고려하여 문제들을 선택해야 합니다. 데드라인이 가까운 문제는 빨리 풀어야 하며, 컵라면 수가 많은 문제를 우선적으로 풀어야 최대 이득을 볼 수 있습니다. 예를 들어, 데드라인이 같은 두 문제 중에서는 컵라면 수가 더 많은 문제를 선택하는 것이 유리합니다. 반면, 데드라인이 서로 다른 문제들은 풀 수 있는 시간에 따라 어떤 문제를 선택할지가 결정되므로, 효율적인 선택 방법을 찾아야 합니다.

## 입출력 조건

- 입력:

  - 첫 번째 줄에 문제의 개수 `N`이 주어집니다. (`1 ≤ N ≤ 200,000`)
  - 두 번째 줄부터 `N+1`번째 줄까지 각 문제의 `데드라인`과 `컵라면 수`가 공백으로 구분되어 주어집니다.
  - 각 `데드라인`은 1 이상 `N` 이하의 자연수이며, 각 문제를 푸는 데 단위 시간 1이 소요됩니다.
  - 각 문제를 풀 때 받을 수 있는 `컵라면 수`와 최대로 받을 수 있는 컵라면 수는 모두 2^31보다 작은 자연수입니다.

- 출력:
  - 동호가 받을 수 있는 최대 컵라면 수를 정수로 출력합니다.

## 접근 방식

이 문제는 `그리디 알고리즘`과 `우선순위 큐`를 사용하여 풀 수 있습니다. 문제의 핵심은 **데드라인을 고려하여 최대로 받을 수 있는 컵라면 수를 계산**하는 것입니다. 따라서 문제를 다음과 같은 방식으로 접근합니다:

1. **문제 정렬**:

   - `데드라인`을 기준으로 오름차순 정렬하여 데드라인이 빠른 문제부터 순서대로 확인합니다.
   - 만약 데드라인이 동일한 문제들이 있다면, 컵라면 수가 많은 순서대로 정렬합니다. 이렇게 하면 같은 데드라인 내에서는 최대한 많은 컵라면을 받을 수 있는 문제를 먼저 선택할 수 있습니다.

2. **우선순위 큐(Priority Queue) 사용**:

   - 문제를 하나씩 처리하면서 `현재까지 풀기로 결정한 문제들의 컵라면 수를 관리`합니다.
   - 현재 데드라인 내에 풀 수 있는 문제의 개수가 초과되면, 가장 적은 컵라면 수를 제공하는 문제를 제외하여 최대로 받을 수 있는 컵라면 수를 유지합니다.
   - 이를 위해 `최소 힙`을 사용하여 현재 선택된 문제들 중 가장 컵라면 수가 적은 문제를 효율적으로 찾고 제거할 수 있도록 합니다.

3. **결과 계산**:
   - 마지막에 `우선순위 큐`에 남아 있는 문제들의 컵라면 수를 모두 더하여 최종적으로 받을 수 있는 최대 컵라면 수를 출력합니다.

<https://mayquartet.com/algorithm-알고리즘-greedy-그리디-알고리즘탐욕법-이해하기/>

## 풀이 과정

1. 먼저 `heapq` 모듈을 임포트하고, 문제의 개수 `N`을 입력받습니다. 이후 `problems`라는 빈 리스트를 생성하여 각 문제의 `데드라인`과 `컵라면 수` 정보를 저장할 준비를 합니다.

2. `for` 반복문을 사용하여 `N`개의 문제 정보를 입력받습니다. 각 문제에 대해 `deadline`과 `ramen` 값을 입력받아 `(데드라인, 컵라면 수)` 형태의 튜플을 `problems` 리스트에 추가합니다. 이렇게 하면 모든 문제 정보가 `problems` 리스트에 저장됩니다.

3. `problems` 리스트를 `데드라인` 기준으로 오름차순 정렬합니다. 이 정렬을 통해 데드라인이 빠른 문제부터 순서대로 처리할 수 있게 됩니다. 만약 데드라인이 동일한 문제가 있을 경우, 자동으로 두 번째 값인 `컵라면 수` 기준으로 정렬됩니다. 이렇게 정렬하면 문제를 풀 때 데드라인을 지키는지 여부를 손쉽게 판단할 수 있습니다.

4. `ramen_heap`이라는 빈 리스트를 생성하여 `최소 힙`을 사용하여 문제를 처리할 준비를 합니다. 정렬된 `problems` 리스트를 순서대로 탐색하면서, 각 문제의 `컵라면 수`를 `ramen_heap`에 추가합니다.

5. 각 문제를 `ramen_heap`에 추가할 때, `ramen_heap`의 길이가 현재 문제의 `데드라인`보다 커지면, 데드라인 내에 풀 수 있는 문제의 수를 초과한 것입니다. 이 경우, `heapq.heappop`을 사용하여 `ramen_heap`에서 가장 컵라면 수가 적은 문제를 제거합니다. 이렇게 하면 현재 문제를 포함하여 데드라인을 초과하지 않는 문제들을 유지할 수 있습니다.

6. 마지막으로, `ramen_heap`에 남아 있는 문제들은 동호가 풀 수 있는 문제들이므로, `sum` 함수를 사용하여 `ramen_heap`에 남아 있는 모든 컵라면 수를 더해 최종적인 최대 컵라면 수를 계산합니다.

7. 최종적으로, 최대 컵라면 수를 출력하여 결과를 확인합니다.

## 코드 구현

```python
import heapq  # 힙 자료구조를 사용하기 위해 heapq 모듈을 임포트

n = int(input())  # 문제의 개수 N 입력받기
problems = []  # 각 문제의 (데드라인, 컵라면 수) 정보를 저장할 리스트 초기화

for _ in range(n):  # N개의 문제에 대해 반복하면서 데드라인과 컵라면 수를 입력받기
    deadline, ramen = map(int, input().split())  # 데드라인과 컵라면 수를 입력받아 변수에 저장
    problems.append((deadline, ramen))  # (데드라인, 컵라면 수) 형태로 리스트에 추가

problems.sort()  # 문제들을 데드라인 기준으로 오름차순 정렬 (같은 데드라인이면 자동으로 컵라면 수 기준 정렬됨)

ramen_heap = []  # 현재까지 풀기로 선택한 문제의 컵라면 수를 관리하기 위한 최소 힙 생성

for deadline, ramen in problems:  # 정렬된 문제 리스트를 하나씩 확인
    heapq.heappush(ramen_heap, ramen)  # 힙에 현재 문제의 컵라면 수를 추가

    # 힙의 길이가 현재 문제의 데드라인을 초과하면, 즉 데드라인 내에 풀 수 있는 문제 수를 초과하면
    if len(ramen_heap) > deadline:
        heapq.heappop(ramen_heap)  # 힙에서 가장 컵라면 수가 적은 문제를 제거하여 데드라인에 맞추기

# 최종적으로 힙에 남아 있는 문제들은 동호가 풀 수 있는 문제들이므로, 힙의 요소들을 합산하여 출력
print(sum(ramen_heap))  # 동호가 받을 수 있는 최대 컵라면 수 출력
```
