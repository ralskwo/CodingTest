# 불 문제 풀이 및 설명

<https://www.acmicpc.net/problem/5427>

<https://mayquartet.com/python-파이썬-백준-5427-불/>

## 문제 이해

이 문제는 불이 퍼지는 속도와 상근이의 이동을 동시에 고려해야 하는 시뮬레이션 문제입니다. 불은 매 초마다 동서남북 방향으로 확산되며, 상근이는 불이 번진 빈 공간을 피하면서 탈출구를 찾아야 합니다. 상근이는 빈 공간만 이동할 수 있으며, 벽(`#`)은 통과할 수 없습니다. 상근이가 위치한 공간에 불이 도달하는 순간에 다른 빈 공간으로 이동할 수 있는 상황도 고려해야 합니다. 문제의 핵심은 불이 퍼지는 속도와 상근이의 이동 속도를 비교하면서 상근이가 안전하게 탈출할 수 있는 최소 시간을 찾는 것입니다. 빌딩의 가장자리에서 바깥으로 나가면 탈출에 성공한 것으로 간주합니다. 따라서 상근이가 가장자리로 이동하는 시간과 그 과정에서 불과의 충돌 여부를 시뮬레이션하여 문제를 해결해야 합니다.

## 입출력 조건

- **입력 조건**

  - 첫 번째 줄에는 테스트 케이스의 개수 `t`가 주어집니다. `t`는 최대 100개입니다.
  - 각 테스트 케이스의 첫 번째 줄에는 빌딩의 너비 `w`(열의 개수)와 높이 `h`(행의 개수)가 공백을 기준으로 주어집니다. (`1 ≤ w, h ≤ 1000`)
  - 그 다음 `h`개의 줄에는 길이가 `w`인 문자열이 주어지며, 이는 빌딩의 지도를 나타냅니다.
    - `'.'`은 빈 공간을 의미합니다.
    - `'#'`은 벽을 의미합니다.
    - `'@'`는 상근이의 시작 위치를 나타내며, 테스트 케이스마다 하나만 존재합니다.
    - `'*'`은 불이 시작된 위치를 의미합니다. 불은 여러 위치에서 시작될 수 있습니다.

- **출력 조건**
  - 각 테스트 케이스마다 상근이가 빌딩을 탈출할 수 있는 최소 시간을 출력합니다.
  - 만약 탈출이 불가능하다면 "IMPOSSIBLE"을 출력합니다.

## 접근 방식

이 문제를 해결하기 위해서는 두 가지의 BFS(너비 우선 탐색)를 사용해야 합니다. 하나는 불이 퍼지는 속도를 계산하는 BFS, 또 다른 하나는 상근이가 이동하는 경로를 계산하는 BFS입니다. 다음은 접근 방식입니다:

1. **불의 확산 BFS**:
   - 먼저 불이 각 위치에서 퍼지는 시간을 BFS를 통해 미리 계산합니다.
   - 불이 퍼질 수 있는 위치는 빈 공간(`'.'`)만 가능하므로, 벽(`#`)이나 이미 불이 퍼진 곳은 확산할 수 없습니다.
   - 불이 퍼지는 시간을 저장하는 2차원 배열을 만들어, 각 위치마다 불이 도달하는 시간을 기록합니다.
2. **상근이의 이동 BFS**:
   - 상근이의 위치에서 시작하여 탈출 가능한 경로를 찾기 위해 BFS를 사용합니다.
   - 상근이가 이동 가능한 위치는 빈 공간(`'.'`)이어야 하고, 불이 도착하지 않았거나 상근이가 불보다 먼저 도착할 수 있는 경우여야 합니다.
   - 상근이가 빌딩의 가장자리에서 밖으로 나가면 탈출에 성공한 것으로 처리하고 그 시간을 기록합니다.
3. **동시에 진행되는 BFS**:
   - 불의 확산과 상근이의 이동이 동시에 진행되므로, 두 BFS를 적절히 연계하여 상근이가 이동 가능한지와 그 위치가 안전한지를 체크해야 합니다.
   - 만약 BFS를 수행하는 동안 상근이가 탈출할 수 있는 위치를 찾지 못하면 "IMPOSSIBLE"을 출력합니다.

<https://mayquartet.com/algorithm-bfs-너비-우선-탐색-알고리즘/>

## 풀이 과정

1. **입력 처리 및 초기 설정**:

   - 입력 데이터를 받아와 각 테스트 케이스에 대해 빌딩의 지도를 처리합니다.
   - 불의 위치와 상근이의 위치를 큐에 각각 저장하고, 불의 확산 시간과 상근이의 이동 시간을 기록할 2차원 배열을 초기화합니다.
   - 상근이의 위치를 나타내는 배열과 불의 위치를 나타내는 배열을 각각 `person_times`와 `fire_times`로 초기화합니다. 초기값은 `-1`로 설정하여 아직 도달하지 않은 상태를 나타냅니다.

2. **불의 확산 BFS**:

   - 불의 위치에서 시작하여 BFS를 수행합니다. 각 위치에서 네 방향(동서남북)으로 불이 퍼질 수 있는지 검사합니다.
   - 불이 퍼질 수 있는 위치는 빈 공간(`'.'`)이어야 하며, 벽(`#`)이나 이미 불이 퍼진 곳은 확산할 수 없습니다.
   - 불이 다음 위치로 확산할 때마다 현재 위치의 시간에서 `1`을 더해 불의 도달 시간을 기록합니다.
   - 이렇게 모든 불의 확산 시간을 기록한 후, 상근이의 이동 BFS를 시작합니다.

3. **상근이의 이동 BFS**:

   - 상근이의 위치에서 시작하여 BFS를 수행합니다. 네 방향(동서남북)으로 이동 가능한지 검사합니다.
   - 상근이가 이동할 수 있는 위치는 빈 공간(`'.'`)이어야 하며, 그 위치에 불이 도달하지 않았거나 불보다 먼저 도착할 수 있어야 합니다.
   - 상근이가 이동하려는 위치가 빌딩의 경계를 넘어가면, 이는 탈출에 성공한 것이므로 탈출 시간을 계산하여 출력합니다.
   - 상근이가 이동할 수 있는 위치를 큐에 추가하고, 해당 위치까지 이동하는 데 걸리는 시간을 기록합니다.

4. **탈출 여부 판별 및 결과 출력**:

   - BFS를 수행하는 동안 상근이가 탈출할 수 있는 위치를 찾지 못하면, 즉 빌딩의 가장자리까지 도달하지 못하면 "IMPOSSIBLE"을 출력합니다.
   - 모든 테스트 케이스에 대해 위 과정을 반복하고, 각 테스트 케이스의 결과를 출력합니다.

5. **시간 복잡도 고려**:
   - 불의 확산과 상근이의 이동은 각각 BFS로 처리하므로 시간 복잡도는 `O(w * h)`입니다. 이는 빌딩의 모든 칸을 한 번씩 방문하는 시간에 해당합니다.
   - `w`와 `h`가 최대 1000이므로, `w * h`는 최대 1,000,000입니다. BFS로 처리하기 적합한 범위입니다.

## 코드 구현

```python
from collections import deque  # BFS 구현을 위해 deque를 임포트합니다.
import sys  # sys를 사용하여 입력을 빠르게 처리합니다.

input = sys.stdin.read  # 전체 입력을 한 번에 받아서 처리합니다.

def escape_building(w, h, building):
    # 불과 상근이의 위치를 저장할 큐를 초기화합니다.
    fire_queue = deque()
    person_queue = deque()
    # 불과 상근이의 각 위치에서의 시간을 저장할 2차원 배열을 초기화합니다.
    fire_times = [[-1] * w for _ in range(h)]
    person_times = [[-1] * w for _ in range(h)]

    # 빌딩의 각 칸을 확인하여 불과 상근이의 위치를 찾아 초기 설정합니다.
    for y in range(h):
        for x in range(w):
            if building[y][x] == '*':  # 해당 위치가 불인 경우
                fire_queue.append((x, y))  # 불의 위치를 큐에 추가합니다.
                fire_times[y][x] = 0  # 불이 퍼지기 시작한 시간을 0으로 설정합니다.
            elif building[y][x] == '@':  # 해당 위치가 상근이의 시작 위치인 경우
                person_queue.append((x, y))  # 상근이의 위치를 큐에 추가합니다.
                person_times[y][x] = 0  # 상근이가 출발하는 시간을 0으로 설정합니다.

    # 이동 가능한 방향을 나타내는 벡터 (동, 서, 남, 북)입니다.
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    # 불의 확산을 BFS로 계산합니다.
    while fire_queue:
        x, y = fire_queue.popleft()  # 현재 불이 있는 위치를 꺼냅니다.
        for dx, dy in directions:  # 네 방향으로 확산을 시도합니다.
            nx, ny = x + dx, y + dy  # 다음 위치를 계산합니다.
            # 다음 위치가 지도 범위 안에 있고, 아직 불이 도달하지 않은 위치인 경우
            if 0 <= nx < w and 0 <= ny < h and fire_times[ny][nx] == -1:
                if building[ny][nx] == '.':  # 빈 공간일 경우에만 불이 퍼질 수 있습니다.
                    fire_times[ny][nx] = fire_times[y][x] + 1  # 현재 위치의 시간보다 1초 늦게 불이 도달합니다.
                    fire_queue.append((nx, ny))  # 불의 새로운 위치를 큐에 추가합니다.

    # 상근이의 이동을 BFS로 계산합니다.
    while person_queue:
        x, y = person_queue.popleft()  # 상근이의 현재 위치를 꺼냅니다.
        for dx, dy in directions:  # 네 방향으로 이동을 시도합니다.
            nx, ny = x + dx, y + dy  # 다음 위치를 계산합니다.

            # 상근이가 지도 밖으로 나가는 경우 탈출에 성공한 것입니다.
            if nx < 0 or nx >= w or ny < 0 or ny >= h:
                return person_times[y][x] + 1  # 현재 시간에 1초를 더하여 탈출 시간을 반환합니다.

            # 다음 위치가 지도 범위 내에 있을 때
            if 0 <= nx < w and 0 <= ny < h:
                # 상근이가 방문하지 않은 빈 공간이고, 이동 가능한 경우
                if person_times[ny][nx] == -1 and building[ny][nx] == '.':
                    # 불이 도착하지 않았거나 상근이가 먼저 도착할 수 있는 경우
                    if fire_times[ny][nx] == -1 or fire_times[ny][nx] > person_times[y][x] + 1:
                        person_times[ny][nx] = person_times[y][x] + 1  # 상근이의 이동 시간을 기록합니다.
                        person_queue.append((nx, ny))  # 상근이의 새로운 위치를 큐에 추가합니다.

    # 상근이가 빌딩을 탈출하지 못한 경우 "IMPOSSIBLE"을 반환합니다.
    return "IMPOSSIBLE"

def main():
    # 전체 입력을 받아 공백을 기준으로 나누어 리스트로 저장합니다.
    input_data = input().split()
    idx = 0  # 입력 리스트의 현재 위치를 나타내는 인덱스를 초기화합니다.
    t = int(input_data[idx])  # 테스트 케이스의 개수를 가져옵니다.
    idx += 1  # 다음 입력을 처리하기 위해 인덱스를 증가시킵니다.
    results = []  # 각 테스트 케이스의 결과를 저장할 리스트입니다.

    # 각 테스트 케이스를 처리합니다.
    for _ in range(t):
        w = int(input_data[idx])  # 빌딩의 너비를 가져옵니다.
        h = int(input_data[idx + 1])  # 빌딩의 높이를 가져옵니다.
        idx += 2  # 다음 입력을 처리하기 위해 인덱스를 증가시킵니다.

        # 빌딩 지도를 가져와 리스트에 저장합니다.
        building = [input_data[idx + i] for i in range(h)]
        idx += h  # 다음 테스트 케이스를 처리하기 위해 인덱스를 증가시킵니다.

        # 현재 테스트 케이스의 결과를 계산하여 리스트에 추가합니다.
        result = escape_building(w, h, building)
        results.append(result)

    # 모든 테스트 케이스의 결과를 출력합니다.
    for result in results:
        print(result)

# 이 코드가 직접 실행될 때만 main 함수를 호출합니다.
if __name__ == "__main__":
    main()
```
