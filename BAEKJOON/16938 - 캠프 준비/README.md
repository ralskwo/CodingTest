# 캠프 준비 문제 풀이 및 설명

<https://www.acmicpc.net/problem/16938>

<https://mayquartet.com/python-백준-16938-캠프-준비/>

## 문제 이해

이 문제는 주어진 문제들 중에서 조건에 맞는 조합을 찾아내는 조합론과 완전 탐색(브루트포스) 문제입니다. 백준이는 여러 개의 알고리즘 문제를 가지고 있으며, 이 중에서 캠프에서 사용할 문제를 선택해야 합니다.

하지만 무작위로 문제를 선택하는 것이 아니라, 다음과 같은 조건을 충족하는 문제 조합을 찾아야 합니다.

- 두 문제 이상을 선택해야 합니다.
- 선택한 문제들의 난이도 합이 특정 범위 내에 있어야 합니다.
- 선택한 문제들 중 가장 어려운 문제와 가장 쉬운 문제의 난이도 차이가 일정 수치 이상이어야 합니다.

즉, 문제를 선택할 때 난이도의 총합뿐만 아니라 문제 난이도의 차이도 중요하게 작용합니다. 학생들이 풀기에 적당한 난이도이면서 다양한 난이도를 경험할 수 있도록 문제를 고르는 것이 목표입니다.

이 문제는 가능한 모든 조합을 탐색해 조건을 만족하는 조합을 찾는 방식으로 해결할 수 있습니다. 문제의 개수가 최대 15개이므로, 모든 경우의 수를 고려하는 완전 탐색 방식으로도 충분히 문제를 해결할 수 있습니다.

## 입출력 조건

입력은 두 줄로 이루어져 있습니다.

- 첫 번째 줄에는 네 개의 정수 N, L, R, X가 주어집니다.
  - N은 문제의 개수를 나타내며 1 이상 15 이하의 값을 가집니다.
  - L과 R은 문제 난이도의 합이 포함되어야 하는 범위를 나타내며, L은 최소값, R은 최대값입니다. L과 R은 1 이상 10억 이하입니다.
  - X는 선택한 문제들 중에서 가장 어려운 문제와 가장 쉬운 문제의 난이도 차이의 최소값을 나타내며, 1 이상 100만 이하입니다.
- 두 번째 줄에는 N개의 정수 A1, A2, ..., AN이 주어지며 각 정수는 문제의 난이도를 나타냅니다. 각 난이도는 1 이상 100만 이하입니다.

출력은 단 한 줄로, 조건을 만족하는 문제 조합의 개수를 출력합니다.

## 접근 방식

이 문제는 완전 탐색 방식으로 접근해야 합니다.

첫 번째로 문제 난이도의 조합을 모두 구해야 합니다. 최소 두 개 이상의 문제를 선택해야 하므로, 부분 집합을 구할 때 크기가 2 이상인 조합을 고려해야 합니다.

두 번째로, 생성된 조합에 대해 난이도의 합이 조건을 만족하는지 확인해야 합니다. 난이도의 합이 L 이상 R 이하인지 확인하여 캠프에서 사용하기 적합한 난이도 범위에 속하는지 검사해야 합니다.

세 번째로, 각 조합에서 가장 어려운 문제와 가장 쉬운 문제의 난이도 차이가 X 이상인지 확인해야 합니다. 이 조건은 다양한 난이도를 경험할 수 있도록 보장하기 위한 것입니다.

이 과정에서 모든 조합을 구하고 조건을 검사하는 방식으로 문제를 해결할 수 있습니다. 조합을 구하는 과정은 itertools 라이브러리의 조합 함수를 사용하면 간단하게 구현할 수 있습니다.

## 풀이 과정

먼저 모든 부분 집합(조합)을 생성하기 위해 반복문을 사용합니다. 문제의 개수가 최대 15개이므로, 2개부터 N개까지의 모든 부분 집합을 구하는 방식으로 접근합니다. 조합을 구할 때는 itertools의 combinations 함수를 사용해 크기가 i인 모든 조합을 생성합니다.

다음으로 생성된 조합에 대해 조건을 검사합니다. 조합의 난이도를 모두 더해 그 값이 L 이상 R 이하인지 확인합니다. 이 과정에서 sum 함수를 사용해 조합의 난이도를 더합니다.

그 후, 선택된 조합에서 가장 어려운 문제와 가장 쉬운 문제의 난이도 차이를 구합니다. max와 min 함수를 사용해 최대 난이도와 최소 난이도를 구하고, 그 차이가 X 이상인지 검사합니다.

모든 조건을 만족하는 조합의 개수를 카운트해 최종적으로 출력합니다.

이 방식은 시간 복잡도가 2의 N승에 비례하는데, N의 최대값이 15이므로 2의 15승(약 32768)까지의 경우의 수를 계산할 수 있습니다. 이는 충분히 빠르게 동작하며, 문제를 해결하는 데 적합한 방식입니다.

## 코드 구현

```python
from itertools import combinations  # itertools의 combinations를 사용해 가능한 모든 조합 생성

def count_valid_combinations(N, L, R, X, A):
    count = 0  # 조건을 만족하는 조합의 개수를 저장할 변수 초기화

    for i in range(2, N + 1):  # 최소 두 문제 이상 선택해야 하므로 2부터 N까지 반복
        for comb in combinations(A, i):  # 난이도 리스트 A에서 i개의 문제를 선택하는 모든 조합 생성
            total = sum(comb)  # 현재 선택된 조합의 난이도 합 계산
            if L <= total <= R and max(comb) - min(comb) >= X:  # 난이도 합이 L 이상 R 이하이고, 난이도 차이가 X 이상인지 확인
                count += 1  # 조건을 만족하면 카운트 증가

    return count  # 최종적으로 조건을 만족하는 조합의 개수를 반환

N, L, R, X = map(int, input().split())  # 문제 개수 N, 난이도 합의 최소 L, 최대 R, 최소 난이도 차이 X 입력
A = list(map(int, input().split()))  # 각 문제의 난이도를 리스트 A로 입력받음

print(count_valid_combinations(N, L, R, X, A))  # 조건을 만족하는 조합의 개수를 출력
```
