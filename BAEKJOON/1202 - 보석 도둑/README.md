# 보석 상자 문제 풀이 및 설명

https://www.acmicpc.net/problem/1202

## 문제 이해

도둑 상덕이는 보석점을 털려고 계획했습니다. 보석점에는 총 \( N \)개의 보석이 있으며, 각각의 보석은 무게 \( M \)과 가격 \( V \)를 가지고 있습니다. 상덕이는 최대 \( K \)개의 가방을 가지고 있으며, 각 가방은 최대 \( C \)의 무게를 담을 수 있습니다. 상덕이는 이 가방들을 사용하여 가능한 한 많은 가격의 보석을 가져가려고 합니다.

따라서 우리의 목표는 주어진 가방들을 사용하여 가져갈 수 있는 보석 가격의 합의 최대값을 계산하는 것입니다.

## 접근 방식

이 문제를 해결하기 위해 다음과 같은 접근 방식을 사용합니다:

1. **정렬**:
   - 보석들을 무게 기준으로 오름차순으로 정렬합니다.
   - 가방들을 최대 무게 기준으로 오름차순으로 정렬합니다.

2. **우선순위 큐 사용**:
   - 각 가방에 대해, 그 가방이 담을 수 있는 보석들을 모두 우선순위 큐(최대 힙)에 넣습니다.
   - 최대 힙을 사용하여 현재 가방에 담을 수 있는 보석 중 가장 가격이 높은 보석을 선택합니다.

## 풀이 과정

1. **입력 데이터 처리**:
   - 입력 데이터를 한 번에 읽고, 이를 공백으로 분리하여 리스트로 만듭니다.
   - 첫 번째 값은 보석의 수 \( N \), 두 번째 값은 가방의 수 \( K \)입니다.
   - 그 다음 \( N \)개의 값은 각 보석의 무게와 가격입니다.
   - 마지막 \( K \)개의 값은 각 가방의 최대 무게입니다.

2. **정렬**:
   - 보석 리스트를 무게 기준으로 오름차순 정렬합니다.
   - 가방 리스트를 최대 무게 기준으로 오름차순 정렬합니다.

3. **우선순위 큐 사용**:
   - 각 가방에 대해, 현재 가방에 담을 수 있는 모든 보석을 최대 힙에 넣습니다.
   - 최대 힙을 사용하여 가격이 가장 높은 보석을 선택하여 결과에 더합니다.

이 과정을 통해 우리는 상덕이가 가져갈 수 있는 보석 가격의 합의 최대값을 효율적으로 계산할 수 있습니다.

## 코드
```python
import heapq  # 힙큐 모듈을 불러옵니다. 이 모듈을 사용하여 우선순위 큐를 구현합니다.

def solve():
    import sys  # 시스템 모듈을 불러옵니다.
    input = sys.stdin.read  # 표준 입력을 읽는 함수를 설정합니다.
    data = input().split()  # 입력 데이터를 공백으로 분리하여 리스트로 만듭니다.
    
    n = int(data[0])  # 보석의 수 N을 입력 받습니다.
    k = int(data[1])  # 가방의 수 K를 입력 받습니다.
    
    jewels = []  # 보석 정보를 저장할 리스트를 초기화합니다.
    index = 2  # 보석 정보가 시작되는 인덱스를 설정합니다.
    for _ in range(n):
        m = int(data[index])  # 보석의 무게를 입력 받습니다.
        v = int(data[index + 1])  # 보석의 가격을 입력 받습니다.
        jewels.append((m, v))  # 보석의 무게와 가격을 튜플로 저장합니다.
        index += 2  # 다음 보석 정보를 가리키도록 인덱스를 증가시킵니다.
    
    bags = []  # 가방 정보를 저장할 리스트를 초기화합니다.
    for _ in range(k):
        c = int(data[index])  # 가방의 최대 무게를 입력 받습니다.
        bags.append(c)  # 가방의 최대 무게를 리스트에 저장합니다.
        index += 1  # 다음 가방 정보를 가리키도록 인덱스를 증가시킵니다.
    
    # 보석을 무게 오름차순으로 정렬합니다.
    jewels.sort()
    # 가방을 무게 오름차순으로 정렬합니다.
    bags.sort()
    
    max_value = 0  # 챙길 수 있는 보석 가격의 합의 최대값을 저장할 변수를 초기화합니다.
    possible_jewels = []  # 현재 가방에 담을 수 있는 보석들을 저장할 최대 힙을 초기화합니다.
    jewel_index = 0  # 보석 리스트의 현재 인덱스를 초기화합니다.
    
    # 각 가방에 대해 반복합니다.
    for bag in bags:
        # 현재 가방에 담을 수 있는 모든 보석을 힙에 넣습니다.
        while jewel_index < len(jewels) and jewels[jewel_index][0] <= bag:
            # 힙에 넣을 때 가격을 음수로 저장하여 최대 힙을 만듭니다.
            heapq.heappush(possible_jewels, -jewels[jewel_index][1])
            jewel_index += 1  # 다음 보석으로 이동합니다.
        # 가장 비싼 보석을 선택합니다.
        if possible_jewels:
            # 힙에서 가장 큰 값을 꺼내어 max_value에 더합니다.
            max_value += -heapq.heappop(possible_jewels)
    
    print(max_value)  # 최종적으로 챙길 수 있는 보석 가격의 합의 최대값을 출력합니다.

if __name__ == "__main__":
    solve()
