# 나무 위의 빗물 문제 풀이 및 설명

https://www.acmicpc.net/problem/17073

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-17073-%eb%82%98%eb%ac%b4-%ec%9c%84%ec%9d%98-%eb%b9%97%eb%ac%bc-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 트리 구조에서 물이 어떻게 분배되는지를 이해하고, 마지막으로 리프 노드들에 얼마나 많은 물이 고이게 되는지 계산하는 문제입니다. 트리의 루트는 1번 노드이며, 1번 노드에는 일정량의 물이 고여 있습니다. 그 외 다른 노드들은 물을 가지고 있지 않습니다. 매초마다 물이 자식 노드로 전달되는데, 자식 노드가 여러 개 있으면 무작위로 선택된 한 자식에게만 물이 전달됩니다.

따라서 이 문제는 물이 더 이상 흐르지 않는 정적인 상태에서 각 리프 노드(자식이 없는 노드)들에 고인 물의 양의 기대값을 구하는 문제입니다. 결국 물은 모두 리프 노드들에 고이게 되고, 각 리프 노드에 고인 물의 양을 계산하여 리프 노드들의 평균 물의 양을 구해야 합니다.

문제를 해결하기 위해서는 트리의 구조를 정확히 파악하고, 물이 어떻게 분배되는지를 이해하는 것이 중요합니다.

---

## 입출력 조건

### 입력

- 첫 번째 줄에는 두 개의 정수 `N`과 `W`가 주어집니다.
  - `N`: 트리의 노드 개수 (2 ≤ N ≤ 500,000)
  - `W`: 1번 노드에 고인 물의 양 (1 ≤ W ≤ 10^9)
- 두 번째 줄부터 `N-1`개의 줄에는 두 개의 정수 `U`와 `V`가 주어집니다. 이는 노드 `U`와 노드 `V`가 연결된 간선이 있다는 뜻입니다.
  - 입력으로 주어지는 트리는 항상 올바른 트리임이 보장되며, 루트는 항상 1번 노드입니다.

### 출력

- 더 이상 물이 움직이지 않을 때, 물이 고인 리프 노드들에 대해서 물의 양 평균을 출력해야 합니다.
- 소수점 3자리 이하의 차이는 모두 정답으로 인정됩니다. 즉, 소수점 10자리까지 출력하는 것이 요구됩니다.

---

## 접근 방식

1. **리프 노드에 주목**: 물은 트리의 리프 노드들에 고이게 됩니다. 자식 노드가 없는 노드들만 물을 받으며, 물이 흐르지 않는 상태가 되었을 때는 물이 리프 노드들에만 분배됩니다.
2. **리프 노드의 개수 구하기**: 각 노드의 자식 여부를 확인하여 리프 노드를 찾아야 합니다. 트리 구조에서 자식이 없는 노드들은 물을 받을 수 있는 최종 목적지입니다. 따라서 리프 노드의 수를 구하는 것이 중요합니다.

3. **물 분배**: 루트 노드(1번 노드)에 고인 물 `W`는 리프 노드들로 분배됩니다. 모든 물이 리프 노드에 동일한 확률로 전달된다고 가정했을 때, 각 리프 노드에 고이는 물의 양은 `W / 리프 노드 개수`가 됩니다.

4. **평균 계산**: 리프 노드에 고인 물의 양의 평균은 `W / 리프 노드의 개수`로 간단하게 구할 수 있습니다. 이것이 이 문제에서 요구하는 최종 답이 됩니다.

---

## 풀이 과정

1. **트리의 입력을 처리**: 우선 트리 구조를 입력받아 이를 인접 리스트 방식으로 저장합니다. 이를 통해 각 노드가 어떤 다른 노드와 연결되어 있는지 파악할 수 있습니다. 이때 `defaultdict`를 사용하면 자동으로 리스트를 생성해주므로 편리합니다.

2. **리프 노드 개수 세기**: 트리 구조를 구성한 후, 각 노드가 자식 노드가 있는지 없는지 확인해야 합니다. 자식 노드가 없는 노드는 리프 노드로 간주되며, 이를 통해 리프 노드의 개수를 셉니다. 1번 노드는 루트 노드이므로 리프 노드가 될 수 없으며, 이를 제외한 나머지 노드에서 자식이 없는 노드들을 찾습니다.

3. **물의 양 계산**: 리프 노드의 개수를 구한 후, 루트 노드에 있는 물 `W`를 리프 노드의 개수로 나누어 각 리프 노드에 고인 물의 양을 계산합니다. 이 문제는 물이 모든 리프 노드로 균등하게 분배된다고 가정하므로, 매우 단순한 계산식으로 해결할 수 있습니다.

4. **결과 출력**: 계산된 결과를 소수점 10자리까지 출력합니다. 문제에서는 소수점 3자리 이하의 오차는 허용한다고 되어 있으므로, 안전하게 소수점 10자리까지 출력하는 것이 좋습니다.

---

## 코드 구현

```python
import sys
from collections import defaultdict

def main():
    # 입력을 받기 위해 sys.stdin.read를 사용하여 전체 데이터를 읽음
    input = sys.stdin.read
    # 입력받은 데이터를 줄 단위로 나누어 리스트로 변환
    data = input().splitlines()

    # 첫 번째 줄에서 노드의 수 N과 1번 노드에 고인 물의 양 W를 추출
    N, W = map(int, data[0].split())

    # 트리의 연결 관계를 저장할 인접 리스트 형태의 딕셔너리를 생성
    tree = defaultdict(list)

    # 두 번째 줄부터 N-1줄까지의 간선 정보를 읽어와 트리 구성
    for line in data[1:]:
        U, V = map(int, line.split())
        tree[U].append(V)  # U 노드에 V 노드를 연결
        tree[V].append(U)  # V 노드에 U 노드를 연결

    # 리프 노드(자식이 없는 노드)의 개수를 셀 변수
    leaf_count = 0
    # 2번 노드부터 N번 노드까지 순회하여 리프 노드 찾기
    for node in range(2, N+1):
        # 각 노드의 연결된 노드 개수가 1개인 경우, 해당 노드는 리프 노드
        if len(tree[node]) == 1:
            leaf_count += 1

    # 리프 노드의 개수로 1번 노드의 물을 나누어 각 리프 노드에 고이는 물의 양을 계산
    result = W / leaf_count
    # 결과를 소수점 10자리까지 출력
    print(f"{result:.10f}")

if __name__ == "__main__":
    # main 함수 호출
    main()
```
