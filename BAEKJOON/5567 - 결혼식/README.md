# 결혼식 문제 풀이 및 설명

<https://www.acmicpc.net/problem/5567>

<https://mayquartet.com/python-파이썬-백준-5567-결혼식/>

## 문제 이해

이 문제는 상근이가 자신의 결혼식에 친구와 친구의 친구를 초대하는 상황을 다루고 있습니다. 상근이의 동기들은 총 `n`명이며, 이 중 상근이와 친구 관계에 있는 사람들, 그리고 그 친구들의 친구까지 결혼식에 초대하려고 합니다. 문제에서 주어지는 것은 각 동기들 간의 친구 관계입니다. 상근이의 학번은 항상 1번으로 고정되어 있으며, 이 정보를 바탕으로 상근이와 직접 친구이거나 친구의 친구인 사람들의 수를 계산하는 것이 목표입니다.

이 문제를 해결하기 위해서는 주어진 친구 관계를 어떻게 처리하고, 상근이와의 관계를 바탕으로 결혼식에 초대할 수 있는 동기들을 찾아내는 방법을 고려해야 합니다. 여기서 중요한 점은 친구 관계는 양방향이므로, 한쪽이 친구라면 반대쪽도 친구로 간주된다는 점입니다. 상근이와 직접 친구인 사람(1단계 친구)과 상근이의 친구의 친구(2단계 친구)를 탐색하는 것이 핵심입니다.

## 입출력 조건

1. **입력**

   - 첫 번째 줄에는 상근이의 동기 수 `n`이 주어지며, 이 값은 2 이상 500 이하입니다.
   - 두 번째 줄에는 친구 관계의 수 `m`이 주어지며, 이 값은 1 이상 10,000 이하입니다.
   - 다음 `m`개의 줄에는 두 명의 동기가 친구 관계에 있다는 정보 `a_i`와 `b_i`가 주어집니다. 이는 `a_i`와 `b_i`가 서로 친구라는 의미입니다. 친구 관계는 양방향으로 성립됩니다.

2. **출력**
   - 첫 번째 줄에 상근이의 결혼식에 초대할 수 있는 동기의 수를 출력합니다. 이때 초대할 수 있는 동기는 상근이와 직접 친구이거나, 상근이의 친구의 친구여야 합니다.

## 접근 방식

이 문제는 기본적으로 그래프 탐색 문제로 볼 수 있습니다. 각 동기를 노드로 보고, 친구 관계를 간선으로 간주하는 무방향 그래프가 형성됩니다. 상근이(1번 학번)를 시작점으로 하여, 이와 연결된 노드를 찾고, 그 다음에는 연결된 친구의 친구까지 탐색하면 됩니다. 이때 사용해야 할 알고리즘은 `BFS(너비 우선 탐색)`입니다. BFS를 사용하면 상근이로부터 1단계 혹은 2단계 이내의 모든 노드를 탐색할 수 있기 때문에 적합한 방식입니다.

`BFS` 알고리즘을 사용하면 상근이의 친구를 먼저 탐색하고, 그 다음에는 친구의 친구를 탐색하는 방식으로 자연스럽게 거리를 확장해나갈 수 있습니다. 이를 통해 상근이와 거리가 1 또는 2인 동기들을 찾아낼 수 있습니다.

<https://mayquartet.com/algorithm-bfs-너비-우선-탐색-알고리즘/>

## 풀이 과정

1. **그래프 생성**

   - 먼저, 각 동기들의 친구 관계를 저장할 그래프를 인접 리스트 방식으로 만듭니다. 노드는 동기들의 학번에 대응하며, 각 동기와 친구 관계에 있는 동기들을 리스트로 저장합니다. 예를 들어, 동기 `a`와 `b`가 친구 관계라면 `graph[a]` 리스트에 `b`를, `graph[b]` 리스트에 `a`를 추가합니다. 이렇게 하면 친구 관계를 양방향으로 쉽게 처리할 수 있습니다.

2. **BFS 탐색 준비**

   - BFS 탐색을 위해 방문 여부를 기록하는 `visited` 리스트와, 상근이로부터 각 동기까지의 거리를 기록할 `distance` 리스트를 생성합니다. 방문 여부는 상근이의 친구 및 친구의 친구를 중복해서 계산하지 않기 위해 필요합니다. 거리는 상근이로부터 친구 관계가 얼마나 떨어져 있는지를 나타내는 데 사용됩니다. 큐에는 상근이(1번 학번)를 시작점으로 넣고 BFS 탐색을 시작합니다.

3. **BFS 탐색 수행**

   - 큐에서 노드를 하나씩 꺼내면서 해당 노드와 연결된 친구 노드를 탐색합니다. 친구 노드가 아직 방문되지 않았다면, 그 노드를 방문 처리하고 상근이로부터의 거리를 현재 노드의 거리 + 1로 설정합니다. 이후 그 친구 노드를 큐에 추가하여 탐색을 이어갑니다. 이렇게 BFS를 수행하면 상근이와 직접 연결된 친구들(거리 1)과, 친구의 친구(거리 2)를 모두 탐색할 수 있습니다.

4. **결과 계산**

   - BFS 탐색이 완료된 후, 상근이로부터의 거리가 1 또는 2인 노드를 모두 세어서 초대할 동기의 수를 계산합니다. 이때 상근이 자신은 제외해야 하므로, 거리가 0인 상근이를 제외한 결과만을 계산합니다.

5. **결과 출력**
   - 최종적으로 계산된 초대할 수 있는 동기의 수를 출력하면 됩니다.

## 코드 구현

```python
from collections import deque  # BFS 탐색을 위한 deque 모듈을 임포트

def bfs(start, graph, n):  # BFS 탐색을 수행하는 함수 정의
    visited = [False] * (n + 1)  # 방문 여부를 기록할 리스트, n명의 동기들에 대해 False로 초기화
    distance = [-1] * (n + 1)  # 상근이로부터의 거리를 기록할 리스트, -1로 초기화
    queue = deque([start])  # BFS 탐색을 위한 큐, 상근이의 학번인 1을 시작점으로 설정

    visited[start] = True  # 상근이의 학번을 방문 처리
    distance[start] = 0  # 상근이의 거리는 0으로 설정

    while queue:  # 큐가 빌 때까지 BFS 탐색을 진행
        current = queue.popleft()  # 큐에서 현재 노드를 꺼내옴

        for neighbor in graph[current]:  # 현재 노드에 연결된 친구들을 확인
            if not visited[neighbor]:  # 방문하지 않은 친구라면
                visited[neighbor] = True  # 방문 처리
                distance[neighbor] = distance[current] + 1  # 친구의 거리는 현재 노드의 거리 + 1
                queue.append(neighbor)  # 친구를 큐에 추가

    invite_count = 0  # 초대할 친구의 수를 세는 변수 초기화
    for i in range(2, n + 1):  # 상근이(1번 학번) 이외의 친구들에 대해
        if 0 < distance[i] <= 2:  # 상근이로부터의 거리가 1 또는 2인 경우
            invite_count += 1  # 초대할 수 있는 친구로 카운트

    return invite_count  # 초대할 친구 수 반환

n = int(input())  # 동기들의 수 입력받기
m = int(input())  # 친구 관계의 수 입력받기

graph = [[] for _ in range(n + 1)]  # 각 동기의 친구 관계를 저장할 그래프 생성 (1부터 n까지)

for _ in range(m):  # 주어진 친구 관계 수만큼 반복
    a, b = map(int, input().split())  # 각 친구 관계를 입력받기
    graph[a].append(b)  # a와 b는 친구 관계이므로 a에 b를 추가
    graph[b].append(a)  # b와 a도 친구 관계이므로 b에 a를 추가

result = bfs(1, graph, n)  # 상근이(1번 학번)에서 BFS 탐색 시작
print(result)  # 결혼식에 초대할 친구 수 출력
```
