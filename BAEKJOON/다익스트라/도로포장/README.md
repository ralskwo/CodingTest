# 도로 포장 풀이 및 설명

https://www.acmicpc.net/problem/1162

## 문제 이해

이 문제는 서울(도시 1)에서 포천(도시 N)까지 종용이가 여행하는 데 필요한 최소 시간을 찾는 것입니다. 종용이는 최대 \( K \)개의 도로를 이동 시간을 0으로 만들 수 있는 능력을 가지고 있습니다. 우리는 이러한 패치를 효과적으로 사용하여 전체 여행 시간을 최소화하는 것이 목표입니다.

## 입출력 조건

**입력:**
1. 첫 번째 줄에는 세 개의 정수가 주어집니다:
   - \( N \) (1 ≤ \( N \) ≤ 10,000): 도시의 수.
   - \( M \) (1 ≤ \( M \) ≤ 50,000): 도로의 수.
   - \( K \) (1 ≤ \( K \) ≤ 20): 패치할 수 있는 최대 도로 수.
2. 다음 \( M \)개의 줄에는 각각 세 개의 정수가 포함됩니다:
   - \( u \)와 \( v \) (1 ≤ \( u, v \) ≤ \( N \)): 도로로 연결된 도시.
   - \( w \) (1 ≤ \( w \) < 1,000,000): 해당 도로의 이동 시간.

**출력:**
- 출력은 종용이가 도시 1에서 도시 N까지 여행하는 데 필요한 최소 시간을 나타내는 단일 정수입니다. 이때 최대 \( K \)개의 도로를 패치하여 이동 시간을 0으로 만들 수 있습니다.

## 접근 방법

이 문제를 해결하기 위해 다익스트라 알고리즘을 약간 수정하여 패치 가능한 도로를 고려해야 합니다. 각 도시에 도달할 때까지의 최단 경로를 \( K \)개의 패치를 사용하여 추적해야 합니다. 이는 우선순위 큐(최소 힙)와 동적 프로그래밍을 사용하여 각 도시에 특정 패치 수를 사용하여 도달하는 최소 시간을 저장함으로써 효율적으로 수행할 수 있습니다.

## 풀이 과정

1. **그래프 표현:**
   - 인접 리스트를 사용하여 그래프를 표현합니다. 각 도시는 인접한 도시와 그 도시에 도달하는 시간을 튜플로 저장합니다.

2. **우선순위 큐 초기화:**
   - 현재 시간, 현재 도시, 사용된 패치 수를 저장하기 위해 우선순위 큐(최소 힙)를 초기화합니다.
   - 도시 1에서 시간 0, 패치 수 0으로 시작합니다.

3. **동적 프로그래밍 테이블:**
   - 2차원 리스트(DP 테이블)를 생성하여 `dp[u][k]`가 도시 `u`에 `k`개의 패치를 사용하여 도달하는 최소 시간을 나타내도록 합니다. 시작점인 `dp[1][0]`은 0으로 설정합니다.

4. **패치를 고려한 다익스트라 알고리즘:**
   - 우선순위 큐에서 노드를 추출하여 처리합니다:
     - 추출된 시간이 이미 기록된 시간보다 큰 경우, 다음 노드를 처리합니다.
     - 현재 도시와 연결된 모든 인접 도시를 확인합니다:
       - 패치를 사용할 수 있는 경우, 패치를 사용한 후의 시간을 업데이트합니다.
       - 패치를 사용하지 않는 경우, 기존 이동 시간을 더한 후의 시간을 업데이트합니다.
     - 이 업데이트된 정보를 우선순위 큐에 추가합니다.

5. **결과 반환:**
   - DP 테이블의 마지막 행(`dp[N]`)에서 최소 값을 찾아 도시 N에 도달하는 최소 시간을 반환합니다.

## 코드 구현
```python
import heapq  # 우선순위 큐를 사용하기 위해 heapq 모듈을 임포트합니다.
import sys  # 표준 입력을 읽기 위해 sys 모듈을 임포트합니다.

# 최소 여행 시간을 계산하는 함수 정의
def minimum_travel_time(N, M, K, roads):
    # 그래프를 인접 리스트로 표현하기 위해 초기화합니다.
    graph = [[] for _ in range(N + 1)]
    
    # 주어진 도로 정보를 기반으로 그래프를 구성합니다.
    for u, v, w in roads:
        graph[u].append((v, w))  # 도시 u에서 v로 가는 도로와 시간을 추가합니다.
        graph[v].append((u, w))  # 도시 v에서 u로 가는 반대 방향 도로도 추가합니다.
    
    # 우선순위 큐를 사용하여 최단 경로를 계산합니다.
    # (시간, 현재 도시, 사용한 패치 수) 형태의 튜플을 저장합니다.
    pq = [(0, 1, 0)]  # 시작점 설정: (시간 0, 도시 1, 패치 수 0)
    
    # DP 테이블을 초기화합니다.
    # dp[u][k]는 도시 u까지 k개의 패치를 사용했을 때의 최소 시간을 의미합니다.
    dp = [[float('inf')] * (K + 1) for _ in range(N + 1)]
    dp[1][0] = 0  # 출발지인 도시 1의 초기값을 0으로 설정합니다.
    
    # 우선순위 큐가 빌 때까지 반복합니다.
    while pq:
        time, u, k = heapq.heappop(pq)  # 우선순위 큐에서 현재 가장 짧은 시간의 요소를 추출합니다.
        
        # 현재 시간이 이미 기록된 시간보다 크면 무시합니다.
        if dp[u][k] < time:
            continue
        
        # 현재 도시 u와 연결된 모든 도시 v에 대해
        for v, w in graph[u]:
            # 도로를 패치할 경우
            if k < K and time < dp[v][k + 1]:
                dp[v][k + 1] = time  # 패치 후의 시간을 갱신합니다.
                heapq.heappush(pq, (time, v, k + 1))  # 우선순위 큐에 추가합니다.
            
            # 도로를 패치하지 않을 경우
            if time + w < dp[v][k]:
                dp[v][k] = time + w  # 시간을 갱신합니다.
                heapq.heappush(pq, (time + w, v, k))  # 우선순위 큐에 추가합니다.
    
    # 도시 N에 도달하는 최소 시간을 반환합니다.
    return min(dp[N])

# 입력을 읽습니다.
input = sys.stdin.read
data = input().split()  # 입력 데이터를 공백으로 분리합니다.
N = int(data[0])  # 첫 번째 값은 도시의 수입니다.
M = int(data[1])  # 두 번째 값은 도로의 수입니다.
K = int(data[2])  # 세 번째 값은 패치할 수 있는 최대 도로 수입니다.

# 도로 정보를 읽습니다.
roads = []
index = 3  # 도로 정보는 네 번째 요소부터 시작합니다.
for _ in range(M):
    u = int(data[index])  # 도로의 시작 도시를 읽습니다.
    v = int(data[index+1])  # 도로의 도착 도시를 읽습니다.
    w = int(data[index+2])  # 도로의 시간을 읽습니다.
    roads.append((u, v, w))  # 도로 정보를 리스트에 추가합니다.
    index += 3  # 다음 도로 정보를 가리킵니다.

# 최소 여행 시간을 계산합니다.
result = minimum_travel_time(N, M, K, roads)
# 결과를 출력합니다.
print(result)
