# 공장 문제 풀이 및 설명

<https://www.acmicpc.net/problem/7578>

<https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-7578-%ea%b3%b5%ec%9e%a5-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/>

## 문제 이해

이 문제는 두 열에 걸쳐 N개의 기계가 각각 배치되어 있고, 각 기계들은 케이블로 연결되어 있는 상태에서 케이블이 서로 교차하는 횟수를 계산하는 문제입니다. A열에 있는 각 기계는 B열에 있는 기계와 하나씩 짝을 이루며, 기계들의 순서는 무작위로 배치되어 있어 케이블이 엉켜 있는 상황입니다. 목표는 기계의 위치를 바꾸지 않고 케이블을 직선으로 만들기 위해, 서로 교차하는 케이블 쌍의 개수를 정확하게 세는 것입니다.

문제를 해결하기 위해서는 A열의 기계들이 B열의 기계들과 어떤 방식으로 연결되어 있는지 파악하고, 그 과정에서 발생하는 케이블 교차를 찾는 것이 핵심입니다. 이 문제는 결국 **배열 내의 역순 쌍을 찾는 문제**로 변환할 수 있습니다. 역순 쌍이란, 두 요소가 원래 순서에서 반대 방향으로 정렬되어 있는 경우를 의미하며, 이러한 역순 쌍의 개수를 세면 교차하는 케이블 쌍의 개수를 구할 수 있습니다.

## 입출력 조건

- **입력**:

  1. 첫 번째 줄에는 기계의 수 N이 주어집니다. (1 ≤ N ≤ 500,000)
  2. 두 번째 줄에는 A열에 위치한 N개의 기계 식별번호가 공백으로 구분되어 주어집니다. 이 식별번호들은 모두 0 이상 1,000,000 이하의 정수이며, 서로 다른 번호로 이루어져 있습니다.
  3. 세 번째 줄에는 B열에 위치한 N개의 기계 식별번호가 공백으로 구분되어 주어집니다. 이 식별번호들도 A열과 마찬가지로 0 이상 1,000,000 이하의 정수이며, 서로 다른 번호로 이루어져 있습니다.

- **출력**:
  - 서로 교차하는 케이블 쌍의 개수를 정수 형태로 출력합니다.

## 접근 방식

이 문제를 해결하기 위해서는 **역순 쌍(Inversion Count)**을 계산하는 방식으로 접근할 수 있습니다. A열의 기계와 B열의 기계가 각각 짝을 이루고 있고, 이 짝이 원래의 순서대로 정렬되어 있지 않다면 그만큼 케이블이 교차하는 것입니다. 이러한 교차를 찾기 위해서는 B열의 순서를 A열의 순서대로 재배열한 후, 이 배열에서 역순 쌍의 개수를 세면 됩니다.

역순 쌍을 빠르게 찾는 알고리즘은 일반적으로 **세그먼트 트리**나 **펜윅 트리(바이너리 인덱스 트리, BIT)**를 사용합니다. 이 자료구조들은 구간 합을 빠르게 계산하고 업데이트할 수 있기 때문에, 대량의 데이터에서도 효율적인 처리가 가능합니다.

세부 접근 방식은 다음과 같습니다:

1. A열의 기계 식별번호를 B열에서 몇 번째 위치에 있는지 매핑합니다.
2. B열의 순서를 A열의 순서에 맞게 재배열합니다.
3. 이 재배열된 B열에서 역순 쌍을 구하면, 그 수가 곧 교차하는 케이블 쌍의 개수입니다.
4. 역순 쌍을 구하기 위해 펜윅 트리나 세그먼트 트리를 사용하여 구간 합을 계산하고 업데이트합니다.

## 풀이 과정

1. **입력 처리**:
   - 먼저, A열과 B열의 기계 식별번호를 입력받습니다. A열과 B열의 식별번호는 모두 0 이상 1,000,000 이하이며, 서로 다른 번호로 이루어져 있습니다.
2. **A열과 B열 매핑**:
   - A열에 있는 기계들의 식별번호를 B열의 인덱스와 매핑합니다. 이를 통해 A열의 기계가 B열에서 몇 번째 위치에 있는지 알 수 있습니다. 예를 들어, A열의 첫 번째 기계가 B열에서 세 번째 위치에 있다면, 그 관계를 기록해둡니다.
3. **B열의 순서를 A열의 순서로 재배열**:
   - 이제 B열의 기계들이 A열의 순서대로 연결될 수 있도록 B열을 재배열합니다. 즉, B열의 기계들이 A열의 각 기계와 연결될 수 있는 위치로 변환된 순서를 생성합니다.
4. **역순 쌍 계산**:
   - 재배열된 B열의 순서에서 역순 쌍을 계산합니다. 역순 쌍이란, 배열에서 앞에 있는 값이 뒤에 있는 값보다 큰 경우를 의미합니다. 이 문제에서는 역순 쌍의 개수가 곧 교차하는 케이블의 수와 동일합니다.
5. **펜윅 트리 또는 세그먼트 트리 사용**:
   - 역순 쌍을 빠르게 계산하기 위해 펜윅 트리(또는 세그먼트 트리)를 사용합니다. 펜윅 트리는 구간 합과 값의 업데이트를 \(O(\log N)\) 시간 복잡도로 처리할 수 있어, 배열의 크기가 커도 효율적으로 역순 쌍을 구할 수 있습니다.
   - B열의 배열을 오른쪽에서 왼쪽으로 순회하면서, 현재 값보다 작은 값들이 앞에 몇 개 있었는지 계산합니다. 이를 통해 교차하는 케이블의 개수를 구합니다.
6. **결과 출력**:
   - 계산된 역순 쌍의 개수를 출력하여, 교차하는 케이블 쌍의 수를 구합니다.

이 과정에서 펜윅 트리를 사용하면 시간 복잡도가 \(O(N \log N)\)로, 문제에서 제시된 최대 N값인 500,000에서도 효율적으로 문제를 해결할 수 있습니다.

## 코드 구현

```python
class FenwickTree:
    def __init__(self, size):
        # 주어진 크기(size)를 받아서 펜윅 트리 초기화
        self.size = size
        # 크기 + 1 만큼의 배열을 0으로 초기화 (1-based index를 사용하기 때문에 크기를 하나 더 늘림)
        self.tree = [0] * (size + 1)

    def update(self, index, value):
        # index 위치에서 value 값을 트리에 더하고, 영향을 받는 상위 인덱스들도 갱신
        while index <= self.size:
            # 해당 인덱스에 value 값을 더함
            self.tree[index] += value
            # index를 상위 노드로 이동 (index += index & -index)
            index += index & -index

    def query(self, index):
        # 1부터 index까지의 합을 구하는 함수
        sum = 0
        # index가 0보다 큰 동안 구간 합을 계산
        while index > 0:
            # 현재 index의 값을 sum에 더함
            sum += self.tree[index]
            # index를 하위 노드로 이동 (index -= index & -index)
            index -= index & -index
        # 1부터 주어진 index까지의 합을 반환
        return sum

def count_inversions(N, A, B):
    # A열의 각 식별번호를 인덱스로 변환하여 B열에서의 위치를 찾기 위한 매핑을 생성
    position_map = {number: i + 1 for i, number in enumerate(A)}
    # B열의 각 번호를 A열의 순서에 맞게 재배열
    mapped_B = [position_map[number] for number in B]

    # 펜윅 트리를 초기화
    fenwick_tree = FenwickTree(N)
    # 역순 쌍의 개수를 저장할 변수
    inversion_count = 0

    # B열을 재배열한 리스트를 오른쪽에서 왼쪽으로 순회
    for i in range(N - 1, -1, -1):
        # 현재 인덱스보다 작은 값이 앞에 몇 개 있는지 펜윅 트리로 계산하여 역순 쌍 개수에 더함
        inversion_count += fenwick_tree.query(mapped_B[i] - 1)
        # 현재 값을 펜윅 트리에 업데이트
        fenwick_tree.update(mapped_B[i], 1)

    # 역순 쌍의 총 개수를 반환
    return inversion_count

# 입력을 처리하여 N, A열, B열 값을 받음
N = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))

# 교차하는 케이블 쌍의 개수를 계산하여 출력
print(count_inversions(N, A, B))
```
