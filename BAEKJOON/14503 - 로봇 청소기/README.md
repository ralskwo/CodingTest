# 로봇 청소기 문제 풀이 및 설명

https://www.acmicpc.net/problem/14503

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-14503-%eb%a1%9c%eb%b4%87-%ec%b2%ad%ec%86%8c%ea%b8%b0-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 로봇 청소기가 방 안을 돌아다니며 청소하는 과정을 시뮬레이션하는 문제입니다. 로봇은 주어진 규칙에 따라 움직이며, 움직일 수 없을 때까지 동작을 반복합니다. 문제를 해결하려면 로봇의 동작 규칙을 정확히 이해하고 이를 코드로 구현해야 합니다. 문제는 다음과 같은 관점에서 이해해야 합니다:

1. **방의 크기와 상태**: 방은 `N x M` 크기의 2차원 공간이며, 각 칸은 벽 또는 빈 칸으로 나누어져 있습니다. 벽은 로봇이 이동할 수 없는 영역이며, 빈 칸은 청소할 수 있는 공간입니다.
2. **로봇 청소기의 위치와 방향**: 로봇 청소기는 특정한 위치 `(r, c)`에서 시작하며, 처음에 바라보는 방향이 주어집니다. 방향은 북, 동, 남, 서 중 하나이며, 로봇은 이 방향에 따라 움직입니다.
3. **동작 규칙**: 로봇 청소기는 주어진 규칙에 따라 행동합니다. 현재 위치를 청소하고, 주변 4칸을 확인하여 청소할 수 있는 빈 칸이 있다면 해당 칸으로 이동합니다. 청소할 수 있는 칸이 없으면 후진하거나 작동을 멈춥니다. 이 규칙을 정확히 구현하는 것이 핵심입니다.
4. **시뮬레이션의 종료 조건**: 로봇 청소기는 더 이상 움직일 수 없는 상황이 되면 작동을 멈춥니다. 이때까지 청소한 칸의 개수를 구해야 합니다.

## 입출력 조건

**입력 조건**

1. 첫째 줄에 방의 크기 `N`과 `M`이 공백으로 구분되어 주어집니다. `3 ≤ N, M ≤ 50`의 범위를 가지며, 이는 방의 최소 및 최대 크기를 나타냅니다.
2. 둘째 줄에 로봇 청소기의 초기 위치 `(r, c)`와 방향 `d`가 공백으로 구분되어 주어집니다.
   - `r`과 `c`는 로봇 청소기의 시작 좌표를 나타내며, 각각 `0 ≤ r < N` 및 `0 ≤ c < M`의 범위를 가집니다.
   - `d`는 로봇의 초기 방향을 나타내며, 0: 북쪽, 1: 동쪽, 2: 남쪽, 3: 서쪽을 의미합니다.
3. 셋째 줄부터 `N`개의 줄에 방의 상태가 주어집니다. 각 줄은 `M`개의 정수로 구성되며, 각 정수는 해당 칸의 상태를 나타냅니다.
   - 0은 청소되지 않은 빈 칸을 의미하며, 로봇이 이동 및 청소할 수 있는 칸입니다.
   - 1은 벽을 의미하며, 로봇이 이동할 수 없는 칸입니다.
4. 로봇 청소기가 있는 초기 위치는 항상 빈 칸(0)입니다.

**출력 조건**

- 로봇 청소기가 작동을 시작한 후 작동을 멈출 때까지 청소한 칸의 개수를 정수로 출력합니다.

## 접근 방식

이 문제를 해결하기 위해서는 시뮬레이션과 탐색을 결합한 방식으로 접근해야 합니다. 로봇 청소기의 동작 규칙을 시뮬레이션하여 문제를 해결할 수 있습니다. 다음과 같은 알고리즘 및 방식을 사용할 수 있습니다:

1. **시뮬레이션**: 문제의 핵심은 로봇 청소기의 동작을 정확히 시뮬레이션하는 것입니다. 로봇이 한 칸씩 이동하며 주변 상황을 확인하고, 규칙에 따라 행동하도록 구현해야 합니다.
2. **4방향 탐색**: 로봇은 현재 위치에서 주변 4칸을 탐색하며 청소하지 않은 빈 칸이 있는지 확인합니다. 이 탐색은 현재 로봇의 방향을 기준으로 반시계 방향으로 이루어집니다. 이를 위해 방향 벡터를 사용하여 각 방향으로의 이동을 계산합니다.
3. **조건에 따른 동작**: 문제에서 주어진 동작 규칙을 정확히 구현해야 합니다. 각 단계에서 청소 여부, 주변 칸 확인, 방향 전환, 후진 등의 조건을 처리해야 합니다.
4. **반복과 종료 조건**: 로봇 청소기가 더 이상 움직일 수 없는 상황이 되면 작동을 멈추도록 시뮬레이션을 반복합니다. 이때까지 청소한 칸의 개수를 출력합니다.

## 풀이 과정

1. **초기 설정**:

   - 방의 크기, 로봇 청소기의 초기 위치와 방향, 방의 상태를 입력받습니다.
   - 로봇의 이동을 위한 방향 벡터를 설정합니다. 방향은 북, 동, 남, 서를 기준으로 반시계 방향으로 순서대로 정의합니다.

2. **청소기 동작 시뮬레이션**:

   - 로봇 청소기가 현재 위치를 청소하지 않았다면 해당 칸을 청소하고 청소한 칸의 수를 증가시킵니다.
   - 현재 방향을 기준으로 반시계 방향으로 90도씩 회전하며 4방향을 모두 확인합니다.
     - 각 방향마다 이동할 칸이 청소되지 않은 빈 칸인 경우 해당 방향으로 이동합니다.
     - 이때, 한 번이라도 청소할 수 있는 칸이 있으면 다른 방향은 더 이상 확인하지 않고 다음 단계로 넘어갑니다.
   - 만약 4방향 모두 청소할 수 있는 칸이 없는 경우, 현재 방향을 유지한 채로 후진을 시도합니다.
     - 후진할 수 있는지 확인하고, 후진할 수 있다면 후진합니다.
     - 후진할 수 없다면, 즉 뒤쪽이 벽이라면 작동을 멈춥니다.

3. **종료와 결과 출력**:
   - 로봇이 더 이상 움직일 수 없는 상황에 도달하면 반복을 종료합니다.
   - 작동이 멈추었을 때까지 청소한 칸의 수를 출력합니다.

## 코드 구현

```python
def robot_cleaner():
    # 방의 크기 N과 M을 입력받음
    N, M = map(int, input().split())
    # 로봇 청소기의 시작 위치 (r, c)와 바라보는 방향 d를 입력받음
    r, c, d = map(int, input().split())
    # 방의 상태를 2차원 리스트로 입력받음
    room = [list(map(int, input().split())) for _ in range(N)]

    # 로봇이 이동할 때 사용할 방향 벡터 정의: 북, 동, 남, 서
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]

    # 청소한 칸의 수를 저장할 변수 초기화
    cleaned_count = 0

    # 로봇 청소기의 동작을 무한 루프를 통해 시뮬레이션
    while True:
        # 현재 칸이 청소되지 않은 경우, 청소함
        if room[r][c] == 0:
            room[r][c] = 2  # 청소한 칸은 2로 표시
            cleaned_count += 1  # 청소한 칸의 수를 증가시킴

        # 주변 4칸 중 청소할 수 있는 칸이 있는지 확인하기 위한 플래그
        has_cleanable_adjacent = False
        # 4방향을 모두 확인
        for i in range(4):
            # 현재 방향에서 반시계 방향으로 90도 회전
            d = (d + 3) % 4
            # 회전 후 이동할 위치 계산
            nr, nc = r + directions[d][0], c + directions[d][1]

            # 이동할 위치가 청소되지 않은 빈 칸인 경우
            if room[nr][nc] == 0:
                # 그 방향으로 한 칸 전진
                r, c = nr, nc
                # 청소할 수 있는 칸이 있음을 표시
                has_cleanable_adjacent = True
                # 한 칸 전진했으므로 다음 동작을 위해 반복문 종료
                break

        # 4방향 모두 확인했는데 청소할 수 있는 인접 칸이 없는 경우
        if not has_cleanable_adjacent:
            # 바라보는 방향을 유지한 채로 후진할 위치 계산
            back_d = (d + 2) % 4
            back_r, back_c = r + directions[back_d][0], c + directions[back_d][1]

            # 후진할 위치가 벽이 아닌 경우
            if room[back_r][back_c] != 1:
                # 후진함
                r, c = back_r, back_c
            else:
                # 후진할 수 없는 경우 작동 멈춤
                break

    # 로봇 청소기가 청소한 칸의 수를 출력
    print(cleaned_count)

# 로봇 청소기 시뮬레이션 함수 실행
robot_cleaner()
```
