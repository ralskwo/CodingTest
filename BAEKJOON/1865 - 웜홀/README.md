# 웜홀 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1865>

<https://mayquartet.com/python-백준-1865-웜홀/>

## 문제 이해

이 문제는 그래프에서 **음수 사이클**을 탐지하는 문제로, 주어진 조건을 통해 특정 경로를 따라 이동하면 **시간이 되돌아가는 경로가 존재하는지**를 확인하는 문제입니다.

**월드나라**에는 `N`개의 지점이 있고, 지점 간에는 `M`개의 도로와 `W`개의 웜홀이 있습니다. 도로는 양방향으로 이동이 가능하며, 도로를 통해 이동하는 데 시간이 양수로 소요됩니다. 반면, 웜홀은 단방향으로만 이동이 가능하며, 이동 시 시간이 감소하는 음수 값의 시간이 소요됩니다. 즉, 웜홀을 통과하면 시간을 되돌아가는 것처럼 느껴지는 효과가 발생합니다.

이 문제에서 백준이는 어떤 지점에서 출발해 다른 지점을 거쳐 다시 출발 지점으로 돌아왔을 때, 출발 시간보다 시간이 되돌아간 상황이 발생하는지 궁금해하고 있습니다. 이를 확인하기 위해서는 **음수 사이클**이 존재하는지 여부를 확인해야 합니다. 음수 사이클이란, 특정 경로를 따라 순환했을 때 시간이 음수 값이 되는 경우를 의미하며, 이 경우 시간 여행이 가능하다고 볼 수 있습니다. 따라서, 문제는 **음수 사이클이 존재하는지를 판별하여** 결과를 출력하는 것이 목표입니다.

## 입출력 조건

### 입력 조건

- 첫 번째 줄에는 테스트 케이스의 개수 `TC`가 주어집니다. (`1 ≤ TC ≤ 5`)
- 각 테스트 케이스는 아래와 같은 순서로 주어집니다:
  - 첫 줄에는 지점의 수 `N`, 도로의 개수 `M`, 웜홀의 개수 `W`가 주어집니다. (`1 ≤ N ≤ 500`, `1 ≤ M ≤ 2500`, `1 ≤ W ≤ 200`)
  - 다음 `M`개의 줄에는 각 도로의 정보가 `S`, `E`, `T` 형태로 주어집니다.
    - `S`와 `E`는 도로로 연결된 두 지점의 번호이고, `T`는 이 도로를 통해 이동하는 데 걸리는 시간입니다.
    - 도로는 양방향으로 연결되어 있으며, 도로의 시간 `T`는 양수입니다.
  - 다음 `W`개의 줄에는 각 웜홀의 정보가 `S`, `E`, `T` 형태로 주어집니다.
    - `S`는 웜홀의 시작 지점, `E`는 도착 지점입니다. `T`는 줄어드는 시간으로 음수 값입니다. 웜홀은 단방향으로만 이동이 가능합니다.

### 출력 조건

- 각 테스트 케이스마다 시간이 되돌아가는 음수 사이클이 존재하면 `"YES"`를 출력하고, 존재하지 않으면 `"NO"`를 출력합니다.

## 접근 방식

이 문제는 그래프에서 **음수 사이클을 탐지**하는 문제이므로 **벨만-포드(Bellman-Ford) 알고리즘**을 활용하는 것이 적절합니다. 벨만-포드 알고리즘은 **단일 출발점**에서 다른 모든 지점까지의 최단 경로를 구할 수 있으며, 특히 **음수 가중치**가 포함된 그래프에서도 사용할 수 있는 알고리즘입니다.

1. **음수 사이클 탐지**: 벨만-포드 알고리즘은 경로를 `N-1`번만큼 반복해서 갱신한 후, 마지막 `N`번째 반복에서 거리 갱신이 발생하면 음수 사이클이 존재한다고 판단할 수 있습니다.
2. **모든 지점에서 출발**: 음수 사이클이 어디에 위치해 있는지 알 수 없기 때문에 모든 지점을 출발 지점으로 설정하여 벨만-포드 알고리즘을 수행해야 합니다. 모든 지점에서 출발하여 음수 사이클을 찾으면, 해당 테스트 케이스에 대해 `"YES"`를 출력하고, 모든 출발점에서 음수 사이클이 발견되지 않으면 `"NO"`를 출력합니다.
3. **복수의 도로 및 웜홀 처리**: 입력으로 주어지는 도로는 양방향이므로 각각의 도로를 양방향으로 간선 리스트에 추가해야 하며, 웜홀은 단방향이므로 주어진 방향으로만 추가하면 됩니다.

## 풀이 과정

1. **입력 데이터를 처리**:

   - 먼저, 모든 입력을 읽어온 후 테스트 케이스 개수 `TC`를 확인합니다.
   - 각 테스트 케이스마다 지점의 수 `N`, 도로의 수 `M`, 웜홀의 수 `W`를 차례대로 읽어옵니다.

2. **간선 리스트 구성**:

   - 도로와 웜홀의 정보를 저장할 리스트 `edges`를 생성합니다.
   - 도로는 양방향이므로 `(S, E, T)`와 `(E, S, T)`의 양방향으로 `edges` 리스트에 추가합니다.
   - 웜홀은 단방향으로만 이동할 수 있으며, 시간이 감소하므로 `(S, E, -T)`로 `edges` 리스트에 추가합니다.

3. **모든 지점에서 벨만-포드 알고리즘 실행**:

   - 모든 지점을 출발점으로 설정하여 벨만-포드 알고리즘을 실행합니다.
   - `N`번 반복하는 루프에서 거리 갱신이 발생하는지 확인하며, `N-1`번째 반복 이후에도 갱신이 발생하면 음수 사이클이 존재한다고 판단합니다.
   - 만약 음수 사이클이 발견되면 해당 테스트 케이스에 대해 `"YES"`를 출력 리스트에 저장하고, 음수 사이클 탐색을 중단합니다.

4. **출력 준비**:
   - 모든 테스트 케이스에 대해 결과를 저장한 후, 한 번에 출력합니다.

## 코드 구현

```python
import sys
input = sys.stdin.read  # 입력을 빠르게 처리하기 위해 sys.stdin.read를 사용하여 한 번에 모든 입력을 받음

def bellman_ford(n, edges, start):
    INF = float('inf')  # 무한대를 의미하는 값을 설정
    dist = [INF] * (n + 1)  # 시작 지점에서 다른 지점까지의 최단 거리를 저장하는 배열, 초기에는 모두 무한대 값으로 설정
    dist[start] = 0  # 시작 지점(start)의 거리를 0으로 초기화

    for i in range(n):  # 지점의 개수 n만큼 반복
        updated = False  # 현재 반복에서 거리 갱신이 있었는지 확인하는 변수
        for u, v, w in edges:  # 모든 간선에 대해 반복
            if dist[u] != INF and dist[u] + w < dist[v]:  # 시작 지점까지의 거리가 무한대가 아니고, 갱신 가능할 때
                dist[v] = dist[u] + w  # 현재 간선의 도착 지점까지의 거리 갱신
                updated = True  # 거리 갱신이 있었음을 표시
                if i == n - 1:  # n번째 반복에서 갱신이 발생하면 음수 사이클이 존재
                    return True  # 음수 사이클이 있음을 나타내기 위해 True 반환
        if not updated:  # 거리 갱신이 없으면 더 이상 확인할 필요가 없음
            break  # 반복 종료
    return False  # 음수 사이클이 없음을 나타내기 위해 False 반환

def main():
    data = input().strip().split()  # 입력을 받아 공백을 기준으로 나누고, 리스트로 저장
    idx = 0  # 입력 데이터에서 현재 위치를 가리키는 인덱스
    tc = int(data[idx])  # 테스트 케이스 개수를 첫 번째 값으로 설정
    idx += 1  # 다음 인덱스로 이동
    results = []  # 각 테스트 케이스 결과를 저장할 리스트

    for _ in range(tc):  # 테스트 케이스 개수만큼 반복
        n = int(data[idx])  # 지점의 수
        m = int(data[idx + 1])  # 도로의 개수
        w = int(data[idx + 2])  # 웜홀의 개수
        idx += 3  # 다음 인덱스로 이동
        edges = []  # 도로와 웜홀의 정보를 저장할 리스트

        for __ in range(m):  # 도로의 개수만큼 반복
            s = int(data[idx])  # 도로의 시작 지점
            e = int(data[idx + 1])  # 도로의 끝 지점
            t = int(data[idx + 2])  # 도로의 이동 시간
            edges.append((s, e, t))  # 도로 정보 추가 (양방향)
            edges.append((e, s, t))  # 양방향이므로 역방향도 추가
            idx += 3  # 다음 인덱스로 이동

        for __ in range(w):  # 웜홀의 개수만큼 반복
            s = int(data[idx])  # 웜홀의 시작 지점
            e = int(data[idx + 1])  # 웜홀의 끝 지점
            t = int(data[idx + 2])  # 줄어드는 시간 (음수 가중치)
            edges.append((s, e, -t))  # 웜홀 정보 추가 (단방향)
            idx += 3  # 다음 인덱스로 이동

        has_negative_cycle = False  # 음수 사이클 존재 여부를 확인하는 변수
        for start in range(1, n + 1):  # 모든 지점을 시작점으로 설정하여 음수 사이클 탐지 시도
            if bellman_ford(n, edges, start):  # 음수 사이클이 발견되면
                has_negative_cycle = True  # 음수 사이클 존재를 표시
                break  # 더 이상 탐색할 필요가 없으므로 중단

        if has_negative_cycle:  # 음수 사이클이 발견되었을 경우
            results.append("YES")  # 결과 리스트에 "YES" 추가
        else:  # 음수 사이클이 없을 경우
            results.append("NO")  # 결과 리스트에 "NO" 추가

    print("\n".join(results))  # 모든 테스트 케이스 결과를 출력

if __name__ == "__main__":
    main()  # 프로그램 시작
```
