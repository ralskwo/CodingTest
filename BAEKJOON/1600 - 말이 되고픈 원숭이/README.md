# 말이 되고픈 원숭이 문제 풀이 및 설명

https://www.acmicpc.net/problem/1600

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-1600-%eb%a7%90%ec%9d%b4-%eb%90%98%ea%b3%a0%ed%94%88-%ec%9b%90%ec%88%ad%ec%9d%b4-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4/

## 문제 이해

이 문제는 격자판 위에서 원숭이가 시작 지점에서 도착 지점까지 최소한의 동작으로 이동하는 최단 경로를 찾는 문제입니다. 일반적으로 원숭이는 인접한 네 방향(상, 하, 좌, 우)으로 한 칸씩 이동할 수 있습니다. 하지만 원숭이는 최대 K번까지 체스의 나이트와 같은 이동(말의 이동)을 사용할 수 있습니다. 말의 이동은 장애물을 뛰어넘을 수 있으며, 이동한 후의 칸이 평지라면 이동이 가능합니다.

문제의 핵심은 말의 이동을 최대한 활용하여 최소한의 동작으로 목적지에 도달하는 것입니다. 하지만 말의 이동 횟수에는 제한이 있으므로, 일반 이동과 말의 이동을 적절히 조합해야 합니다. 또한, 격자판에는 장애물이 존재할 수 있으므로 이를 피해서 이동해야 합니다.

## 입출력 조건

**입력**

- 첫째 줄: 말의 이동을 할 수 있는 최대 횟수 K (0 ≤ K ≤ 30)
- 둘째 줄: 격자판의 가로 길이 W와 세로 길이 H (1 ≤ W, H ≤ 200)
- 다음 H줄: 격자판의 상태를 나타내는 W개의 숫자
  - 0: 이동할 수 있는 평지
  - 1: 장애물이 있는 칸 (이동 불가)

**출력**

- 시작 지점에서 도착 지점까지 이동하는 데 필요한 최소 동작 수를 출력
- 이동할 수 없는 경우 -1을 출력

## 접근 방식

이 문제는 BFS(너비 우선 탐색)를 사용하여 최단 경로를 찾는 전형적인 문제입니다. 하지만 말의 이동 횟수라는 추가적인 상태가 존재하므로, 단순한 2차원 BFS가 아닌 3차원 BFS를 사용해야 합니다. 여기서 3차원은 세 번째 축으로 말의 이동 횟수를 추가한 것입니다.

구체적인 접근 방식은 다음과 같습니다:

- **상태 정의**: 위치 (x, y)와 말의 이동 사용 횟수 k를 상태로 정의합니다.
- **방문 여부 체크**: 3차원 배열 `visited[y][x][k]`를 사용하여 해당 위치에서 특정 말 이동 횟수를 사용한 상태를 방문했는지 확인합니다.
- **이동 방법**:
  - 말의 이동 횟수가 남아 있으면 말의 이동을 시도합니다.
  - 항상 원숭이의 일반 이동(상하좌우)도 시도합니다.
- **BFS 진행**: 큐를 사용하여 각 가능한 이동을 탐색하며, 이동 횟수를 누적하여 최단 경로를 찾습니다.

## 풀이 과정

1. **데이터 입력 및 초기 설정**:

   - 말의 최대 이동 횟수 K, 격자판의 크기 W와 H, 격자판의 상태를 입력받습니다.
   - 방문 여부를 체크하기 위한 3차원 배열 `visited`를 `(H x W x (K+1))` 크기로 생성합니다.

2. **BFS를 위한 큐 초기화**:

   - `deque`를 사용하여 BFS를 위한 큐를 생성합니다.
   - 시작 지점 `(0, 0)`에서 말의 이동을 0번 사용한 상태를 큐에 추가하고 방문 처리합니다.

3. **BFS 탐색 시작**:

   - 큐가 빌 때까지 반복합니다.
     - 현재 위치 `(x, y)`, 이동 횟수 `cnt`, 말 이동 사용 횟수 `k`를 큐에서 꺼냅니다.
     - 현재 위치가 도착 지점 `(W-1, H-1)`이면 `cnt`를 반환합니다.
     - 말의 이동을 더 사용할 수 있는 경우( `k < K` ):
       - 말의 이동 방향 8가지를 모두 탐색합니다.
       - 새로운 위치 `(nx, ny)`가 격자판 내에 있고, 해당 위치가 평지이며, 해당 상태로 방문한 적이 없으면:
         - 방문 처리하고 큐에 `(nx, ny, cnt+1, k+1)`을 추가합니다.
     - 원숭이의 일반 이동(상하좌우)도 모두 탐색합니다.
       - 새로운 위치 `(nx, ny)`가 격자판 내에 있고, 해당 위치가 평지이며, 해당 상태로 방문한 적이 없으면:
         - 방문 처리하고 큐에 `(nx, ny, cnt+1, k)`를 추가합니다.

4. **결과 처리**:

   - BFS 탐색이 종료될 때까지 도착 지점에 도달하지 못하면 `-1`을 반환합니다.

5. **결과 출력**:
   - BFS 함수의 반환값을 출력하여 최소 이동 횟수를 결과로 제공합니다.

## 코드 구현

```python
import sys  # 시스템 모듈 임포트
from collections import deque  # 덱 자료구조 임포트

input = sys.stdin.readline  # 빠른 입력을 위해 sys.stdin.readline 사용

horse_moves = [(-2, -1), (-1, -2), (1, -2), (2, -1),  # 말의 이동 방향 정의 (8가지)
               (2, 1), (1, 2), (-1, 2), (-2, 1)]

monkey_moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 원숭이의 일반 이동 방향 정의 (4가지)

K = int(input())  # 말처럼 이동할 수 있는 최대 횟수 K 입력
W, H = map(int, input().split())  # 격자판의 가로(W), 세로(H) 크기 입력
grid = [list(map(int, input().split())) for _ in range(H)]  # 격자판 정보 입력

visited = [[[False] * (K + 1) for _ in range(W)] for _ in range(H)]  # 방문 여부를 체크하기 위한 3차원 배열 생성

def bfs():
    queue = deque()  # BFS를 위한 큐 생성
    queue.append((0, 0, 0, 0))  # 시작점 추가 (x좌표, y좌표, 이동 횟수, 말 이동 사용 횟수)
    visited[0][0][0] = True  # 시작점 방문 처리

    while queue:
        x, y, cnt, k = queue.popleft()  # 큐에서 현재 위치와 상태를 꺼냄

        if x == W - 1 and y == H - 1:  # 도착지점에 도달한 경우
            return cnt  # 이동 횟수 반환

        if k < K:  # 말의 이동을 더 사용할 수 있는 경우
            for dx, dy in horse_moves:  # 말의 이동 방향에 대해 반복
                nx, ny = x + dx, y + dy  # 새로운 위치 계산
                nk = k + 1  # 말 이동 횟수 증가
                if 0 <= nx < W and 0 <= ny < H:  # 격자판 범위 내인지 확인
                    if not visited[ny][nx][nk] and grid[ny][nx] == 0:  # 방문하지 않았고 장애물이 없는 경우
                        visited[ny][nx][nk] = True  # 방문 처리
                        queue.append((nx, ny, cnt + 1, nk))  # 큐에 추가

        for dx, dy in monkey_moves:  # 원숭이의 일반 이동 방향에 대해 반복
            nx, ny = x + dx, y + dy  # 새로운 위치 계산
            nk = k  # 말 이동 횟수는 그대로
            if 0 <= nx < W and 0 <= ny < H:  # 격자판 범위 내인지 확인
                if not visited[ny][nx][nk] and grid[ny][nx] == 0:  # 방문하지 않았고 장애물이 없는 경우
                    visited[ny][nx][nk] = True  # 방문 처리
                    queue.append((nx, ny, cnt + 1, nk))  # 큐에 추가

    return -1  # 도착지점에 도달할 수 없는 경우 -1 반환

print(bfs())  # 결과 출력
```
