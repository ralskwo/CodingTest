# 비밀번호 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2464>

<https://mayquartet.com/python-파이썬-2464-비밀번호/>

## 문제 이해

이 문제는 주어진 양의 정수 `A`를 이진수로 표현했을 때, 해당 이진수 내에서 1의 개수가 동일한 수 중에서 가장 가까운 작은 수와 큰 수를 찾는 것입니다. 이를 통해, 주어진 수 `A`를 기준으로 이진수 내 1의 개수가 같은 두 수를 찾고자 합니다.

예를 들어, `A = 43`일 경우, `43`의 이진수 표현은 `101011`이고, 여기서 1의 개수는 4입니다. 따라서, `43`보다 작은 수 중에서 이진수 표현에서 1의 개수가 4인 가장 큰 수를 찾고, `43`보다 큰 수 중에서 1의 개수가 4인 가장 작은 수를 찾으면 됩니다. 이 문제는 주어진 숫자 `A`의 이진수에서 1의 개수를 기준으로 가까운 숫자를 찾는 것이 핵심이므로, 비트 조작을 통해 효율적으로 풀이할 수 있습니다.

## 입출력 조건

- **입력**: 첫 번째 줄에 하나의 양의 정수 `A`가 주어지며, `1 ≤ A ≤ 10^18`의 범위를 가집니다.
  - 예를 들어, 입력이 `43`이라면, 이는 `A = 43`을 의미합니다.
- **출력**: 한 줄에 두 개의 정수를 출력합니다.
  - 첫 번째 값은 `A`보다 작은 수 중에서 1의 개수가 같으면서 가장 가까운 수입니다.
  - 두 번째 값은 `A`보다 큰 수 중에서 1의 개수가 같으면서 가장 가까운 수입니다.
  - 만약 `A`보다 작은 수 중에서 조건을 만족하는 수가 없을 경우 `0`을 출력하고, 큰 수 중에서 조건을 만족하는 수가 없을 경우에도 `0`을 출력합니다.

## 접근 방식

이 문제는 큰 수와 작은 수를 찾는 과정에서 `A`의 값이 최대 `10^18`이므로 매우 큰 수에 대한 연산이 필요합니다. 따라서 단순히 `A-1`, `A+1` 식으로 숫자를 하나씩 줄이거나 늘려가며 조건을 만족하는 수를 찾는 것은 비효율적이며 시간 초과를 일으킬 수 있습니다. 이를 해결하기 위해 **비트 조작**을 통해 효율적으로 다음 또는 이전의 숫자를 찾는 방식을 사용해야 합니다.

비트 조작을 활용하면 다음과 같은 절차로 접근할 수 있습니다.

1. **A보다 큰 수 중에서 1의 개수가 같은 가장 가까운 수 찾기**:
   - 주어진 수 `A`의 가장 오른쪽에 있는 0을 1로 바꾸고, 그 이후 비트를 조정하여 원래의 1의 개수를 맞추면 `A`보다 큰 가장 가까운 수를 효율적으로 찾을 수 있습니다.
2. **A보다 작은 수 중에서 1의 개수가 같은 가장 가까운 수 찾기**:
   - 주어진 수 `A`의 오른쪽에서 연속된 1을 0으로 바꾸고, 그 이후 비트를 조정하여 원래의 1의 개수를 유지하면 `A`보다 작은 가장 가까운 수를 찾을 수 있습니다.

이를 위해 각각의 숫자에 대해 비트마스킹과 시프트 연산을 통해 최적화된 방법으로 접근할 수 있습니다.

## 풀이 과정

1. 먼저, 주어진 수 `A`를 이진수로 변환했을 때의 1의 개수를 구합니다. 이는 다음 과정에서 1의 개수를 유지하며 숫자를 변경할 때 기준이 됩니다.

2. **A보다 큰 수를 찾기 위한 함수 정의**:

   - 함수 `next_same_bit_count`를 정의합니다. 이 함수는 다음과 같은 단계로 동작합니다.
     - `A`의 가장 오른쪽에 있는 1 비트를 찾고, 이를 `smallest` 변수에 저장합니다.
     - 가장 오른쪽에 위치한 0 비트를 1로 바꾸어 새로운 수를 만듭니다. 이를 `ripple` 변수에 저장합니다.
     - 비트의 변화를 계산하여 1의 개수를 맞추기 위해 `ones` 변수를 조정합니다.
     - 마지막으로 `ripple`과 `ones`를 합쳐 새로운 수를 반환합니다. 이 수는 `A`보다 크면서 1의 개수가 같은 가장 가까운 수가 됩니다.

3. **A보다 작은 수를 찾기 위한 함수 정의**:

   - 함수 `prev_same_bit_count`를 정의합니다. 이 함수는 다음과 같은 단계로 동작합니다.
     - 주어진 수에서 오른쪽부터 연속된 1의 개수를 세어 `c1`에 저장하고, 이어서 나오는 0의 개수를 세어 `c0`에 저장합니다.
     - `c1` 다음에 나오는 첫 번째 0 비트까지의 길이를 `p`로 계산합니다.
     - `A`의 `p` 이후 모든 비트를 0으로 만들어 1의 개수를 줄인 후, 남은 위치에 1 비트를 배치하여 최종 수를 생성합니다.
     - 이 수는 `A`보다 작으면서 1의 개수가 같은 가장 가까운 수가 됩니다.
     - 만약 `A`가 1로만 이루어진 수라면, 더 작은 수가 존재하지 않으므로 `0`을 반환합니다.

4. **최종 함수 호출 및 결과 출력**:
   - `find_nearest_numbers` 함수를 통해 `A`에 대한 작은 수와 큰 수를 각각 찾습니다. 작은 수는 `prev_same_bit_count` 함수의 결과이며, 큰 수는 `next_same_bit_count` 함수의 결과입니다.
   - 결과적으로 이 두 수를 한 줄에 출력하여 문제의 요구사항을 만족합니다.

## 코드 구현

```python
def find_nearest_numbers(A):
    # A보다 큰 수 중에서 1의 개수가 같은 가장 가까운 수를 찾는 함수 정의
    def next_same_bit_count(n):
        # 가장 오른쪽에 위치한 1 비트를 찾음
        smallest = n & -n
        # 가장 오른쪽 0 비트를 1로 변경하여 더 큰 수를 만듦
        ripple = n + smallest
        # 변경된 위치에서 발생한 비트 패턴을 계산
        ones = n ^ ripple
        # 필요한 1의 개수를 유지하며 비트들을 조정
        ones = (ones >> 2) // smallest
        # 새로운 수를 반환
        return ripple | ones

    # A보다 작은 수 중에서 1의 개수가 같은 가장 가까운 수를 찾는 함수 정의
    def prev_same_bit_count(n):
        # 입력된 n을 임시로 저장하여 비트 조작에 사용
        temp = n
        # 오른쪽에서부터 연속된 0과 1의 개수를 세기 위한 변수 초기화
        c0, c1 = 0, 0

        # 오른쪽부터 연속된 1의 개수를 셈
        while (temp & 1) == 1:
            c1 += 1
            temp >>= 1
        # 만약 1로만 이루어진 경우, 이전 수를 찾을 수 없으므로 0을 반환
        if temp == 0:
            return 0

        # 1 다음에 나오는 0의 개수를 셈
        while ((temp & 1) == 0) and (temp != 0):
            c0 += 1
            temp >>= 1

        # 변경해야 할 비트 위치 계산 (1 다음의 첫 번째 0 위치)
        p = c0 + c1

        # p 이후 모든 비트를 0으로 만듦으로써 1의 개수를 줄임
        n &= ((~0) << (p + 1))

        # 필요한 만큼 1 비트를 만든 후 왼쪽으로 이동하여 위치에 맞게 배치
        mask = (1 << (c1 + 1)) - 1
        n |= mask << (c0 - 1)

        # 재조정된 값을 반환
        return n

    # A보다 작은 수 중에서 1의 개수가 같은 가장 가까운 수를 찾음
    smaller = prev_same_bit_count(A)
    # A보다 큰 수 중에서 1의 개수가 같은 가장 가까운 수를 찾음
    larger = next_same_bit_count(A)

    # 결과값을 반환
    return smaller, larger

# 사용자로부터 정수 A를 입력받음
A = int(input().strip())
# A에 대해 작은 수와 큰 수를 찾는 함수를 호출하여 결과를 받음
smaller, larger = find_nearest_numbers(A)
# 결과값을 출력
print(smaller, larger)
```
