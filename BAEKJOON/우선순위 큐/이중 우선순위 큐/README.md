# 이중 우선순위 큐 문제 풀이 및 설명 

https://www.acmicpc.net/problem/7662

## 문제 이해

이 문제는 이중 우선순위 큐를 구현하는 것입니다. 이중 우선순위 큐는 일반적인 큐와 달리 두 가지 주요 기능을 가지고 있습니다. 첫 번째는 데이터를 삽입하는 기능이고, 두 번째는 데이터를 삭제하는 기능입니다. 삭제 연산은 최대값과 최소값을 각각 삭제할 수 있는 두 가지 연산이 존재합니다. 즉, 가장 큰 값을 삭제하거나 가장 작은 값을 삭제할 수 있습니다. 문제는 주어진 연산을 처리한 후 최종적으로 큐에 남아있는 최대값과 최소값을 출력하는 것입니다. 만약 큐가 비어있다면 "EMPTY"를 출력해야 합니다.

## 입출력 조건

**입력 조건:**

- 입력은 여러 개의 테스트 데이터로 구성됩니다.
- 첫 번째 줄에는 테스트 데이터의 개수를 나타내는 정수 T가 주어집니다.
- 각 테스트 데이터의 첫 줄에는 명령어의 개수를 나타내는 정수 k (1 ≤ k ≤ 1,000,000)가 주어집니다.
- 그 다음 k개의 줄에는 명령어가 주어집니다. 명령어는 'I n' 또는 'D 1' 또는 'D -1'의 형태를 가집니다.
  - 'I n': 정수 n을 큐에 삽입합니다.
  - 'D 1': 큐에서 최댓값을 삭제합니다.
  - 'D -1': 큐에서 최솟값을 삭제합니다.

**출력 조건:**

- 각 테스트 데이터에 대해 모든 명령어를 처리한 후, 큐에 값이 남아있다면 최댓값과 최솟값을 출력합니다. 그렇지 않으면 "EMPTY"를 출력합니다.
- 최댓값과 최솟값은 같은 줄에 공백으로 구분하여 출력합니다.

## 접근 방식

이 문제를 풀기 위해서는 이중 우선순위 큐를 구현할 수 있어야 합니다. 이를 위해 두 개의 우선순위 큐를 사용합니다. 하나는 최소 힙(min-heap)이고, 다른 하나는 최대 힙(max-heap)입니다. Python의 `heapq` 모듈을 사용하면 최소 힙을 쉽게 구현할 수 있습니다. 최대 힙은 최소 힙에 음수 값을 넣는 방식으로 구현할 수 있습니다.

**알고리즘 및 데이터 구조:**

1. **힙(Heap):** 최소 힙과 최대 힙을 사용하여 데이터 삽입 및 삭제 연산을 효율적으로 수행합니다.
2. **딕셔너리:** 삽입된 원소의 개수를 추적하여 유효하지 않은 힙의 루트를 제거할 때 사용합니다.
3. **카운터:** 현재 큐에 남아있는 원소의 개수를 추적하여 빈 큐인지 여부를 확인합니다.

## 풀이 과정

1. **입력 파싱:** 표준 입력으로부터 데이터를 읽어와 명령어를 파싱합니다. 이때 각 테스트 케이스를 구분하여 처리할 수 있도록 합니다.
2. **데이터 구조 초기화:** 각 테스트 케이스마다 최소 힙과 최대 힙을 초기화합니다. 또한, 삽입된 원소의 개수를 추적하기 위한 딕셔너리와 카운터를 초기화합니다.
3. **명령어 처리:**
   - 'I n' 명령어를 만나면 n을 최소 힙과 최대 힙에 각각 삽입합니다. 이때 최대 힙에는 음수 값을 삽입하여 최대 힙을 구현합니다. 삽입된 원소의 개수를 딕셔너리에 기록하고 카운터를 증가시킵니다.
   - 'D 1' 명령어를 만나면 최대 힙에서 유효한 최대값을 제거합니다. 유효하지 않은 루트를 제거한 후 유효한 최대값을 찾아 제거합니다. 딕셔너리에서 해당 값을 감소시키고 카운터를 감소시킵니다.
   - 'D -1' 명령어를 만나면 최소 힙에서 유효한 최소값을 제거합니다. 유효하지 않은 루트를 제거한 후 유효한 최소값을 찾아 제거합니다. 딕셔너리에서 해당 값을 감소시키고 카운터를 감소시킵니다.
4. **유효하지 않은 원소 정리:** 명령어 처리가 끝난 후, 최소 힙과 최대 힙에서 유효하지 않은 루트를 제거합니다. 이는 딕셔너리에서 해당 값의 개수가 0인 경우 해당 원소를 제거하여 정리합니다.
5. **결과 출력:** 모든 명령어를 처리한 후, 큐에 남아있는 값이 있는지 확인합니다. 값이 남아있다면 최대값과 최소값을 출력하고, 그렇지 않으면 "EMPTY"를 출력합니다.

이러한 방식으로 문제를 해결할 수 있습니다. 이중 우선순위 큐를 구현함으로써 효율적으로 최댓값과 최솟값을 관리하고 주어진 명령어를 처리할 수 있습니다.

## 코드 구현
```python
import heapq
import sys

# 표준 입력을 읽기 위해 사용
input = sys.stdin.read

# 입력 데이터를 공백을 기준으로 나누어 리스트로 변환
data = input().split()

# 테스트 케이스의 수를 읽음
index = 0
T = int(data[index])
index += 1

# 결과를 저장할 리스트 초기화
results = []

# 각 테스트 케이스를 처리
for _ in range(T):
    # 각 테스트 케이스에서 명령어의 수를 읽음
    k = int(data[index])
    index += 1

    # 최대 힙과 최소 힙을 초기화
    max_heap = []
    min_heap = []

    # 삽입된 원소의 개수를 추적하기 위한 딕셔너리와 카운터 초기화
    entry_finder = {}
    count = 0

    # 각 명령어를 처리
    for _ in range(k):
        # 명령어와 값을 읽음
        command = data[index]
        value = int(data[index + 1])
        index += 2

        if command == 'I':  # 삽입 연산
            # 최소 힙과 최대 힙에 각각 삽입
            heapq.heappush(min_heap, value)
            heapq.heappush(max_heap, -value)
            # 삽입된 값을 기록
            entry_finder[value] = entry_finder.get(value, 0) + 1
            count += 1
        elif command == 'D':  # 삭제 연산
            if count == 0:
                continue
            if value == 1:  # 최대값 삭제
                # 유효하지 않은 최대 힙의 루트를 제거
                while max_heap and entry_finder[-max_heap[0]] == 0:
                    heapq.heappop(max_heap)
                if max_heap:
                    # 최대값을 제거하고 기록 업데이트
                    max_value = -heapq.heappop(max_heap)
                    entry_finder[max_value] -= 1
                    count -= 1
            elif value == -1:  # 최소값 삭제
                # 유효하지 않은 최소 힙의 루트를 제거
                while min_heap and entry_finder[min_heap[0]] == 0:
                    heapq.heappop(min_heap)
                if min_heap:
                    # 최소값을 제거하고 기록 업데이트
                    min_value = heapq.heappop(min_heap)
                    entry_finder[min_value] -= 1
                    count -= 1

    # 유효하지 않은 최소 힙의 루트를 제거
    while min_heap and entry_finder[min_heap[0]] == 0:
        heapq.heappop(min_heap)
    # 유효하지 않은 최대 힙의 루트를 제거
    while max_heap and entry_finder[-max_heap[0]] == 0:
        heapq.heappop(max_heap)

    if count == 0:
        # 큐가 비어 있으면 "EMPTY"를 결과에 추가
        results.append("EMPTY")
    else:
        # 큐에 값이 있으면 최대값과 최소값을 결과에 추가
        results.append(f"{-max_heap[0]} {min_heap[0]}")

# 모든 결과를 출력
for result in results:
    print(result)
