# 뱀 문제 풀이 및 설명

https://www.acmicpc.net/problem/3190

https://mayquartet.com/python-파이썬-백준-3190-뱀-문제-풀이-및-설명/

## 문제 이해

이 문제는 뱀 게임을 시뮬레이션하는 문제입니다. 뱀이 사과를 먹을 때마다 길이가 늘어나고, 벽이나 자기 자신의 몸에 부딪히면 게임이 끝나는 단순한 규칙을 가지고 있습니다. 이 문제를 해결하기 위해서는 게임이 어떻게 진행되는지를 정확히 이해해야 합니다.

1. **게임 보드**: NxN 크기의 정사각형 보드에서 게임이 진행됩니다. 보드의 각 칸은 (행, 열)로 표현되며, 뱀은 보드의 (0, 0)에서 시작합니다.
2. **사과의 위치**: 사과는 특정 위치에 놓여 있으며, 뱀이 이 위치로 이동하면 사과를 먹고 길이가 늘어납니다.
3. **뱀의 움직임**: 뱀은 매초마다 한 칸씩 이동하며, 머리가 이동하는 위치에 따라 게임이 진행됩니다. 이동 후에는 꼬리가 따라가며 길이를 유지하거나 늘리게 됩니다.
4. **게임 종료 조건**: 뱀이 보드의 경계를 넘거나 자신의 몸에 부딪히는 경우 게임이 종료됩니다.
5. **방향 전환**: 주어진 시간에 따라 뱀의 방향이 왼쪽(L) 또는 오른쪽(D)으로 90도 회전합니다.

## 입출력 조건

- **입력**:

  1. 첫 번째 줄에는 보드의 크기 N이 주어집니다. (2 ≤ N ≤ 100)
  2. 두 번째 줄에는 사과의 개수 K가 주어집니다. (0 ≤ K ≤ 100)
  3. 다음 K개의 줄에는 사과의 위치가 주어집니다. 각 위치는 두 개의 정수로 이루어져 있으며, 행과 열을 나타냅니다.
  4. 그 다음 줄에는 방향 전환 횟수 L이 주어집니다. (1 ≤ L ≤ 100)
  5. 마지막으로, L개의 줄에는 방향 전환 정보가 주어집니다. 각 줄은 정수 X와 문자 C로 이루어져 있으며, X초가 끝난 후 C 방향으로 회전한다는 의미입니다. X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 시간 순서대로 주어집니다.

- **출력**:
  - 첫 번째 줄에 게임이 몇 초에 끝나는지를 출력합니다.

## 접근 방식

이 문제를 해결하기 위해서는 뱀의 움직임을 매초마다 시뮬레이션하면서, 주어진 조건에 따라 게임이 언제 종료되는지를 계산해야 합니다. 다음과 같은 접근 방식을 사용할 수 있습니다:

1. **자료 구조**:

   - **덱(deque)**: 뱀의 몸을 관리하기 위해 덱을 사용합니다. 덱은 양방향으로 빠르게 데이터를 추가하고 제거할 수 있어 뱀의 머리와 꼬리의 움직임을 효율적으로 관리할 수 있습니다.
   - **보드**: NxN 크기의 2차원 리스트를 사용하여 사과의 위치와 뱀의 위치를 관리합니다.

2. **시뮬레이션**:
   - 뱀이 매초마다 이동하는 과정을 시뮬레이션합니다. 이 과정에서 머리의 위치를 업데이트하고, 새로운 위치가 벽이나 뱀의 몸과 충돌하는지 확인합니다.
   - 방향 전환 정보는 미리 저장해두고, 해당 시간이 되었을 때 뱀의 방향을 전환합니다.
3. **충돌 처리**:
   - 머리가 보드의 경계를 벗어나거나 뱀의 몸과 충돌하면 게임을 종료합니다.
   - 뱀이 사과를 먹으면 뱀의 길이가 늘어나며, 꼬리가 움직이지 않습니다. 그렇지 않은 경우에는 꼬리가 한 칸 줄어듭니다.

## 풀이 과정

1. **보드 초기화**:
   - 입력으로 주어진 보드 크기를 기반으로 NxN 크기의 보드를 0으로 초기화합니다. 그리고 사과의 위치를 1로 설정합니다.
2. **방향 전환 정보 저장**:

   - 방향 전환 횟수와 전환 정보를 입력받아 이를 딕셔너리 형태로 저장합니다. 이 딕셔너리는 특정 시간에 방향이 전환되어야 할 정보를 가지고 있습니다.

3. **뱀의 초기 상태 설정**:

   - 뱀은 (0, 0) 위치에서 시작하며, 초기 방향은 오른쪽입니다. 뱀의 몸은 덱으로 관리하며, 초기 상태에서는 머리만 덱에 포함되어 있습니다.

4. **게임 시뮬레이션**:

   - 게임이 종료될 때까지 매초마다 뱀의 머리를 현재 방향으로 이동시킵니다.
   - 이동한 머리의 위치가 벽에 부딪히거나, 뱀의 몸에 부딪히는 경우 게임이 종료됩니다.
   - 이동한 위치에 사과가 있는 경우, 사과를 먹고 뱀의 길이를 늘립니다. 그렇지 않은 경우, 뱀의 꼬리를 한 칸 줄입니다.
   - 현재 시간이 방향 전환 정보에 포함되어 있으면, 해당 시간에 맞춰 방향을 전환합니다.

5. **결과 출력**:
   - 게임이 종료된 시점을 출력합니다. 이 값이 게임이 끝나는 시간, 즉 몇 초에 게임이 끝나는지를 나타냅니다.

## 코드 구현

```python
from collections import deque  # deque를 사용하여 뱀의 몸을 관리

directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 오른쪽, 아래, 왼쪽, 위쪽 방향 벡터

def turn(direction, c):  # 방향 전환 함수
    if c == 'L':  # 왼쪽으로 90도 회전할 때
        return (direction - 1) % 4  # 현재 방향에서 왼쪽으로 90도 회전한 새로운 방향 계산
    else:  # 'D' 즉, 오른쪽으로 90도 회전할 때
        return (direction + 1) % 4  # 현재 방향에서 오른쪽으로 90도 회전한 새로운 방향 계산

def simulate():  # 뱀 게임 시뮬레이션 함수
    n = int(input())  # 보드의 크기 입력
    k = int(input())  # 사과의 개수 입력
    board = [[0] * n for _ in range(n)]  # NxN 크기의 보드를 0으로 초기화

    for _ in range(k):  # 사과의 위치 설정
        x, y = map(int, input().split())  # 각 사과의 위치 입력
        board[x-1][y-1] = 1  # 해당 위치에 사과 표시 (1로 설정)

    l = int(input())  # 방향 전환 횟수 입력
    changes = {}  # 방향 전환 정보를 저장할 딕셔너리
    for _ in range(l):  # 각 방향 전환 정보를 입력받음
        x, c = input().split()  # 시간과 방향 정보 입력
        changes[int(x)] = c  # 시간을 키로, 방향을 값으로 딕셔너리에 저장

    snake = deque([(0, 0)])  # 뱀의 초기 위치 (0, 0)을 덱에 저장
    direction = 0  # 뱀의 초기 방향 (오른쪽)
    time = 0  # 게임이 진행된 시간 초기화

    while True:  # 게임이 종료될 때까지 반복
        time += 1  # 1초 경과
        head_x, head_y = snake[-1]  # 뱀의 현재 머리 위치
        new_head_x = head_x + directions[direction][0]  # 새로운 머리 위치 x 좌표
        new_head_y = head_y + directions[direction][1]  # 새로운 머리 위치 y 좌표

        if not (0 <= new_head_x < n and 0 <= new_head_y < n):  # 벽에 부딪혔는지 확인
            break  # 벽에 부딪혔으면 게임 종료
        if (new_head_x, new_head_y) in snake:  # 자기 몸에 부딪혔는지 확인
            break  # 자기 몸에 부딪혔으면 게임 종료

        snake.append((new_head_x, new_head_y))  # 뱀의 새로운 머리 위치 추가

        if board[new_head_x][new_head_y] == 1:  # 사과가 있는 경우
            board[new_head_x][new_head_y] = 0  # 사과를 먹었으므로 보드에서 사과 제거
        else:
            snake.popleft()  # 사과가 없으면 꼬리를 줄여서 뱀의 길이 유지

        if time in changes:  # 현재 시간이 방향 전환 정보에 있는지 확인
            direction = turn(direction, changes[time])  # 방향 전환 실행

    return time  # 게임이 종료된 시간을 반환

print(simulate())  # 시뮬레이션 실행 후 결과 출력
```
