# 감시 문제 풀이 및 설명

<https://www.acmicpc.net/problem/15683>

<https://mayquartet.com/python-파이썬-백준-15683-감시-문제-풀이-및-설명/>

## 문제 이해

이 문제는 사무실에 설치된 여러 개의 CCTV가 주어진 방향으로 감시할 수 있는 영역을 표시하고, 이 CCTV들의 방향을 최적화하여 사각지대의 크기를 최소화하는 것이 목표입니다. 각 CCTV는 한 방향 또는 여러 방향을 감시할 수 있으며, CCTV의 감시 방향은 90도 단위로 회전할 수 있습니다. CCTV가 감시할 수 없는 영역은 "사각지대"라고 정의하며, 이 사각지대의 크기를 최소화해야 합니다.

또한 CCTV는 벽(숫자 6)을 통과할 수 없으며, 벽에 의해 감시 영역이 차단됩니다. CCTV가 서로 다른 방향으로 감시하더라도 CCTV는 다른 CCTV를 통과할 수 있기 때문에 감시 영역은 상호 간섭하지 않습니다.

이 문제를 해결하기 위해서는 각 CCTV의 모든 가능한 방향을 고려해보고, CCTV의 방향을 어떻게 설정하느냐에 따라 사각지대가 어떻게 변하는지 확인해야 합니다. 모든 경우의 수를 고려한 후, 사각지대의 크기를 최소화하는 방향 설정을 찾아내야 합니다.

## 입출력 조건

### 입력

1. 첫째 줄에는 사무실의 세로 크기 \( N \)과 가로 크기 \( M \)이 공백으로 구분되어 주어집니다. \( N \)과 \( M \)은 각각 1 이상 8 이하의 정수입니다.
2. 둘째 줄부터 \( N \)개의 줄에는 사무실의 상태가 주어집니다. 사무실 상태는 다음과 같은 값들로 이루어져 있습니다:
   - 0: 빈 칸 (감시할 수 있는 영역)
   - 6: 벽 (CCTV의 감시를 차단하는 벽)
   - 1~5: CCTV의 번호 (각 번호는 CCTV의 유형을 나타냄)
3. CCTV의 최대 개수는 8개를 넘지 않습니다.

### 출력

1. CCTV의 방향을 적절히 설정했을 때, 사각지대의 최소 크기를 출력해야 합니다. 사각지대는 CCTV가 감시할 수 없는 빈 칸의 개수입니다.

## 접근 방식

이 문제는 주어진 사무실의 상태를 기준으로 CCTV의 모든 가능한 방향을 고려하여, 각 방향에서 발생하는 사각지대의 크기를 계산하고 이를 최소화하는 방식으로 풀 수 있습니다. 기본적으로 백트래킹을 통해 각 CCTV의 방향을 모두 탐색해야 하며, 이를 효율적으로 처리하기 위해 아래와 같은 알고리즘과 방법을 사용합니다.

1. **CCTV의 방향 결정**:
   각 CCTV는 회전하여 여러 방향을 감시할 수 있습니다. 예를 들어 1번 CCTV는 한 방향만 감시할 수 있지만, 그 방향은 4방향 중 하나로 설정할 수 있습니다. 2번 CCTV는 서로 반대 방향을 감시할 수 있으며, 3번 CCTV는 직각으로 두 방향을 감시합니다. 모든 CCTV가 가질 수 있는 방향의 조합을 고려해야 하므로, 백트래킹을 사용하여 모든 경우의 수를 탐색합니다.

2. **감시 영역 표시**:
   CCTV가 감시하는 영역은 빈 칸(0)을 `#`으로 바꾸어 표시합니다. 하지만 벽(6)을 만나면 그 방향으로의 감시는 중단되며, 다른 CCTV가 감시하는 영역을 침범하지 않도록 관리해야 합니다.

3. **사각지대 계산**:
   각 경우에 대해 CCTV의 감시 영역이 설정된 후, 남아있는 빈 칸의 개수를 계산하여 사각지대의 크기를 구합니다. 이를 반복하면서 사각지대의 최소 크기를 구합니다.

4. **최적의 방향 탐색**:
   백트래킹을 사용해 모든 CCTV의 방향 설정을 탐색하고, 그중 사각지대가 가장 작은 방향 설정을 찾아냅니다.

## 풀이 과정

1. **입력 처리**:
   - 사무실의 크기 \( N \)과 \( M \)을 입력받습니다. 그 후, 사무실 상태를 2차원 리스트로 저장합니다. 이때, CCTV의 위치와 번호를 따로 저장하여 나중에 방향을 설정할 때 사용합니다.
2. **CCTV의 종류별 방향 설정**:
   - 각 CCTV는 회전할 수 있는 방향에 따라 감시할 수 있는 방향이 달라집니다. 1번 CCTV는 한 방향만, 2번 CCTV는 반대 방향, 3번 CCTV는 직각 방향, 4번 CCTV는 세 방향, 5번 CCTV는 네 방향 모두를 감시합니다. 따라서 각 CCTV마다 감시할 수 있는 모든 방향의 리스트를 미리 준비해 둡니다.
3. **감시 함수 작성**:
   - CCTV가 특정 방향으로 감시할 때, 해당 방향에 있는 빈 칸을 모두 `#`로 표시하는 함수가 필요합니다. CCTV가 벽을 만나거나 사무실의 경계를 넘으면 감시를 중단합니다. 이 과정에서 CCTV의 감시 영역을 사무실 상태에 반영합니다.
4. **백트래킹을 통한 모든 방향 조합 탐색**:
   - 각 CCTV의 가능한 모든 방향을 탐색하기 위해 백트래킹 알고리즘을 사용합니다. CCTV의 방향을 하나 설정한 후, 그 다음 CCTV의 방향을 설정하는 방식으로 모든 경우를 재귀적으로 탐색합니다.
   - CCTV가 감시할 수 있는 영역을 계산한 후, 재귀적으로 다음 CCTV로 넘어가며 사무실 상태를 복사하여 사용합니다. 이렇게 하면 원본 사무실 상태는 변경되지 않으며, 매번 새로운 방향 설정을 적용할 수 있습니다.
5. **사각지대 계산**:
   - CCTV의 모든 방향을 설정한 후, 사무실에서 남은 빈 칸(감시되지 않은 칸)의 개수를 계산합니다. 이를 통해 사각지대의 크기를 구하고, 최소값을 저장합니다.
6. **최소 사각지대 출력**:
   - 모든 CCTV의 방향을 탐색한 후, 사각지대의 최소 크기를 출력합니다.

## 코드 구현

```
import copy  # 사무실 상태를 복사하기 위한 copy 모듈을 임포트

# CCTV가 감시할 수 있는 방향을 나타내는 리스트 (우, 하, 좌, 상 순서)
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

# 각 CCTV 번호에 따라 감시할 수 있는 방향 설정
# 예를 들어 1번 CCTV는 한 방향만, 5번 CCTV는 네 방향 모두 감시 가능
cctv_directions = [
    [],  # 0번 인덱스는 사용하지 않음
    [[0], [1], [2], [3]],  # 1번 CCTV는 4가지 방향 (우, 하, 좌, 상)
    [[0, 2], [1, 3]],  # 2번 CCTV는 반대 방향 (우-좌, 하-상)
    [[0, 1], [1, 2], [2, 3], [3, 0]],  # 3번 CCTV는 직각 방향 (우-하, 하-좌 등)
    [[0, 1, 2], [1, 2, 3], [2, 3, 0], [3, 0, 1]],  # 4번 CCTV는 세 방향
    [[0, 1, 2, 3]]  # 5번 CCTV는 네 방향 모두 감시
]

# CCTV가 주어진 방향을 따라 감시할 수 있는 영역을 표시하는 함수
def watch(x, y, directions, office):
    n = len(office)  # 사무실의 세로 크기
    m = len(office[0])  # 사무실의 가로 크기
    for d in directions:  # 감시할 방향들을 반복
        nx, ny = x, y  # CCTV의 시작 위치
        while True:  # 주어진 방향으로 감시를 계속 진행
            nx += dx[d]  # 다음 x 위치 (현재 위치에서 방향에 따른 이동)
            ny += dy[d]  # 다음 y 위치 (현재 위치에서 방향에 따른 이동)
            if not (0 <= nx < n and 0 <= ny < m):  # 범위를 벗어나면 중단
                break
            if office[nx][ny] == 6:  # 벽(6)을 만나면 중단
                break
            if office[nx][ny] == 0:  # 빈 칸(0)을 만나면 감시 처리
                office[nx][ny] = '#'  # 감시된 구역은 '#'으로 표시

# 현재 사무실 상태에서 사각지대(감시되지 않은 영역)의 크기를 계산하는 함수
def calculate_blind_spot(office):
    count = 0  # 사각지대 카운트를 0으로 초기화
    for row in office:  # 사무실의 각 행에 대해 반복
        count += row.count(0)  # 각 행에서 감시되지 않은 빈 칸(0)의 개수를 셈
    return count  # 사각지대의 총 개수를 반환

# 백트래킹을 통해 모든 CCTV 방향을 조합하여 탐색하는 함수
def dfs(depth, office):
    global min_blind_spot  # 전역 변수로 최소 사각지대를 저장
    if depth == len(cctvs):  # 모든 CCTV에 대한 방향을 설정 완료한 경우
        min_blind_spot = min(min_blind_spot, calculate_blind_spot(office))  # 최소 사각지대 갱신
        return

    x, y, cctv_type = cctvs[depth]  # 현재 탐색 중인 CCTV의 좌표와 타입
    for directions in cctv_directions[cctv_type]:  # CCTV가 가질 수 있는 모든 방향에 대해 반복
        new_office = copy.deepcopy(office)  # 현재 사무실 상태를 복사 (원본 손상 방지)
        watch(x, y, directions, new_office)  # CCTV가 해당 방향으로 감시
        dfs(depth + 1, new_office)  # 다음 CCTV에 대해 재귀적으로 탐색

# 입력 처리
n, m = map(int, input().split())  # 사무실의 크기(N, M) 입력
office = []  # 사무실 상태를 저장할 리스트
cctvs = []  # CCTV의 좌표와 타입을 저장할 리스트

# 사무실의 상태를 입력받으면서 CCTV의 위치와 타입을 기록
for i in range(n):
    row = list(map(int, input().split()))  # 각 행을 입력받음
    office.append(row)  # 사무실 상태를 리스트에 추가
    for j in range(m):
        if 1 <= row[j] <= 5:  # CCTV가 있으면
            cctvs.append((i, j, row[j]))  # CCTV의 위치와 타입을 리스트에 저장

min_blind_spot = float('inf')  # 최소 사각지대를 매우 큰 값으로 초기화

dfs(0, office)  # 백트래킹 시작

print(min_blind_spot)  # 최소 사각지대 출력
```
