# 불 끄기 문제 풀이 및 설명

<https://www.acmicpc.net/problem/14939>

<https://mayquartet.com/python-파이썬-백준-14939-불-끄기-문제-풀이-및-설명/>

## 문제 이해

이 문제는 10x10 크기의 2차원 배열 형태로 주어지는 전구의 상태를 이용하여, 모든 전구를 끄는 데 필요한 최소한의 스위치 누르기 횟수를 찾는 것입니다. 각각의 전구는 `#`(꺼진 상태)와 `O`(켜진 상태)로 표시됩니다. 각 전구에는 개별 스위치가 있으며, 특정 전구의 스위치를 누르면 그 전구와 함께 상하좌우에 있는 전구의 상태도 동시에 바뀌게 됩니다.

즉, 스위치를 누르면 해당 위치의 전구를 포함하여 상하좌우에 있는 전구들이 모두 상태를 반전시키며, 이로 인해 모든 전구를 끄기 위해서는 각 전구의 상태 변화가 다른 전구에 미치는 영향을 면밀히 고려해야 합니다. 모든 전구를 끌 수 있는 최소 스위치 누르기 횟수를 구하는 것이 이 문제의 목표입니다. 또한, 모든 전구를 끄는 것이 불가능한 경우 `-1`을 출력해야 합니다. 이러한 문제는 전구를 하나씩 조작해가며 전구의 상태를 분석하고, 각 전구의 상호작용을 이해하는 것이 핵심입니다.

## 입출력 조건

### 입력 조건

1. 총 10줄에 걸쳐 각 줄마다 10개의 문자가 주어집니다.
2. 각각의 문자는 `#` 또는 `O`로 구성되어 있으며, 전구 배열의 상태를 나타냅니다.
3. `#`은 꺼진 전구, `O`는 켜진 전구를 의미합니다.
4. 전구 배열의 초기 상태가 주어지며, 전구 배열의 범위는 항상 10x10입니다.

### 출력 조건

1. 모든 전구를 끄기 위해 눌러야 하는 최소 스위치의 개수를 출력합니다.
2. 만약 모든 전구를 끄는 것이 불가능하다면 `-1`을 출력합니다.

## 접근 방식

이 문제는 전구를 끄는 스위치 누르기 규칙이 상하좌우 전구의 상태에 영향을 주는 특징 때문에 간단한 순차적 접근 방식으로는 해결이 어렵습니다. 각 전구가 다른 전구에 미치는 영향을 고려해야 하기 때문에 **브루트포스(모든 경우의 수를 탐색)**와 **그리디 알고리즘**의 결합을 이용하여 문제를 해결합니다.

특히, 첫 번째 줄의 스위치를 누르는 조합을 먼저 정해놓고, 그에 따른 결과를 토대로 두 번째 줄부터는 단순히 위쪽 전구의 상태만을 고려하여 나머지 전구의 상태를 결정할 수 있습니다. 이 방법을 사용하면 첫 번째 줄에 대해 가능한 모든 스위치 누르기 조합(2^10 = 1024가지)을 모두 시도해보고, 각 경우에 대해 전체 배열을 순회하여 결과를 확인할 수 있습니다.

따라서, 첫 번째 줄의 스위치 조작을 결정한 후, 이후의 줄들은 그 위에 있는 전구가 켜진 상태일 때만 스위치를 누르는 방식으로 최소 스위치 누르기 횟수를 구합니다. 이 방식은 브루트포스와 그리디 접근을 결합하여 효율적으로 문제를 해결할 수 있도록 합니다.

<https://mayquartet.com/algorithm-알고리즘-greedy-그리디-알고리즘탐욕법-이해하기/>

## 풀이 과정

1. **전구 상태를 변경하는 `toggle` 함수 작성**:

   - 특정 위치 `(x, y)`에 대해 전구의 상태를 반전시키는 함수 `toggle`을 작성합니다.
   - 이 함수는 현재 위치 `(x, y)`의 전구와 함께 상하좌우 4개의 전구의 상태를 반전시킵니다.
   - 배열의 범위(`0 ≤ x, y < 10`)를 벗어나는 전구는 반전시키지 않습니다.

2. **모든 전구가 꺼져 있는지 확인하는 `all_off` 함수 작성**:

   - 전구 배열의 모든 전구가 꺼져 있는지를 확인하는 함수 `all_off`를 작성합니다.
   - 10x10 배열을 순회하면서 켜져 있는 전구(`O`)가 하나라도 있다면 `False`를 반환하고, 모든 전구가 꺼져 있다면 `True`를 반환합니다.

3. **첫 번째 줄의 모든 경우의 수에 대해 탐색**:

   - 첫 번째 줄에 있는 각 전구를 기준으로 스위치를 누를지 여부를 결정하는 모든 경우의 수(2^10 = 1024가지)를 비트마스크를 사용하여 탐색합니다.
   - 예를 들어, 1024가지 조합은 `0000000000`부터 `1111111111`까지의 이진수 형태로 표현할 수 있습니다. 각 이진수의 각 비트는 첫 번째 줄의 각 전구에 대응됩니다.
   - 특정 비트가 1인 경우 해당 전구의 스위치를 누르고, 0인 경우 누르지 않습니다.

4. **첫 번째 줄의 스위치 누르기 조합에 따른 결과 확인**:

   - 각 조합에 대해 첫 번째 줄을 기준으로 전구의 상태를 변경합니다.
   - 두 번째 줄부터는 위쪽 줄의 전구 상태를 확인하면서, 위쪽 전구가 켜져 있으면 해당 위치의 스위치를 눌러 전구를 끕니다.
   - 이 과정은 첫 번째 줄을 결정한 후 나머지 줄들을 차례대로 확인하여 간단히 해결할 수 있습니다.

5. **모든 전구가 꺼진 상태인지 확인**:

   - 마지막 줄까지 스위치 조작을 완료한 후, `all_off` 함수를 사용하여 모든 전구가 꺼져 있는지를 확인합니다.
   - 만약 모든 전구가 꺼져 있다면 최소 스위치 누르기 횟수를 갱신하고, 그렇지 않은 경우 다음 조합을 시도합니다.

6. **최종 결과 출력**:
   - 모든 조합을 확인한 후 최소 스위치 누르기 횟수가 `inf`라면(모든 전구를 끌 수 없는 경우) `-1`을 출력합니다.
   - 최소 스위치 누르기 횟수가 존재하면 해당 값을 출력하여 문제를 해결합니다.

## 코드 구현

```python
def toggle(grid, x, y):
    # 상하좌우 및 현재 위치를 포함한 5개의 위치를 나타내는 이동 방향 배열 설정
    dx = [0, 0, -1, 1, 0]
    dy = [0, -1, 0, 0, 1]

    # 5개의 위치에 대해 순회하며 전구 상태를 반전시킴
    for i in range(5):
        nx, ny = x + dx[i], y + dy[i]  # 현재 위치에서의 이동된 좌표를 계산
        if 0 <= nx < 10 and 0 <= ny < 10:  # 좌표가 전구 배열의 범위 내에 있는지 확인
            # 전구 상태를 반전시킴 ('O'면 '#'으로, '#'이면 'O'로 변경)
            grid[nx][ny] = '#' if grid[nx][ny] == 'O' else 'O'

def all_off(grid):
    # 전구 배열의 모든 전구가 꺼져 있는지 확인하기 위해 10x10 배열을 순회
    for i in range(10):
        for j in range(10):
            if grid[i][j] == 'O':  # 켜진 전구가 하나라도 있으면 False 반환
                return False
    return True  # 모든 전구가 꺼져 있으면 True 반환

def solve(grid):
    import copy  # 배열의 깊은 복사를 위해 copy 모듈을 사용
    min_switches = float('inf')  # 최소 스위치 누르기 횟수를 무한대로 초기화

    # 첫 번째 줄의 모든 스위치 조합(2^10 = 1024가지)을 비트마스크로 표현하여 순회
    for case in range(1 << 10):
        switches = 0  # 현재 경우에 따른 스위치 누르기 횟수 초기화
        test_grid = copy.deepcopy(grid)  # 현재 상태를 복사하여 test_grid에 저장

        # 첫 번째 줄의 각 전구에 대해 스위치를 누를지 여부를 결정 (비트마스크를 통해 결정)
        for j in range(10):
            if case & (1 << j):  # case의 j번째 비트가 1인 경우 해당 전구를 누름
                toggle(test_grid, 0, j)  # 전구 상태 변경
                switches += 1  # 스위치 누른 횟수 증가

        # 첫 번째 줄을 기준으로 두 번째 줄부터 차례대로 전구 상태를 조정
        for i in range(1, 10):
            for j in range(10):
                if test_grid[i - 1][j] == 'O':  # 위쪽 전구가 켜져 있으면 현재 위치의 전구를 누름
                    toggle(test_grid, i, j)  # 전구 상태 변경
                    switches += 1  # 스위치 누른 횟수 증가

        # 모든 전구가 꺼진 상태인지 확인
        if all_off(test_grid):
            min_switches = min(min_switches, switches)  # 최소 스위치 누른 횟수 갱신

    # 최소 스위치 누른 횟수가 초기값 그대로면 불가능한 경우이므로 -1 반환
    return -1 if min_switches == float('inf') else min_switches

# 입력 받기: 10줄에 걸쳐 전구 배열의 상태를 입력으로 받음
grid = [list(input().strip()) for _ in range(10)]

# 문제 해결 및 결과 출력
print(solve(grid))
```
