# 택배 문제 풀이 및 설명

<https://www.acmicpc.net/problem/8980>

<https://mayquartet.com/python-백준-8980-택배/>

## 문제 이해

이 문제는 트럭 한 대로 최대한 많은 박스를 배송하는 것이 목표입니다. 주어진 조건에 따라 효율적으로 배송해야 하며, 다음과 같은 점들을 고려해야 합니다.

1. 트럭은 본부에서 출발하여 1번 마을부터 마지막 마을까지 한 방향으로 이동합니다. 즉, 이미 지나간 마을로 되돌아갈 수 없습니다.
2. 각 마을에서 트럭에 실은 박스는 도착지 마을에서만 내릴 수 있습니다.
3. 트럭의 용량이 제한되어 있으므로, 모든 박스를 한 번에 실을 수는 없습니다.
4. 여러 개의 배송 요청이 있을 때, 우선적으로 어떤 박스를 배송해야 최대한 많은 양을 배송할 수 있을지 고민해야 합니다.

이 문제를 풀기 위해서는 각 마을과 트럭 용량의 관계를 이해하고, 효율적인 적재와 배송 방법을 찾아야 합니다.

## 입출력 조건

### 입력 조건

1. 첫 줄에는 마을의 개수 N과 트럭의 용량 C가 공백으로 구분되어 주어집니다.
   - N은 2 이상 2000 이하의 정수입니다.
   - C는 1 이상 10000 이하의 정수입니다.
2. 두 번째 줄에는 박스 정보의 개수 M이 주어집니다.
   - M은 1 이상 10000 이하의 정수입니다.
3. 이어지는 M개의 줄에는 박스를 보내는 마을 번호, 받는 마을 번호, 박스 개수가 공백으로 구분되어 주어집니다.
   - 보내는 마을 번호는 받는 마을 번호보다 작습니다.
   - 각 박스의 개수는 1 이상 10000 이하의 정수입니다.

### 출력 조건

1. 트럭 한 대로 배송할 수 있는 최대 박스 수를 출력합니다.
2. 결과는 정수 형태로 한 줄에 출력합니다.

## 접근 방식

이 문제는 그리디 알고리즘을 사용하여 해결할 수 있습니다. 그리디 알고리즘은 현재 시점에서 가장 최선의 선택을 반복하여 전체 문제를 해결하는 방식입니다. 이 문제에서 최적의 방법은 아래와 같습니다.

1. 각 배송 요청을 받는 마을 번호를 기준으로 정렬합니다. 이렇게 하면 트럭이 순차적으로 배송하며, 가까운 마을에 우선적으로 박스를 배송하게 됩니다.
2. 트럭의 용량을 관리하며, 각 마을에서 적재 가능한 최대 박스 수를 계산합니다. 이미 적재된 박스와 현재 요청된 박스를 비교해 트럭 용량을 초과하지 않도록 합니다.
3. 각 마을을 지나면서 트럭에 실린 박스를 도착지 마을에서 내리고, 새로 적재할 박스를 트럭에 추가합니다.
4. 모든 요청을 처리하며 트럭이 실어나를 수 있는 최대 박스 수를 계산합니다.

이 과정에서 트럭의 용량, 마을 번호, 적재된 박스를 효율적으로 관리하는 것이 핵심입니다.

<https://mayquartet.com/algorithm-알고리즘-greedy-그리디-알고리즘탐욕법-이해하기/>

## 풀이 과정

1. 먼저 입력받은 박스 정보를 받는 마을 번호를 기준으로 정렬합니다. 이는 트럭이 순차적으로 배송을 진행하므로, 가까운 마을부터 배송을 처리하기 위함입니다.

2. 각 마을에 대해 트럭의 적재 상황을 관리하기 위해 배열을 초기화합니다. 이 배열은 각 마을을 기준으로 트럭에 실린 박스의 개수를 나타냅니다.

3. 정렬된 박스 정보를 순회하면서 각 요청을 처리합니다.

   - 각 배송 요청에 대해 보내는 마을과 받는 마을 사이에서 트럭에 이미 실린 박스의 최대 개수를 확인합니다. 이를 통해 해당 구간에서 현재 요청된 박스를 얼마나 더 실을 수 있는지 계산합니다.
   - 계산된 값은 트럭의 용량, 현재 요청된 박스 개수, 구간 내 이미 적재된 박스를 고려하여 결정됩니다.

4. 트럭에 적재 가능한 최대 박스를 실은 후, 트럭에 실린 박스 상태를 업데이트합니다. 또한, 배송 완료된 박스 개수를 누적합니다.

5. 모든 배송 요청을 처리한 후, 최종적으로 배송된 박스의 총 개수를 반환합니다.

이 과정은 박스 정보를 정렬하는 데 O(M log M), 각 요청을 처리하며 트럭 상태를 업데이트하는 데 O(M \* N)의 시간이 소요됩니다. 따라서 제한 조건 내에서 효율적으로 작동합니다.

## 코드 구현

```python
def max_boxes_delivered(n, c, box_info):
    # 박스 정보를 받는 마을 번호 기준으로 오름차순 정렬
    box_info.sort(key=lambda x: x[1])

    # 각 마을에 실린 박스 개수를 관리할 배열 초기화
    deliveries = [0] * (n + 1)

    # 최종 배송한 박스의 총 개수를 저장하는 변수
    total_delivered = 0

    # 각 박스 정보를 순회하며 최대한 많은 박스를 배송
    for start, end, boxes in box_info:
        # 현재 구간에서 트럭에 실을 수 있는 최대 박스 수 계산
        max_capacity = min(c - max(deliveries[start:end]), boxes)

        # 구간 내 각 마을에 적재된 박스 개수를 업데이트
        for i in range(start, end):
            deliveries[i] += max_capacity

        # 누적 배송된 박스 수를 갱신
        total_delivered += max_capacity

    # 최종 배송된 박스 수 반환
    return total_delivered


# 입력값으로 마을 수 N과 트럭 용량 C를 읽어옴
n, c = map(int, input().split())

# 박스 정보의 개수 M을 입력받음
m = int(input())

# 박스 정보를 입력받아 리스트로 저장
box_info = [tuple(map(int, input().split())) for _ in range(m)]

# 결과 출력
print(max_boxes_delivered(n, c, box_info))
```
