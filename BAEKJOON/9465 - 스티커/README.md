# 스티커 문제 풀이 및 설명

<https://www.acmicpc.net/problem/9465>

<https://mayquartet.com/python-백준-9465-스티커/>

## 문제 이해

이 문제는 2행 \( n \)열로 이루어진 스티커 배열에서 최대 점수를 얻는 문제입니다. 스티커를 선택하면 인접한 스티커는 사용할 수 없게 된다는 제약이 있습니다. 따라서 점수를 최대화하려면 선택한 스티커가 다른 선택된 스티커와 상하좌우로 인접하지 않도록 해야 합니다.

문제를 해결하기 위해 각 열에서 선택 가능한 스티커의 점수와 이전 열에서의 점수를 기반으로 최적의 선택을 결정해야 합니다. 이는 동적 계획법(Dynamic Programming, DP)을 사용하여 효율적으로 해결할 수 있습니다.

## 입출력 조건

입력은 다음과 같은 조건을 만족해야 합니다:

- 첫 번째 줄에는 테스트 케이스의 개수 \( T \)가 주어집니다.
- 각 테스트 케이스의 첫 줄에는 열의 개수 \( n \)이 주어집니다. \( 1 \leq n \leq 100,000 \)입니다.
- 이후 두 줄에는 \( n \)개의 정수가 주어지며, 첫 번째 줄은 위쪽 행의 스티커 점수, 두 번째 줄은 아래쪽 행의 스티커 점수입니다. 각 점수는 0 이상 100 이하입니다.

출력은 다음과 같은 조건을 만족해야 합니다:

- 각 테스트 케이스에 대해 선택 가능한 스티커 점수의 합 중 최댓값을 한 줄에 하나씩 출력합니다.

## 접근 방식

이 문제는 동적 계획법(Dynamic Programming)을 사용해 해결합니다. 각 스티커를 선택했을 때의 최댓값을 계산하기 위해 다음 접근 방식을 사용합니다.

1. **DP 배열 정의**  
   `dp[0][i]`는 위쪽 행에서 \( i \)번째 스티커를 선택했을 때 가능한 최대 점수입니다.  
   `dp[1][i]`는 아래쪽 행에서 \( i \)번째 스티커를 선택했을 때 가능한 최대 점수입니다.

2. **점화식 유도**

   - 위쪽 행에서 \( i \)번째 스티커를 선택하면, 이전 열의 아래쪽 행 스티커를 선택한 경우와 그 전 열의 아래쪽 행 스티커를 선택한 경우 중 최댓값을 더해야 합니다.  
     `dp[0][i] = max(dp[1][i-1], dp[1][i-2]) + sticker[0][i]`
   - 아래쪽 행도 동일한 방식으로 계산합니다.  
     `dp[1][i] = max(dp[0][i-1], dp[0][i-2]) + sticker[1][i]`

3. **초기값 설정**

   - \( i = 0 \)일 때는 단순히 스티커의 점수를 선택합니다.  
     `dp[0][0] = sticker[0][0]`  
     `dp[1][0] = sticker[1][0]`
   - \( i = 1 \)일 때는 두 번째 열을 선택하면서 첫 번째 열과 합산합니다.  
     `dp[0][1] = sticker[0][1] + sticker[1][0]`  
     `dp[1][1] = sticker[1][1] + sticker[0][0]`

4. **최적화**  
   DP 배열 전체를 저장하지 않고, 현재 열과 이전 두 열의 값만 유지하여 계산하면 메모리 사용량을 \( O(1) \)로 줄일 수 있습니다.

## 풀이 과정

테스트 케이스를 입력받아 각 케이스를 순회하며 다음 과정을 수행합니다:

1. 스티커 열의 개수가 1인 경우, 위쪽 행과 아래쪽 행의 첫 번째 값 중 더 큰 값을 결과로 저장합니다.
2. 열의 개수가 2 이상인 경우, 두 열 전의 결과를 저장하는 `dp_prev`와 한 열 전의 결과를 저장하는 `dp_curr`를 초기화합니다.
3. 두 번째 열부터 마지막 열까지 순회하며, 점화식에 따라 현재 열의 최댓값을 계산하여 `new_dp`에 저장합니다.
4. 계산한 `new_dp` 값을 사용해 `dp_prev`와 `dp_curr`를 갱신합니다.
5. 마지막 열에서의 최댓값을 결과 리스트에 저장합니다.
6. 모든 테스트 케이스를 처리한 후, 결과 리스트를 출력합니다.

## 코드 구현

```python
def max_sticker_score(test_cases):
    # 결과를 저장할 리스트를 초기화
    results = []

    # 각 테스트 케이스에 대해 반복
    for stickers in test_cases:
        # 스티커 열의 개수를 계산
        n = len(stickers[0])

        # 열의 개수가 1인 경우 처리
        if n == 1:
            results.append(max(stickers[0][0], stickers[1][0]))
            continue

        # 두 열 전의 결과를 저장할 배열 초기화 (dp[i-2])
        dp_prev = [0, 0]
        # 한 열 전의 결과를 저장할 배열 초기화 (dp[i-1])
        dp_curr = [stickers[0][0], stickers[1][0]]

        # 두 번째 열부터 마지막 열까지 반복
        for i in range(1, n):
            # 현재 열에서 얻을 수 있는 최대 점수 계산
            new_dp = [
                max(dp_curr[1], dp_prev[1]) + stickers[0][i],  # 위쪽 행의 현재 열 점수 계산
                max(dp_curr[0], dp_prev[0]) + stickers[1][i]   # 아래쪽 행의 현재 열 점수 계산
            ]
            # 이전 두 열 값을 갱신
            dp_prev = dp_curr
            dp_curr = new_dp

        # 현재 열에서 최대 점수를 결과 리스트에 추가
        results.append(max(dp_curr))

    # 모든 테스트 케이스에 대해 계산된 결과 반환
    return results

# 테스트 케이스의 개수를 입력받음
t = int(input())
# 각 테스트 케이스를 저장할 리스트 초기화
test_cases = []

# 각 테스트 케이스를 입력받아 저장
for _ in range(t):
    # 열의 개수를 입력받음
    n = int(input())
    # 위쪽 행 스티커 점수를 입력받음
    row1 = list(map(int, input().split()))
    # 아래쪽 행 스티커 점수를 입력받음
    row2 = list(map(int, input().split()))
    # 위쪽 행과 아래쪽 행을 한 쌍으로 리스트에 추가
    test_cases.append([row1, row2])

# 각 테스트 케이스에 대해 최대 점수를 계산
results = max_sticker_score(test_cases)

# 계산된 결과를 한 줄씩 출력
for result in results:
    print(result)
```
