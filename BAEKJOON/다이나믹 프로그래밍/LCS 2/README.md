# 최장 공통 부분 수열 (Longest Common Subsequence)

https://www.acmicpc.net/problem/9252

## 문제 설명
LCS(Longest Common Subsequence, 최장 공통 부분 수열) 문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제입니다.

예를 들어, `ACAYKP`와 `CAPCAK`의 LCS는 `ACAK`가 됩니다.

## 입력
- 첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.

## 출력
- 첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력하고, 둘째 줄에 LCS를 출력한다.
- LCS가 여러 가지인 경우에는 아무거나 출력하고, LCS의 길이가 0인 경우에는 둘째 줄을 출력하지 않는다.

## 예제 입력 1
ACAYKP
CAPCAK

## 예제 출력 1
4
ACAK

## 풀이 과정

### 1. 입력 받기
먼저 두 개의 문자열 `X`와 `Y`를 입력받습니다. 각 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있습니다.

### 2. DP 테이블 생성
동적 프로그래밍(Dynamic Programming)을 위해 `L`이라는 2차원 리스트를 생성합니다. 이 리스트는 `0`으로 초기화되어 있으며, 크기는 `(m+1) x (n+1)`입니다. 여기서 `m`은 첫 번째 문자열의 길이, `n`은 두 번째 문자열의 길이입니다.

### 3. DP 테이블 채우기
두 문자열을 비교하면서 DP 테이블을 채웁니다.
- `X[i-1]`와 `Y[j-1]`가 같으면 `L[i][j] = L[i-1][j-1] + 1`로 설정합니다. 이는 두 문자가 같을 때 대각선 위의 값에 1을 더한 값입니다.
- 그렇지 않으면 `L[i][j] = max(L[i-1][j], L[i][j-1])`로 설정합니다. 이는 두 문자가 다를 때 위쪽 값과 왼쪽 값 중 큰 값을 선택하는 것입니다.

### 4. LCS의 길이 계산
DP 테이블의 마지막 값인 `L[m][n]`이 LCS의 길이입니다. 이는 전체 문자열에서 최장 공통 부분 수열의 길이를 나타냅니다.

### 5. LCS 구성
DP 테이블을 역추적하여 LCS 문자열을 구성합니다. `i`와 `j`를 `m`과 `n`으로 초기화하고, `i`와 `j`가 0보다 큰 동안 다음을 반복합니다:
- 만약 `X[i-1]`가 `Y[j-1]`와 같다면, `lcs` 리스트에 해당 문자를 추가하고 `i`, `j`, `index`를 각각 1씩 감소시킵니다.
- 그렇지 않으면 `L[i-1][j]`와 `L[i][j-1]` 중 큰 값을 가지는 방향으로 이동합니다.

### 6. 결과 반환
LCS의 길이와 LCS 문자열을 반환합니다. 이 값을 사용하여 결과를 출력합니다.

### 7. 결과 출력
LCS의 길이를 출력하고, 길이가 0보다 크면 LCS 문자열도 출력합니다. LCS가 여러 개 있을 경우, 그 중 하나를 출력합니다. 만약 LCS의 길이가 0인 경우에는 두 번째 줄을 출력하지 않습니다.

## 코드

```python
def lcs(X, Y):
    m = len(X)  # 첫 번째 문자열의 길이
    n = len(Y)  # 두 번째 문자열의 길이

    # DP 테이블 생성 (0으로 초기화된 (m+1)x(n+1) 배열)
    L = [[0] * (n + 1) for _ in range(m + 1)]

    # DP 테이블 채우기
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                L[i][j] = L[i - 1][j - 1] + 1  # 문자가 같으면 대각선 위 + 1
            else:
                L[i][j] = max(L[i - 1][j], L[i][j - 1])  # 문자가 다르면 위 또는 왼쪽 값 중 큰 값

    # LCS의 길이
    length_of_lcs = L[m][n]

    # LCS 문자열 구성 (역추적)
    index = L[m][n]
    lcs = [""] * index  # LCS 문자열을 저장할 리스트
    i = m
    j = n
    while i > 0 and j > 0:
        if X[i - 1] == Y[j - 1]:
            lcs[index - 1] = X[i - 1]  # 공통 문자를 LCS 리스트에 저장
            i -= 1
            j -= 1
            index -= 1
        elif L[i - 1][j] > L[i][j - 1]:
            i -= 1  # 위쪽 값이 더 크면 위로 이동
        else:
            j -= 1  # 왼쪽 값이 더 크면 왼쪽으로 이동

    return length_of_lcs, "".join(lcs)  # LCS의 길이와 LCS 문자열을 반환

# 입력 받기
X = input().strip()
Y = input().strip()

# 함수 호출 및 결과 출력
length_of_lcs, lcs_str = lcs(X, Y)
print(length_of_lcs)  # LCS의 길이 출력
if length_of_lcs > 0:
    print(lcs_str)  # LCS 문자열 출력
```