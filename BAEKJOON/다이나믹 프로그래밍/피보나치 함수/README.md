# 피보나치 함수 문제 풀이 및 설명

https://www.acmicpc.net/problem/1003

## 문제 이해

이 문제는 피보나치 수열을 계산하는 과정에서 특정 숫자가 몇 번 출력되는지를 계산하는 것입니다. 주어진 C++ 코드에서 fibonacci(N) 함수를 호출했을 때, 내부적으로 fibonacci(0)과 fibonacci(1)이 여러 번 호출됩니다. 이때, fibonacci(0)은 0을 출력하고, fibonacci(1)은 1을 출력합니다. 문제의 목표는 주어진 N에 대해 fibonacci(N)을 호출했을 때 0과 1이 각각 몇 번 출력되는지를 구하는 것입니다.

이 문제는 단순히 피보나치 수를 계산하는 것뿐만 아니라, 그 과정에서 각 숫자가 몇 번 호출되었는지를 계산해야 하므로, 피보나치 수열의 성질과 재귀 호출의 구조를 잘 이해해야 합니다. 이를 통해 우리는 단순한 피보나치 수 계산 문제를 넘어, 재귀적 호출의 누적 결과를 효과적으로 계산하는 방법을 고민해야 합니다.

## 입출력 조건

**입력:**

- 첫째 줄에 테스트 케이스의 개수 T가 주어집니다. (1 ≤ T ≤ 40)
- 그 다음 각 테스트 케이스마다 한 줄에 N이 주어집니다. N은 0 이상 40 이하의 정수입니다.

**출력:**

- 각 테스트 케이스마다, fibonacci(N)을 호출했을 때 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분하여 한 줄씩 출력합니다.

## 접근 방식

이 문제는 재귀적으로 피보나치 수를 계산하는 방식의 특성을 이해하고, 이를 최적화하여 풀 수 있습니다. 단순히 재귀 호출을 반복하는 방식으로는 중복된 계산이 많이 발생하기 때문에 효율적으로 문제를 해결하기 어렵습니다. 따라서, 동적 프로그래밍(DP) 방법을 사용하여 fibonacci(N)을 계산할 때 fibonacci(0)과 fibonacci(1)이 몇 번 호출되었는지를 미리 계산해두는 방법을 사용할 수 있습니다.

- **동적 프로그래밍 접근:**
  - 피보나치 수열의 성질을 이용해, 작은 문제의 결과를 조합하여 큰 문제를 해결합니다.
  - 미리 dp_zero와 dp_one 배열을 만들어, 각 N에 대해 fibonacci(0)과 fibonacci(1)이 몇 번 호출되었는지를 저장합니다.
  - dp_zero[n]는 fibonacci(n)을 호출했을 때 0이 출력되는 횟수를 저장하고, dp_one[n]은 1이 출력되는 횟수를 저장합니다.
  - 이 값을 계산하기 위해서, dp_zero[n] = dp_zero[n-1] + dp_zero[n-2]와 dp_one[n] = dp_one[n-1] + dp_one[n-2]의 관계를 이용합니다.

## 풀이 과정

1. **DP 배열 초기화:**
   - dp_zero와 dp_one 배열을 만들어, dp_zero[0] = 1, dp_one[0] = 0으로 초기화합니다. 이는 fibonacci(0)이 0을 한 번 출력하고, 1은 출력하지 않음을 의미합니다.
   - dp_zero[1] = 0, dp_one[1] = 1로 초기화합니다. 이는 fibonacci(1)이 1을 한 번 출력하고, 0은 출력하지 않음을 의미합니다.

2. **DP 값 채우기:**
   - N이 2 이상일 때부터 dp_zero와 dp_one 배열을 채워 나갑니다.
   - dp_zero[n]은 dp_zero[n-1]과 dp_zero[n-2]의 합이고, dp_one[n]은 dp_one[n-1]과 dp_one[n-2]의 합으로 계산됩니다
   - 이는 피보나치 수열의 성질을 이용한 것으로, fibonacci(n)은 fibonacci(n-1)과 fibonacci(n-2)를 호출하기 때문에, 0과 1의 출력 횟수도 이전 두 값의 합으로 결정됩니다.

3. **테스트 케이스 처리:**
   - 각 테스트 케이스에 대해 N을 입력받고, dp_zero[N]과 dp_one[N]을 출력합니다.
   - 미리 계산해 둔 DP 배열을 이용해, 각 테스트 케이스에서 0과 1의 출력 횟수를 빠르게 구할 수 있습니다.
  
4. **출력:**
   - 각 테스트 케이스에 대해 계산된 0과 1의 출력 횟수를 공백으로 구분하여 출력합니다. 이를 통해 문제에서 요구하는 형식에 맞게 결과를 반환합니다.

## 코드 구현
```python
def fibonacci_counts(N):
    # N번째 피보나치 수를 계산할 때 0과 1이 각각 몇 번 출력되는지 구하는 함수
    
    # dp_zero는 N번째 피보나치 수를 계산할 때 0이 출력되는 횟수를 저장하는 리스트
    # dp_one은 N번째 피보나치 수를 계산할 때 1이 출력되는 횟수를 저장하는 리스트
    # 리스트의 크기를 N+1로 설정해 N까지의 값을 모두 저장할 수 있게 함
    dp_zero = [0] * (N + 1)
    dp_one = [0] * (N + 1)
    
    # 피보나치 수열에서 N이 0일 때, 0이 한 번 출력되고, 1은 출력되지 않음
    # 따라서 dp_zero[0]은 1, dp_one[0]은 0으로 초기화
    dp_zero[0] = 1
    dp_one[0] = 0
    
    # 피보나치 수열에서 N이 1일 때, 1이 한 번 출력되고, 0은 출력되지 않음
    # 따라서 dp_zero[1]은 0, dp_one[1]은 1로 초기화
    if N > 0:
        dp_zero[1] = 0
        dp_one[1] = 1
    
    # 피보나치 수열의 특성에 따라 dp_zero[i]는 dp_zero[i-1]과 dp_zero[i-2]의 합이 됨
    # 마찬가지로 dp_one[i]도 dp_one[i-1]과 dp_one[i-2]의 합이 됨
    # 이를 통해 피보나치 수를 계산하는 과정에서 0과 1이 출력되는 횟수를 누적하여 계산
    for i in range(2, N + 1):
        dp_zero[i] = dp_zero[i-1] + dp_zero[i-2]
        dp_one[i] = dp_one[i-1] + dp_one[i-2]
    
    # 주어진 N에 대해 0과 1이 각각 몇 번 출력되었는지를 반환
    return dp_zero[N], dp_one[N]

# 테스트 케이스의 수 T를 입력받음
T = int(input())

# 결과를 저장할 리스트 초기화
results = []

# 각 테스트 케이스에서 피보나치 수 N을 입력받음
for _ in range(T):
    N = int(input())
    
    # 입력받은 N에 대해 0과 1의 출력 횟수를 계산
    zero_count, one_count = fibonacci_counts(N)
    
    # 계산된 결과를 "0의 출력 횟수 1의 출력 횟수" 형식으로 results 리스트에 저장
    results.append(f"{zero_count} {one_count}")

# 모든 테스트 케이스에 대해 저장된 결과를 한 줄씩 출력
for result in results:
    print(result)