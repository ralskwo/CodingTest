# 구슬 탈출 2 문제 풀이 및 설명

<https://www.acmicpc.net/problem/13460>

<https://mayquartet.com/python-백준-13460-구슬-탈출2/>

## 문제 이해

이 문제는 빨간 구슬과 파란 구슬을 직사각형의 보드에서 동시에 움직여, **빨간 구슬만 구멍에 빠뜨리는 것이 목표**인 퍼즐 게임 문제입니다. 문제의 목표는 **최소 횟수**로 빨간 구슬을 구멍에 빠뜨리되, 파란 구슬은 구멍에 빠뜨리지 않아야 합니다. 구슬을 한 방향으로 기울이면 구슬은 중력의 방향으로 움직이며, 벽에 막힐 때까지 계속 이동합니다. **빨간 구슬이 구멍에 빠지면 성공**이며, **파란 구슬이 구멍에 빠지거나 두 구슬이 동시에 구멍에 빠지면 실패**입니다. 또한, 빨간 구슬과 파란 구슬은 같은 위치에 존재할 수 없습니다. **최대 10번까지 이동 시도**로 구멍에 빠질 수 없다면, **해결 불가능으로 간주**하고 `-1`을 반환해야 합니다.

## 입출력 조건

- **입력**: 첫 줄에는 보드의 세로(`N`)와 가로(`M`) 크기를 나타내는 두 정수 `N`, `M`이 공백으로 구분되어 주어집니다. 이어서 `N`개의 줄에 걸쳐 보드의 상태가 문자열로 주어지며, 각 줄은 `M`개의 문자로 이루어져 있습니다.
  - 보드의 각 칸은 `'.'`, `'#'`, `'O'`, `'R'`, `'B'` 중 하나로 구성됩니다.
    - `'.'`: 빈 공간을 의미하며 구슬이 이동할 수 있습니다.
    - `'#'`: 벽을 의미하며 구슬이 이동할 수 없습니다.
    - `'O'`: 구멍을 의미합니다.
    - `'R'`: 빨간 구슬의 초기 위치입니다.
    - `'B'`: 파란 구슬의 초기 위치입니다.
  - 보드의 가장자리는 항상 `'#'`로 둘러싸여 있으며 구멍은 하나만 존재합니다.
  - 빨간 구슬과 파란 구슬 또한 각 하나씩 주어집니다.
- **출력**: 빨간 구슬을 구멍에 빠뜨리는 최소 이동 횟수를 출력합니다. 만약, 10번 이하의 이동으로 빨간 구슬만 구멍에 빠뜨리는 것이 불가능하면 `-1`을 출력합니다.

## 접근 방식

이 문제는 **구슬의 위치를 상태로 정의하고 상태를 이동할 때마다 탐색하는 방식**으로 해결할 수 있습니다. 보드의 크기가 작고(최대 10x10), 제한된 이동 횟수(최대 10번)가 주어져 있어 **너비 우선 탐색(BFS)**을 사용하면 효율적으로 최단 경로를 찾을 수 있습니다.

- **BFS**는 최단 경로 탐색에 적합한 알고리즘으로, 각 상태에서 가능한 모든 이동을 탐색하면서 가장 먼저 도달하는 최단 이동 횟수를 구할 수 있습니다.
- BFS를 통해 빨간 구슬과 파란 구슬의 위치를 큐에 넣고, 각 상태에서 네 방향(상, 하, 좌, 우)으로 기울이는 동작을 시도하며 다음 상태로 이동합니다.
- 구슬을 한 방향으로 기울이면 벽에 닿을 때까지 계속 이동하므로, 각 이동에서 구슬의 최종 위치를 계산하는 별도의 함수 `move`를 만들어 구슬을 적절히 이동시킵니다.
- **파란 구슬이 구멍에 빠지면 해당 경로는 실패로 처리**하고 더 이상 탐색하지 않으며, **빨간 구슬만 구멍에 빠졌을 때 성공한 경로로 간주**하고 현재의 이동 횟수를 반환합니다.
- 만약 10번 이하로 모든 가능한 경로를 탐색했음에도 성공 조건을 만족하지 못하면 `-1`을 반환하여 해결 불가 상태를 나타냅니다.

<https://mayquartet.com/algorithm-bfs-너비-우선-탐색-알고리즘/>

## 풀이 과정

1. **입력 데이터 처리 및 보드 설정**:

   - 먼저 보드의 크기 `N`, `M`을 입력으로 받고 보드 상태를 저장합니다. 이때, 빨간 구슬(`R`)과 파란 구슬(`B`)의 초기 위치를 각각 저장해 둡니다. 초기 상태에서 `R`과 `B`의 위치를 찾은 후, 구슬 위치를 `. (빈 공간)`으로 바꾸어 초기 상태를 설정합니다.

2. **BFS 초기 설정**:

   - BFS 탐색을 위해 `deque`를 사용하여 큐를 생성하고, 초기 상태로 빨간 구슬과 파란 구슬의 위치 및 초기 이동 횟수(1)를 큐에 추가합니다.
   - 방문 기록을 저장할 집합 `visited`를 생성하여, `visited`에 초기 위치 상태(빨간 구슬 위치와 파란 구슬 위치 쌍)를 저장하여 중복된 상태 탐색을 방지합니다.

3. **이동 구현 함수 `move` 작성**:

   - `move` 함수는 특정 방향(`dx`, `dy`)으로 구슬을 이동시키며, 벽에 닿거나 구멍에 빠질 때까지 이동합니다.
   - 이동이 완료되면 최종 위치 `(x, y)`와 이동 횟수를 반환하여 이후 상태에서 각 구슬이 어디로 이동했는지를 추적할 수 있게 합니다.
   - 이 함수를 통해 BFS 탐색 중 각 방향으로 구슬이 벽에 막히거나 구멍에 빠질 때까지 한 번에 이동하도록 설정합니다.

4. **BFS 탐색 수행**:

   - 큐가 빌 때까지 `while`문을 통해 BFS 탐색을 수행합니다.
   - 각 상태에서 `상, 하, 좌, 우` 네 방향으로 이동을 시도하며, 각 방향으로 `move` 함수를 호출하여 빨간 구슬과 파란 구슬을 동시에 이동시킵니다.
   - 이동 후 위치를 검사하여 파란 구슬이 구멍에 빠졌을 경우 현재 경로는 실패로 간주하고, 해당 방향의 탐색을 종료합니다.
   - 빨간 구슬이 구멍에 빠졌을 경우 성공한 경로로 간주하여 현재 `depth` 값을 반환하여 탐색을 종료합니다.
   - 두 구슬이 같은 위치에 도달한 경우, 이동 횟수를 비교하여 더 많이 이동한 구슬을 한 칸 뒤로 조정해 서로 겹치지 않게 합니다.
   - 새로운 위치가 `visited`에 없는 상태라면, `visited`에 추가하고 큐에 상태를 추가하여 다음 탐색으로 진행합니다.
   - 이동 횟수가 10을 초과하면 탐색을 중단하고 `-1`을 반환하여 종료합니다.

5. **결과 출력**:
   - BFS 탐색이 종료되면, `bfs` 함수의 반환 값을 출력합니다.
   - 빨간 구슬이 구멍에 빠진 최단 경로의 이동 횟수가 출력되며, 구슬을 구멍에 빠뜨릴 수 없는 경우 `-1`이 출력됩니다.

## 코드 구현

```python
from collections import deque  # BFS 탐색을 위해 deque를 가져옴

def move(x, y, dx, dy):  # 주어진 방향으로 구슬을 이동시키는 함수
    count = 0  # 이동한 칸 수를 저장할 변수
    while board[x+dx][y+dy] != '#' and board[x][y] != 'O':  # 벽이나 구멍에 도달할 때까지 반복
        x += dx  # 구슬을 x 방향으로 이동
        y += dy  # 구슬을 y 방향으로 이동
        count += 1  # 이동 횟수 증가
    return x, y, count  # 최종 위치와 이동 횟수를 반환

def bfs():  # BFS 탐색을 통해 최단 경로를 찾는 함수
    queue = deque([(rx, ry, bx, by, 1)])  # 빨간 구슬, 파란 구슬의 초기 위치와 깊이(1)를 큐에 추가
    visited = set([(rx, ry, bx, by)])  # 방문한 위치를 기록하여 중복 탐색을 방지

    while queue:  # 큐가 빌 때까지 반복
        crx, cry, cbx, cby, depth = queue.popleft()  # 현재 상태(구슬 위치와 깊이)를 큐에서 꺼냄

        if depth > 10:  # 이동 횟수가 10을 넘으면 더 이상 탐색하지 않음
            break

        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:  # 네 방향(상하좌우)으로 기울이기 시도
            nrx, nry, r_count = move(crx, cry, dx, dy)  # 빨간 구슬을 해당 방향으로 이동
            nbx, nby, b_count = move(cbx, cby, dx, dy)  # 파란 구슬을 해당 방향으로 이동

            if board[nbx][nby] != 'O':  # 파란 구슬이 구멍에 빠지지 않은 경우에만 진행
                if board[nrx][nry] == 'O':  # 빨간 구슬이 구멍에 빠진 경우
                    return depth  # 성공한 횟수를 반환하고 종료

                if nrx == nbx and nry == nby:  # 빨간 구슬과 파란 구슬이 같은 위치에 도달한 경우
                    if r_count > b_count:  # 더 많이 이동한 구슬을 한 칸 뒤로 조정
                        nrx -= dx
                        nry -= dy
                    else:
                        nbx -= dx
                        nby -= dy

                if (nrx, nry, nbx, nby) not in visited:  # 아직 방문하지 않은 위치일 경우
                    visited.add((nrx, nry, nbx, nby))  # 방문 위치로 등록
                    queue.append((nrx, nry, nbx, nby, depth+1))  # 큐에 새로운 상태를 추가하여 탐색

    return -1  # 10번 이하의 이동으로 빨간 구슬을 구멍에 넣을 수 없는 경우 -1 반환

N, M = map(int, input().split())  # 보드의 크기를 입력 받음
board = [list(input().strip()) for _ in range(N)]  # 보드의 상태를 2차원 리스트로 입력 받음

rx, ry, bx, by = 0, 0, 0, 0  # 빨간 구슬과 파란 구슬의 위치를 저장할 변수 초기화
for i in range(N):  # 보드의 모든 위치를 순회하면서
    for j in range(M):
        if board[i][j] == 'R':  # 빨간 구슬 위치를 찾으면
            rx, ry = i, j  # 빨간 구슬의 위치를 저장
        elif board[i][j] == 'B':  # 파란 구슬 위치를 찾으면
            bx, by = i, j  # 파란 구슬의 위치를 저장

print(bfs())  # BFS 함수를 호출하여 결과를 출력
```
