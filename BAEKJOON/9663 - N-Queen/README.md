# N-Queen 문제 풀이 및 설명

https://www.acmicpc.net/problem/9663

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-9663-n-queen-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

N-Queen 문제는 체스판 위에 N개의 퀸을 서로 공격하지 못하게 배치하는 경우의 수를 구하는 문제입니다. 체스에서 퀸은 상하좌우, 그리고 대각선으로 공격할 수 있는 능력을 가집니다. 즉, 같은 행이나 같은 열, 또는 같은 대각선에 퀸이 배치되면 서로 공격할 수 있게 됩니다. 이 문제의 목표는 N × N 크기의 체스판에서 N개의 퀸을 서로 공격하지 않도록 배치할 수 있는 방법이 몇 가지인지 찾는 것입니다.

### 예시

N이 8일 경우, 8개의 퀸을 8 × 8 체스판 위에 서로 공격하지 않게 배치할 수 있는 경우의 수는 92입니다.

## 입출력 조건

### 입력

- 첫 번째 줄에 정수 N이 주어집니다. 여기서 N은 체스판의 크기를 나타내며, 퀸의 개수도 N과 같습니다.
- N의 범위는 1 이상 14 미만의 정수입니다. 즉, 1 ≤ N < 15입니다.

### 출력

- 첫 번째 줄에 퀸 N개를 서로 공격하지 않도록 배치할 수 있는 경우의 수를 출력합니다.

## 접근 방식

이 문제는 일반적으로 **백트래킹(Backtracking)**을 통해 해결할 수 있습니다. 백트래킹은 가능한 모든 경우의 수를 탐색하며, 특정 조건을 만족하지 않을 때는 탐색을 중지하고 이전 단계로 돌아가는 방식입니다. N-Queen 문제에서 백트래킹을 적용하면, 체스판의 각 행마다 퀸을 하나씩 놓으면서 조건을 만족하는지 확인하고, 조건을 만족하지 못하면 그 자리에 퀸을 놓지 않고 다른 곳에 놓는 방식으로 탐색합니다.

### 알고리즘 선택

이 문제는 기본적으로 **백트래킹**을 사용하는 것이 가장 적합합니다. 백트래킹을 통해 다음과 같은 조건을 확인하며 탐색을 진행합니다:

1. **같은 열에 퀸이 있는지**: 한 열에 퀸을 두 개 이상 놓을 수 없습니다.
2. **좌하향 대각선에 퀸이 있는지**: 퀸은 대각선 방향으로 공격할 수 있기 때문에, 좌하향 대각선에 다른 퀸이 있으면 그 자리에 퀸을 놓을 수 없습니다.
3. **우하향 대각선에 퀸이 있는지**: 마찬가지로, 우하향 대각선에 다른 퀸이 있으면 퀸을 놓을 수 없습니다.

이러한 조건들을 빠르게 처리하기 위해 **비트마스크**를 사용할 수 있습니다. 비트마스크를 사용하면 열과 대각선에 대한 정보를 효율적으로 관리할 수 있어 탐색 속도를 높일 수 있습니다.

## 풀이 과정

1. **백트래킹을 통한 퀸 배치 탐색**:  
   먼저 0번째 행에서부터 시작하여, 퀸을 놓을 수 있는 모든 위치를 탐색합니다. 각 행에서는 퀸을 놓을 수 있는 열을 선택하고, 선택한 열이 다른 퀸과 충돌하지 않는지 확인합니다. 만약 퀸을 놓을 수 있다면, 그 다음 행으로 넘어가 퀸을 놓습니다. 이 과정을 반복하면서 마지막 행까지 퀸을 놓게 되면, 유효한 배치로 간주하여 경우의 수를 카운트합니다.

2. **비트마스크를 활용한 열과 대각선 관리**:  
   열과 대각선을 비트마스크로 관리하여, 퀸이 놓일 수 있는 위치를 효율적으로 추적합니다.

   - `cols`는 현재 퀸이 놓여 있는 열을 추적합니다. 만약 `cols`에서 해당 열의 비트가 1이면, 그 열에는 이미 퀸이 놓여 있으므로 그 자리에 퀸을 놓을 수 없습니다.
   - `diag1`은 좌하향 대각선을 추적합니다. 퀸이 놓이면 그 퀸이 공격할 수 있는 좌하향 대각선의 위치를 기록하고, 그 위치에 퀸을 놓지 않도록 해야 합니다.
   - `diag2`는 우하향 대각선을 추적합니다. 우하향 대각선 역시 마찬가지로 퀸이 공격할 수 있는 위치를 추적하여, 그 위치에는 퀸을 놓지 않도록 합니다.

3. **퀸을 놓을 수 있는 위치 계산**:  
   현재 퀸을 놓을 수 있는 위치는 `cols`, `diag1`, `diag2`에 저장된 비트마스크를 이용하여 계산합니다. 먼저 공격할 수 있는 위치는 모두 1로 설정된 비트마스크를 만들고, 그 위치에 퀸을 놓을 수 없도록 제외한 후 남은 자리 중에서 퀸을 배치할 수 있습니다.

4. **가장 오른쪽 1비트를 이용해 퀸 배치**:  
   퀸을 놓을 수 있는 자리 중에서 가장 오른쪽에 있는 비트를 추출하여 그 위치에 퀸을 놓습니다. 그 후, 남은 자리에서 다시 퀸을 놓을 수 있는지 확인하며 다음 행으로 이동합니다. 이 과정에서 퀸을 놓고 다시 제거하는 것이 반복되므로 백트래킹 방식입니다.

5. **모든 행에 퀸을 놓았을 경우 카운트 증가**:  
   만약 N개의 행에 모두 퀸을 배치했다면, 유효한 배치로 간주하여 경우의 수를 카운트합니다. 그 후 다시 이전 상태로 돌아가 다른 경우의 수를 탐색합니다.

6. **최종 결과 출력**:  
   모든 경우의 수를 계산한 후, 최종적으로 퀸을 놓을 수 있는 방법의 수를 출력합니다.

## 코드 구현

```python
def n_queen(N):
    # 퀸을 배치하는 함수. 현재 row 행에 퀸을 놓을 수 있는 위치를 탐색한다.
    # cols: 현재까지 퀸이 놓인 열 정보 (비트마스크로 관리)
    # diag1: 좌하향 대각선 정보 (비트마스크로 관리)
    # diag2: 우하향 대각선 정보 (비트마스크로 관리)
    def solve(row, cols, diag1, diag2):
        # 모든 행에 퀸을 놓았을 경우 (즉, row == N이면 N개의 퀸을 모두 놓은 것임)
        if row == N:
            return 1  # 유효한 배치 하나를 찾았으므로 1을 반환

        count = 0  # 가능한 배치의 수를 세기 위한 변수

        # 가능한 퀸의 위치를 비트마스크로 계산
        # (~(cols | diag1 | diag2))는 퀸을 놓을 수 없는 자리(열, 대각선)를 제외한 자리
        # ((1 << N) - 1)은 N개의 열을 표현하는 비트마스크 (모든 열이 1인 상태)
        available_positions = (~(cols | diag1 | diag2)) & ((1 << N) - 1)

        # available_positions에 퀸을 놓을 수 있는 자리가 있을 때까지 반복
        while available_positions:
            # 가능한 위치 중 가장 오른쪽의 비트(퀸을 놓을 자리)를 구함
            pos = available_positions & -available_positions

            # 해당 비트를 지워서 퀸을 그 위치에 놓음
            available_positions -= pos

            # 다음 행으로 넘어가면서 퀸을 놓고, 열과 대각선 정보를 갱신
            # cols | pos: 현재 열에 퀸을 놓았음을 기록
            # (diag1 | pos) << 1: 좌하향 대각선에 대한 정보 업데이트 (한 칸씩 왼쪽으로 밀림)
            # (diag2 | pos) >> 1: 우하향 대각선에 대한 정보 업데이트 (한 칸씩 오른쪽으로 밀림)
            count += solve(row + 1, cols | pos, (diag1 | pos) << 1, (diag2 | pos) >> 1)

        # row 행에서 가능한 모든 경우를 다 확인한 후 가능한 배치 수를 반환
        return count

    # solve 함수를 호출하여 0번째 행부터 시작하고, 초기 상태에서는 퀸이 놓이지 않았으므로 모두 0으로 초기화
    return solve(0, 0, 0, 0)

# 사용자로부터 N을 입력받음
N = int(input())

# N-Queen 문제의 해결 방법 수를 출력
print(n_queen(N))
```
