# 포도주 시식 문제 풀이 및 설명

https://www.acmicpc.net/problem/2156

## 문제 이해

이 문제는 효주가 포도주 잔을 시식할 때, 연속으로 두 잔을 마실 수 없는 제약 조건 하에서 최대한 많은 포도주를 마실 수 있는 양을 구하는 것입니다. 문제에서 제시된 예제를 보면, 각 포도주 잔에 들어 있는 포도주의 양이 주어졌을 때, 어떤 잔을 선택해야 최대로 마실 수 있는지를 계산하는 것이 목표입니다.

## 입출력 조건

**입력 조건**:
1. 첫 번째 줄에는 포도주 잔의 개수 `n`이 주어집니다. (`1 ≤ n ≤ 10,000`)
2. 두 번째 줄부터 `n+1`번째 줄까지 각 포도주 잔에 들어 있는 포도주의 양이 순서대로 주어집니다. 포도주의 양은 1,000 이하의 양의 정수입니다.

**출력 조건**:
1. 첫 번째 줄에 최대로 마실 수 있는 포도주의 양을 출력합니다.

## 접근 방식

이 문제를 해결하기 위해서는 동적 계획법(Dynamic Programming)을 사용해야 합니다. 동적 계획법은 복잡한 문제를 더 작은 부분 문제로 나누어 해결하는 방식으로, 이미 계산한 결과를 저장해 두었다가 나중에 재사용하는 방법입니다.

1. **동적 계획법 배열 정의**:
   - `dp[i]`를 `i`번째 잔까지 최대로 마실 수 있는 포도주의 양이라고 정의합니다.

2. **점화식 정의**:
   - `dp[i]`는 세 가지 경우 중 최대값을 선택합니다:
     1. `dp[i-1]` (현재 잔을 마시지 않는 경우)
     2. `dp[i-2] + wines[i]` (전전 잔까지의 최대 양 + 현재 잔의 포도주 양)
     3. `dp[i-3] + wines[i-1] + wines[i]` (전전전 잔까지의 최대 양 + 직전 잔의 포도주 양 + 현재 잔의 포도주 양)

3. **초기값 설정**:
   - `dp[0]` = `wines[0]`
   - `dp[1]` = `wines[0] + wines[1]`
   - `dp[2]` = `max(wines[0] + wines[1], wines[0] + wines[2], wines[1] + wines[2])`

## 풀이 과정

1. `n`이 1인 경우:
   - 포도주 잔이 하나만 있기 때문에, 그 잔의 포도주 양이 최대로 마실 수 있는 양이 됩니다. 따라서 `wines[0]`을 반환합니다.

2. `n`이 2인 경우:
   - 포도주 잔이 두 개이기 때문에, 두 잔의 포도주 양을 모두 마시는 것이 최대로 마실 수 있는 양입니다. 따라서 `wines[0] + wines[1]`을 반환합니다.

3. `n`이 3 이상인 경우:
   - `dp` 배열을 사용하여 각 잔까지의 최대로 마실 수 있는 포도주의 양을 저장합니다.
   - `dp[0]`는 첫 번째 잔의 포도주 양으로 설정합니다.
   - `dp[1]`는 첫 번째와 두 번째 잔의 포도주 양의 합으로 설정합니다.
   - `dp[2]`는 세 가지 경우 중 최대값으로 설정합니다:
     1. 첫 번째와 두 번째 잔을 마시는 경우 (`wines[0] + wines[1]`)
     2. 첫 번째와 세 번째 잔을 마시는 경우 (`wines[0] + wines[2]`)
     3. 두 번째와 세 번째 잔을 마시는 경우 (`wines[1] + wines[2]`)

4. `dp` 배열을 채워 나갑니다:
   - `for` 루프를 사용하여 `dp[3]`부터 `dp[n-1]`까지 각 잔에 대해 최대로 마실 수 있는 포도주의 양을 계산합니다.
   - `dp[i]`는 다음 세 가지 경우 중 최대값으로 설정합니다:
     1. `dp[i-1]`: 현재 잔을 마시지 않는 경우.
     2. `dp[i-2] + wines[i]`: 현재 잔을 마시고, 이전 잔은 마시지 않는 경우.
     3. `dp[i-3] + wines[i-1] + wines[i]`: 현재 잔과 이전 잔을 마시고, 그 이전 잔은 마시지 않는 경우.

5. 최종 결과는 `dp[n-1]`에 저장된 값으로, 이는 주어진 모든 잔에 대해 최대로 마실 수 있는 포도주의 양을 의미합니다.

## 코드 구현
```python
def max_wine_amount(n, wines):
    # 만약 포도주 잔이 하나만 있다면, 그 잔의 포도주 양을 반환
    if n == 1:
        return wines[0]
    
    # 만약 포도주 잔이 두 개만 있다면, 두 잔의 포도주 양을 더한 값을 반환
    if n == 2:
        return wines[0] + wines[1]
    
    # dp 배열을 초기화합니다. dp[i]는 i번째 잔까지 최대로 마실 수 있는 포도주 양을 저장합니다.
    dp = [0] * n
    
    # 기본 값 설정
    dp[0] = wines[0]  # 첫 번째 잔을 고려할 때의 최댓값
    dp[1] = wines[0] + wines[1]  # 첫 번째와 두 번째 잔을 고려할 때의 최댓값
    
    # 첫 번째, 두 번째, 세 번째 잔을 고려할 때의 최댓값
    dp[2] = max(wines[0] + wines[1],  # 경우 1: 첫 번째와 두 번째 잔을 마신다.
                wines[0] + wines[2],  # 경우 2: 첫 번째와 세 번째 잔을 마신다.
                wines[1] + wines[2])  # 경우 3: 두 번째와 세 번째 잔을 마신다.
    
    # 네 번째 잔부터 n번째 잔까지 dp 배열을 채웁니다.
    for i in range(3, n):
        # i번째 잔에 대한 최댓값은 세 가지 경우 중 최대값입니다:
        dp[i] = max(dp[i-1],  # 경우 1: i번째 잔을 건너뛰는 경우
                    dp[i-2] + wines[i],  # 경우 2: i번째 잔을 마시고 (i-1)번째 잔을 건너뛰는 경우
                    dp[i-3] + wines[i-1] + wines[i])  # 경우 3: i번째 잔과 (i-1)번째 잔을 마시고 (i-2)번째 잔을 건너뛰는 경우
    
    # 결과는 n개의 잔을 고려한 최댓값입니다.
    return dp[-1]

# 입력 처리
n = int(input())  # 포도주 잔의 개수를 입력 받습니다.
wines = [int(input()) for _ in range(n)]  # 각 포도주 잔에 들어 있는 포도주 양을 입력 받습니다.

# 최대로 마실 수 있는 포도주의 양을 출력합니다.
print(max_wine_amount(n, wines))
