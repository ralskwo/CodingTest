# 기타 레슨 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2343>

<https://mayquartet.com/python-백준-2343-기타-레슨/>

## 문제 이해

이 문제는 주어진 강의들을 블루레이에 녹화할 때, 블루레이의 크기를 최소로 설정하는 것을 목표로 합니다.  
강의의 순서는 유지되어야 하며, 한 개의 블루레이에는 연속된 강의만 들어갈 수 있습니다.  
강의를 나눠 담을 수 있는 블루레이의 개수는 제한되어 있으며, 모든 블루레이의 크기는 동일해야 합니다.  
목표는 최소 크기의 블루레이를 사용해 주어진 개수의 블루레이 안에 모든 강의를 담는 것입니다.

이 문제는 특정 조건 하에서 최적의 값을 찾는 전형적인 최적화 문제로, 적절한 탐색 알고리즘을 사용해 풀어야 합니다.  
이분 탐색과 같은 알고리즘을 사용하면 효율적으로 문제를 해결할 수 있습니다.

## 입출력 조건

### 입력

- 첫 번째 줄에 강의의 개수 N(1 ≤ N ≤ 100,000)과 블루레이의 개수 M(1 ≤ M ≤ N)이 주어집니다.
- 두 번째 줄에는 각 강의의 길이가 순서대로 주어집니다.
- 각 강의의 길이는 1 이상 10,000 이하의 자연수입니다.

### 출력

- 가능한 블루레이 크기 중 가장 작은 값을 한 줄로 출력합니다.

## 접근 방식

이 문제는 주어진 조건을 만족하면서 블루레이의 크기를 최소화하는 최적화 문제입니다.  
따라서, 블루레이의 크기를 결정하는 값을 탐색하는 방법이 필요합니다.  
이때, **이분 탐색**을 사용하면 효율적으로 문제를 해결할 수 있습니다.

블루레이의 크기를 특정 값으로 설정하고, 그 크기에서 몇 개의 블루레이가 필요한지 확인하는 방식으로 접근합니다.  
블루레이의 크기가 작으면 더 많은 블루레이가 필요하고, 크면 더 적은 블루레이가 필요합니다.  
이를 통해 가능한 최소 블루레이 크기를 찾습니다.

이 문제는 **'매개 변수 탐색'**이라는 방법을 사용합니다.  
매개 변수 탐색은 특정 조건을 만족하는 최소값이나 최대값을 찾는 데 유용합니다.  
블루레이의 크기를 이분 탐색으로 조절하면서 가능한 블루레이 개수를 계산하고, 조건을 만족하는 최소 크기를 찾습니다.

<https://mayquartet.com/algorithm-binary-search/>

## 풀이 과정

1. **블루레이 크기의 최소값과 최대값을 설정합니다.**

   - 최소값은 **가장 긴 강의의 길이**입니다.  
     블루레이 크기가 이보다 작으면 가장 긴 강의를 담을 수 없기 때문입니다.
   - 최대값은 **모든 강의를 하나의 블루레이에 담았을 때의 총 길이**입니다.

2. **이분 탐색을 통해 블루레이 크기를 조정해 나갑니다.**

   - 중간값을 블루레이 크기로 설정하고, 해당 크기로 블루레이를 나눌 때 필요한 블루레이 개수를 계산합니다.

3. **블루레이 개수를 계산할 때는 강의를 순서대로 담으면서 현재 블루레이의 용량을 초과하는 경우 새로운 블루레이를 사용합니다.**

   - 이를 반복해 블루레이의 개수를 구합니다.

4. **만약 중간값 크기에서 블루레이 개수가 목표 개수보다 작거나 같다면, 해당 크기가 가능하다는 의미이므로 더 작은 크기를 탐색합니다.**

   - 반대로, 중간값에서 블루레이 개수가 목표 개수보다 크다면 블루레이 크기가 작다는 의미이므로 더 큰 크기를 탐색합니다.

5. **이 과정을 반복해 최종적으로 찾은 블루레이 크기를 출력합니다.**

이 방식은 시간 복잡도가 **O(N log S)**로,  
여기서 N은 강의의 개수, S는 모든 강의 길이의 합입니다.  
따라서, 주어진 조건 내에서 매우 효율적으로 동작합니다.

## 코드 구현

```python
def count_blurays(lectures, size):
    count = 1  # 사용된 블루레이 개수를 세기 위한 변수. 최소 1개의 블루레이는 필요하므로 1로 초기화
    total = 0  # 현재 블루레이에 담긴 강의 길이 합을 저장하는 변수

    for lecture in lectures:  # 강의 목록을 순회하면서 각 강의를 블루레이에 담음
        if total + lecture > size:  # 현재 블루레이에 강의를 추가했을 때 블루레이 크기를 초과하는 경우
            count += 1  # 새로운 블루레이가 필요하므로 개수 증가
            total = lecture  # 새 블루레이에 현재 강의를 담음 (누적 합 초기화)
        else:
            total += lecture  # 크기를 초과하지 않으면 현재 블루레이에 강의를 추가

    return count  # 사용된 블루레이의 총 개수 반환

def find_minimum_bluray_size(n, m, lectures):
    left = max(lectures)  # 블루레이 크기의 최소값은 가장 긴 강의의 길이
    right = sum(lectures)  # 블루레이 크기의 최대값은 모든 강의를 하나의 블루레이에 담았을 때의 총합
    answer = right  # 가능한 최소 블루레이 크기를 저장하는 변수. 초기값은 최대값으로 설정

    while left <= right:  # 이분 탐색 시작
        mid = (left + right) // 2  # 중간값을 블루레이 크기로 설정
        if count_blurays(lectures, mid) <= m:  # 중간값 크기에서 필요한 블루레이 개수가 M 이하인 경우
            answer = mid  # 가능한 블루레이 크기 중 더 작은 값을 찾기 위해 현재 값을 저장
            right = mid - 1  # 블루레이 크기를 줄이기 위해 탐색 범위를 왼쪽으로 이동
        else:  # 중간값에서 필요한 블루레이 개수가 M보다 큰 경우
            left = mid + 1  # 블루레이 크기를 늘리기 위해 탐색 범위를 오른쪽으로 이동

    return answer  # 최종적으로 찾은 최소 블루레이 크기 반환

n, m = map(int, input().split())  # 강의의 개수 N과 블루레이 개수 M 입력
lectures = list(map(int, input().split()))  # 각 강의의 길이를 입력받아 리스트로 저장

print(find_minimum_bluray_size(n, m, lectures))  # 최소 블루레이 크기를 계산하고 출력
```
