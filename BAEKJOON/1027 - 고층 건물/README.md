# 고층 건물 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1027>

<https://mayquartet.com/python-백준-1027-고층-건물/>

## 문제 이해

이 문제는 여러 개의 고층 빌딩이 일렬로 늘어선 상황에서, 특정 빌딩에서 다른 빌딩이 보이는지 여부를 판단하는 문제입니다. 빌딩 간의 위치는 1차원 좌표로 표현되며, 높이는 2차원 좌표로 나타납니다. 각 빌딩을 하나의 점으로 간주하고, 해당 빌딩의 높이를 세로선으로 표현합니다. 빌딩 A에서 빌딩 B가 보이려면, A와 B를 잇는 선분이 다른 빌딩에 의해 가려지지 않아야 합니다. 이 문제는 특정 빌딩에서 최대 몇 개의 다른 빌딩이 보이는지 계산하는 것이 목표입니다.

주어진 예시를 통해 문제를 이해할 수 있습니다. 예를 들어, 빌딩들의 높이가 주어지면, 각각의 빌딩에서 좌우 방향으로 다른 빌딩들이 얼마나 보이는지를 계산합니다. 빌딩 사이의 기울기를 통해, 다른 빌딩이 두 빌딩 사이에 끼어 있는지를 판단할 수 있습니다.

결국, 이 문제는 기하학적 관점에서 빌딩 간의 가시성을 판단하는 문제이며, 두 점을 잇는 직선과 중간의 방해물이 존재하는지 여부를 검사하는 방식으로 해결됩니다.

## 입출력 조건

입력은 두 줄로 구성됩니다.

첫 번째 줄에는 빌딩의 수인 자연수 N이 주어집니다. N은 1 이상 50 이하입니다.  
두 번째 줄에는 1번 빌딩부터 N번 빌딩까지의 높이가 차례로 주어집니다. 각 빌딩의 높이는 1 이상 1,000,000,000 이하의 자연수입니다.

출력은 한 줄로, 가장 많은 빌딩이 보이는 특정 빌딩에서 보이는 다른 빌딩의 수를 출력합니다.

### 조건 정리

- 빌딩의 수 N은 1 이상 50 이하입니다.
- 빌딩의 높이는 1 이상 1,000,000,000 이하입니다.
- 출력은 특정 빌딩에서 보이는 최대 빌딩 수입니다.

## 접근 방식

이 문제를 해결하기 위해서는 다음과 같은 관점에서 접근해야 합니다.

1. **기울기 활용**

   - 두 빌딩 A와 B가 서로 보이기 위해서는, A와 B를 잇는 직선보다 중간에 있는 빌딩이 낮아야 합니다.
   - 두 빌딩 사이의 기울기를 계산하여 중간 빌딩이 이보다 높으면 빌딩 B는 보이지 않게 됩니다.

2. **브루트포스 방식**

   - 모든 빌딩에 대해 가능한 모든 빌딩과의 관계를 확인합니다.
   - 각 빌딩에서 왼쪽과 오른쪽으로 다른 빌딩이 보이는지 하나씩 검사하여 계산하는 방식입니다.

3. **시간 복잡도 고려**

   - 빌딩의 수 N이 최대 50으로 제한되어 있으므로, 빌딩 간의 모든 관계를 확인해도 최대 2500번의 연산이 필요합니다.
   - 이는 충분히 계산 가능한 범위이므로 브루트포스 방식으로 접근하는 것이 적합합니다.

4. **수학적 관점에서의 검증**
   - 기울기 계산을 통해 중간 빌딩이 보이는지 여부를 결정하는 방식은 명확하고 직관적입니다.
   - 이를 이용하여 두 빌딩 사이의 선분이 다른 빌딩에 의해 가려지는지를 판단할 수 있습니다.

## 풀이 과정

1. 각 빌딩에 대해 좌우로 보이는 빌딩의 수를 계산해야 합니다. 이를 위해 빌딩 i를 기준으로 왼쪽과 오른쪽에 있는 모든 빌딩을 탐색합니다.

2. 두 빌딩 i와 j가 보이는지 판단하기 위해 두 빌딩의 기울기를 계산합니다. 기울기는 두 빌딩의 높이 차이를 두 빌딩 간의 거리로 나눈 값입니다.

3. 빌딩 i와 j 사이에 있는 모든 빌딩 k에 대해, 해당 빌딩의 높이가 i와 j를 잇는 선분보다 높거나 같은지 확인합니다. 만약 빌딩 k가 선분 위에 있거나 선분보다 높다면 빌딩 j는 보이지 않습니다.

4. 모든 빌딩에 대해 이 과정을 반복하고, 보이는 빌딩 수 중 최대값을 찾아 출력합니다.

5. 최종적으로, 가장 많은 빌딩을 볼 수 있는 특정 빌딩에서 보이는 빌딩의 수를 반환합니다.

이 방식은 빌딩 간의 기울기를 활용하는 기본적인 기하학 문제로, 빌딩이 보이는 조건을 명확하게 수학적으로 판단해야 합니다. 이를 통해 문제를 단계별로 해결할 수 있으며, 빌딩의 수가 많지 않기 때문에 모든 경우를 검사하는 방식이 효율적입니다.

## 코드 구현

```python
def count_visible_buildings(N, heights):
    # 두 빌딩이 서로 보이는지 여부를 판단하는 함수
    def is_visible(i, j):
        # 두 빌딩 i, j 사이의 기울기 계산
        slope = (heights[j] - heights[i]) / (j - i)
        # i와 j 사이에 있는 모든 빌딩을 확인
        for k in range(i + 1, j):
            # k번 빌딩이 i에서 j로 가는 선분 위나 위쪽에 있는 경우 가려짐
            if heights[k] >= heights[i] + slope * (k - i):
                return False
        # 가려지지 않으면 두 빌딩은 서로 보임
        return True

    # 최대 보이는 빌딩 수를 저장하는 변수
    max_count = 0

    # 각 빌딩을 기준으로 보이는 빌딩 수 계산
    for i in range(N):
        # 현재 빌딩에서 보이는 빌딩 수 초기화
        visible_count = 0

        # 현재 빌딩의 왼쪽에 있는 빌딩을 확인
        for j in range(i - 1, -1, -1):
            # i번 빌딩에서 j번 빌딩이 보이는 경우 카운트 증가
            if is_visible(j, i):
                visible_count += 1

        # 현재 빌딩의 오른쪽에 있는 빌딩을 확인
        for j in range(i + 1, N):
            # i번 빌딩에서 j번 빌딩이 보이는 경우 카운트 증가
            if is_visible(i, j):
                visible_count += 1

        # 최대 보이는 빌딩 수 갱신
        max_count = max(max_count, visible_count)

    # 모든 빌딩에 대해 계산한 결과 중 가장 큰 값을 반환
    return max_count

# 빌딩의 개수 입력
N = int(input())
# 빌딩의 높이 입력
heights = list(map(int, input().split()))
# 결과 출력
print(count_visible_buildings(N, heights))
```
