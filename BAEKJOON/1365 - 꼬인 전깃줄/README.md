# 꼬인 전깃줄 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1365>

<https://mayquartet.com/python-백준-1365-꼬인-전깃줄/>

## 문제 이해

이 문제는 전봇대 사이에 연결된 전선들이 서로 꼬이는 상황을 해결하는 것입니다. 길 왼쪽의 전봇대와 길 오른쪽의 전봇대가 1대1로 연결되어 있으며, 이 전선들이 교차하지 않도록 최소한의 전선을 제거하는 것이 목표입니다. 전선이 교차하지 않는 상태는 길 오른쪽의 전봇대 연결 번호가 **비내림차순(오름차순 포함)**으로 정렬된 상태를 의미합니다. 예를 들어, 전봇대 연결 상태가 2, 3, 4, 1로 주어진 경우, 1이 4보다 작기 때문에 교차가 발생합니다. 이를 방지하려면 1을 연결하는 전선을 제거해야 합니다.

이 문제는 전봇대의 개수가 최대 10만 개로 매우 크기 때문에, 효율적인 알고리즘을 사용해야 시간 초과 없이 문제를 해결할 수 있습니다. 핵심은 **꼬이지 않는 전선의 개수**를 최대화하고, 나머지를 잘라내는 방식으로 접근하는 것입니다.

## 입출력 조건

입력은 두 부분으로 구성됩니다.

- 첫 줄에는 전봇대의 개수인 자연수 N이 주어집니다. N은 1 이상 100,000 이하의 값입니다.
- 그다음 줄에는 N개의 정수로 이루어진 전봇대 연결 상태가 주어집니다. 각 정수는 1부터 N까지의 값이며, 길 왼쪽의 i번째 전봇대가 길 오른쪽의 몇 번째 전봇대와 연결되어 있는지를 나타냅니다.

출력은 잘라내야 할 전선의 최소 개수를 나타내는 하나의 정수입니다.

## 접근 방식

이 문제는 전봇대의 연결 상태에서 **가장 긴 증가하는 부분 수열(LIS, Longest Increasing Subsequence)**을 구하는 방식으로 해결할 수 있습니다. LIS는 전선이 교차하지 않고 순서대로 연결되는 가장 긴 부분 수열을 의미합니다.

교차하지 않는 전선의 개수를 최대화하는 것이 목표이므로, 전봇대 연결 상태에서 LIS의 길이를 구하고 전체 전봇대 개수에서 LIS의 길이를 뺀 값이 제거해야 할 전선의 최소 개수가 됩니다.

이 문제를 O(N log N)의 시간 복잡도로 해결하기 위해 **이분 탐색과 동적 프로그래밍을 결합한 방식**을 사용합니다. bisect_left 함수를 사용해 LIS를 효율적으로 구성하고, 주어진 전봇대 연결 상태를 순차적으로 LIS에 추가하거나 갱신해 나갑니다.

<https://www.acmicpc.net/problem/1365>

<https://mayquartet.com/algorithm-lis-longest-increasing-subsequence/>

## 풀이 과정

1. 먼저 전봇대 개수 N과 전봇대 연결 상태를 입력받습니다.
2. 전봇대 연결 상태를 순회하면서 **현재 전봇대가 LIS의 어디에 들어갈 수 있는지**를 이분 탐색을 통해 찾습니다. 이를 위해 bisect_left 함수를 사용합니다.
3. bisect_left는 현재 LIS에서 현재 전봇대 번호가 들어갈 위치를 반환합니다.
   - 만약 반환된 위치가 LIS의 끝이라면, LIS에 새로운 전봇대를 추가합니다.
   - 만약 반환된 위치가 LIS 중간이라면, 해당 위치의 값을 현재 전봇대 번호로 교체합니다.
4. 이 과정을 모든 전봇대에 대해 반복하며, 결과적으로 LIS의 길이가 구해집니다.
5. 마지막으로 전체 전봇대 개수 N에서 LIS의 길이를 뺀 값이 잘라야 할 전선의 최소 개수가 됩니다. 이를 출력합니다.

이 방식은 LIS를 구하는 데 O(N log N)의 시간 복잡도를 가지며, 최대 10만 개의 전봇대에 대해서도 빠르게 해결할 수 있습니다.

## 코드 구현

```python
from bisect import bisect_left

def minimum_cut_wires(N, poles):
    lis = []

    for pole in poles:
        pos = bisect_left(lis, pole)
        if pos == len(lis):
            lis.append(pole)
        else:
            lis[pos] = pole

    return N - len(lis)

if __name__ == "__main__":
    N = int(input().strip())
    poles = list(map(int, input().split()))
    print(minimum_cut_wires(N, poles))
```
