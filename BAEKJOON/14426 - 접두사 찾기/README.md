# 접두사 찾기 문제 풀이 및 설명

https://www.acmicpc.net/problem/14426

## 문제 이해

이 문제는 문자열 접두사와 관련된 문제입니다. 주어진 여러 개의 문자열(N개의 문자열 집합)과 또 다른 여러 개의 문자열(M개의 접두사 목록)이 있을 때, M개의 접두사 중에서 N개의 문자열 집합에 접두사로 포함된 문자열의 개수를 찾아야 합니다. 입력으로 N과 M의 값을 받고, N개의 문자열과 M개의 문자열이 주어집니다. 이 M개의 문자열이 N개의 문자열 중 어느 하나의 접두사로 존재하는지 확인하고 그 개수를 출력합니다.

## 입출력 조건

**입력 조건:**
1. 첫 번째 줄에 문자열의 개수 N과 M이 주어집니다. (1 ≤ N ≤ 10,000, 1 ≤ M ≤ 10,000)
2. 다음 N개의 줄에는 각각 하나의 문자열이 주어집니다. 각 문자열은 알파벳 소문자로만 이루어져 있으며, 길이는 500을 넘지 않습니다.
3. 그 다음 M개의 줄에는 각각 하나의 접두사 문자열이 주어집니다. 접두사 문자열은 집합 S의 문자열과 겹칠 수 없습니다.

**출력 조건:**
- M개의 문자열 중 N개의 문자열 중 적어도 하나의 접두사로 존재하는 문자열의 개수를 출력합니다.

## 접근 방식

이 문제를 풀기 위해서는 접두사를 빠르게 검색할 수 있는 효율적인 자료구조가 필요합니다. 단순히 문자열을 순차적으로 비교하면 시간 복잡도가 너무 높아져서 제한 시간을 초과할 수 있습니다. 트라이(Trie) 자료구조를 사용하면 접두사 검색을 효율적으로 할 수 있습니다.

**접근 방식:**
1. **트라이(Trie) 자료구조 사용:** 트라이는 문자열을 저장하고 탐색하는 데 매우 효율적입니다. 문자열의 접두사를 검색하는 데 적합합니다.
2. **트라이에 N개의 문자열 삽입:** 주어진 N개의 문자열을 트라이에 삽입합니다.
3. **M개의 문자열을 트라이에서 검색:** 각 M개의 문자열을 트라이에서 접두사로 검색하여 존재 여부를 확인합니다.
4. **접두사 존재 여부 카운트:** 접두사로 존재하는 문자열의 개수를 카운트합니다.

## 풀이 과정

1. **트라이 노드 클래스 정의:**
   - `TrieNode` 클래스는 자식 노드를 저장할 딕셔너리와 단어의 끝을 표시하는 플래그를 가집니다.

2. **트라이 클래스 정의:**
   - `Trie` 클래스는 트라이 자료구조를 나타내며, 단어를 삽입하는 `insert` 메소드와 접두사가 존재하는지 확인하는 `starts_with` 메소드를 포함합니다.

3. **입력 데이터 처리:**
   - 표준 입력으로부터 데이터를 읽어와서 N과 M의 값을 구합니다.
   - N개의 문자열과 M개의 문자열을 각각 리스트에 저장합니다.

4. **트라이에 N개의 문자열 삽입:**
   - `insert` 메소드를 사용하여 N개의 문자열을 트라이에 삽입합니다.

5. **M개의 문자열을 트라이에서 접두사 검색:**
   - `starts_with` 메소드를 사용하여 M개의 문자열이 트라이에서 접두사로 존재하는지 확인합니다.

6. **접두사 존재 여부 카운트:**
   - 접두사로 존재하는 문자열의 개수를 카운트하고 출력합니다.

## 코드 구현
```python
# Trie의 각 노드를 정의하는 클래스
class TrieNode:
    def __init__(self):
        self.children = {}  # 자식 노드를 저장하는 딕셔너리
        self.is_end_of_word = False  # 단어의 끝을 표시하는 플래그

# Trie 자료구조를 정의하는 클래스
class Trie:
    def __init__(self):
        self.root = TrieNode()  # 루트 노드를 초기화

    # 단어를 트라이에 삽입하는 메소드
    def insert(self, word):
        node = self.root  # 시작은 항상 루트 노드부터
        for char in word:  # 단어의 각 문자를 순회하며
            if char not in node.children:  # 현재 노드의 자식 중에 문자가 없으면
                node.children[char] = TrieNode()  # 새로운 노드를 추가
            node = node.children[char]  # 현재 노드를 자식 노드로 갱신
        node.is_end_of_word = True  # 단어의 끝임을 표시

    # 주어진 접두사로 시작하는 단어가 있는지 확인하는 메소드
    def starts_with(self, prefix):
        node = self.root  # 시작은 항상 루트 노드부터
        for char in prefix:  # 접두사의 각 문자를 순회하며
            if char not in node.children:  # 현재 노드의 자식 중에 문자가 없으면
                return False  # 접두사가 없음을 반환
            node = node.children[char]  # 현재 노드를 자식 노드로 갱신
        return True  # 접두사가 있음을 반환

# 접두사의 개수를 계산하는 함수
def count_prefixes(N, M, N_strings, M_strings):
    trie = Trie()  # 트라이를 초기화
    for word in N_strings:  # 주어진 N개의 문자열을 순회하며
        trie.insert(word)  # 각 문자열을 트라이에 삽입
    
    prefix_count = 0  # 접두사의 개수를 세기 위한 카운터 초기화
    for prefix in M_strings:  # 주어진 M개의 접두사를 순회하며
        if trie.starts_with(prefix):  # 접두사가 트라이에 존재하면
            prefix_count += 1  # 카운터를 증가
    
    return prefix_count  # 최종 접두사의 개수를 반환

# 표준 입력으로부터 데이터를 읽어옵니다.
import sys
input = sys.stdin.read  # 표준 입력 전체를 읽어오는 함수
data = input().split()  # 읽어온 데이터를 공백 기준으로 나누어 리스트로 저장

# 첫 번째 줄에 주어진 N과 M을 읽어옵니다.
N = int(data[0])  # 첫 번째 값은 N
M = int(data[1])  # 두 번째 값은 M

# N개의 문자열을 리스트로 저장합니다.
N_strings = data[2:2 + N]  # 그 다음 N개의 값은 N개의 문자열

# M개의 문자열을 리스트로 저장합니다.
M_strings = data[2 + N:2 + N + M]  # 그 다음 M개의 값은 M개의 문자열

# 접두사 개수를 계산하는 함수를 호출합니다.
result = count_prefixes(N, M, N_strings, M_strings)  # 접두사의 개수를 계산하여 결과 저장

# 결과를 출력합니다.
print(result)  # 최종 결과를 출력

