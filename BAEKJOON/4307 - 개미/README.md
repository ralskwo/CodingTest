# 개미 문제 풀이 및 설명

https://www.acmicpc.net/problem/4307

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-4307-%ea%b0%9c%eb%af%b8-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 개미들이 길이가 일정한 막대 위를 이동하다가 막대 끝에서 떨어지는 상황을 시뮬레이션하는 문제입니다. 문제의 핵심은 개미들이 어느 방향으로 이동할지 알 수 없다는 점에서, 개미가 모든 경우의 수를 고려하여 가장 빨리 또는 가장 늦게 땅에 떨어지는 시간을 계산하는 것입니다. 개미의 이동 방향이 주어지지 않지만, 각 개미가 독립적으로 움직인다고 가정할 수 있습니다. 두 개미가 만나면 방향을 바꾸는 설정이 있지만, 이 설정은 실제로 개미의 이동 시간에는 영향을 미치지 않습니다. 따라서 각 개미가 양 끝으로 이동하는 두 가지 경우를 독립적으로 고려하면 됩니다.

## 입출력 조건

- **입력 조건**:

  - 첫 번째 줄에 테스트 케이스의 개수가 주어집니다.
  - 각 테스트 케이스의 첫 줄에는 막대의 길이 `l`과 개미의 수 `n`이 주어집니다.
  - 다음 `n`개의 줄에는 각 개미의 초기 위치가 주어집니다. 이 위치는 막대의 왼쪽 끝에서부터 떨어진 거리로 표현됩니다.
  - 모든 위치 값은 `0`부터 `l` 사이의 정수로 주어집니다.

- **출력 조건**:
  - 각 테스트 케이스에 대해, 개미들이 모두 땅에 떨어지는 시간 중 가장 빠른 시간과 가장 늦은 시간을 출력합니다.
  - 출력 형식은 "최소 시간 최대 시간"으로, 두 값을 공백으로 구분해 한 줄에 출력합니다.

## 접근 방식

이 문제를 풀기 위해서는 각 개미의 위치에서 출발하여 막대의 양 끝까지의 거리를 계산하고, 그 중 최소 및 최대 시간을 구해야 합니다. 개미가 양쪽 끝으로 이동할 수 있는 거리를 각각 계산한 후, 가장 짧은 시간이 최소 시간이 되고, 가장 긴 시간이 최대 시간이 됩니다. 이때, 개미의 이동 방향에 대한 불확실성을 고려할 필요 없이, 각 개미의 위치를 기준으로 양 끝까지의 거리를 단순히 비교하여 문제를 해결할 수 있습니다. 따라서 이 문제는 최소/최대 거리를 계산하는 간단한 수학적 접근으로 해결할 수 있습니다.

## 풀이 과정

1. **입력 파싱**:

   - 먼저 전체 테스트 케이스의 수를 읽어들입니다.
   - 각 테스트 케이스에 대해, 막대의 길이 `l`과 개미의 수 `n`을 읽어옵니다.
   - 그 후 각 개미의 초기 위치를 리스트로 저장합니다.

2. **최소 및 최대 시간 계산**:

   - 각 개미의 위치에서 왼쪽 끝(`0`)까지의 거리와 오른쪽 끝(`l`)까지의 거리를 계산합니다.
   - 각 개미에 대해 두 거리 중 더 짧은 거리는 그 개미가 최소 시간에 떨어질 가능성이 있는 시간입니다.
   - 두 거리 중 더 긴 거리는 그 개미가 최대 시간에 떨어질 가능성이 있는 시간입니다.
   - 모든 개미에 대해 최소 시간 중 가장 큰 값을 선택하고, 최대 시간 중 가장 큰 값을 선택하여 전체 최소 및 최대 시간을 구합니다.

3. **결과 출력**:
   - 각 테스트 케이스에 대해 계산된 최소 시간과 최대 시간을 출력 형식에 맞춰 출력합니다.

## 코드 구현

```python
import sys  # sys 모듈을 가져와 표준 입력 및 출력을 최적화하여 사용하기 위해 import 합니다.
input = sys.stdin.read  # sys.stdin.read를 사용하여 입력을 한 번에 처리할 수 있게 합니다.

def ant_times(l, positions):  # 막대의 길이 l과 개미들의 위치 목록 positions을 받아 최소 시간과 최대 시간을 계산하는 함수입니다.
    min_time = 0  # 개미들이 떨어질 수 있는 최소 시간을 저장할 변수입니다.
    max_time = 0  # 개미들이 떨어질 수 있는 최대 시간을 저장할 변수입니다.

    for position in positions:  # 각 개미의 위치를 하나씩 순회하며
        # 개미가 떨어질 최소 시간: 막대의 양 끝 중 가까운 쪽으로 가는 시간을 계산합니다.
        min_time = max(min_time, min(position, l - position))

        # 개미가 떨어질 최대 시간: 막대의 양 끝 중 먼 쪽으로 가는 시간을 계산합니다.
        max_time = max(max_time, max(position, l - position))

    return min_time, max_time  # 최소 시간과 최대 시간을 반환합니다.

data = input().splitlines()  # 입력을 한 번에 읽어 들이고, 줄 단위로 나누어 리스트로 만듭니다.
test_cases = int(data[0])  # 첫 번째 줄은 테스트 케이스의 수입니다.
index = 1  # 현재 처리할 데이터의 시작 인덱스를 1로 설정합니다.

results = []  # 각 테스트 케이스의 결과를 저장할 리스트를 초기화합니다.
for _ in range(test_cases):  # 테스트 케이스의 수만큼 반복합니다.
    l, n = map(int, data[index].split())  # 막대의 길이 l과 개미의 수 n을 가져옵니다.
    positions = list(map(int, data[index+1:index+1+n]))  # n개의 개미 위치를 리스트로 만듭니다.
    min_time, max_time = ant_times(l, positions)  # ant_times 함수를 호출해 최소 시간과 최대 시간을 계산합니다.
    results.append(f"{min_time} {max_time}")  # 결과를 "최소시간 최대시간" 형식으로 리스트에 추가합니다.
    index += n + 1  # 다음 테스트 케이스로 이동하기 위해 인덱스를 갱신합니다.

sys.stdout.write("\n".join(results) + "\n")  # 결과를 한 번에 출력합니다.
```
