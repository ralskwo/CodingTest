# 플로이드 2 문제 풀이 및 설명

https://www.acmicpc.net/problem/11780

## 문제 이해

이 문제는 여러 개의 도시가 있고, 도시 간의 이동을 위해 여러 개의 버스 노선이 존재하는 상황을 다루고 있습니다. 각 버스 노선에는 출발 도시, 도착 도시, 그리고 그 노선을 이용하는 데 드는 비용이 주어집니다. 주어진 모든 도시 쌍에 대해 출발 도시에서 도착 도시로 가는 최소 비용을 구하는 것이 목표입니다. 이 과정에서 중요한 것은 단순히 두 도시 간의 직접적인 이동만 고려하는 것이 아니라, 중간에 다른 도시를 경유했을 때 더 저렴한 경로가 있는지도 고려해야 한다는 점입니다. 또한, 최단 경로가 여러 개일 수 있으며, 해당 경로를 구성하는 도시들의 순서도 구해야 합니다. 이 문제는 모든 도시 쌍에 대해 최단 경로를 구해야 하므로, 효율적인 알고리즘을 사용해야 합니다.

## 입출력 조건

### 입력 조건:

1. 첫 번째 줄에 도시의 개수 \( n \)이 주어집니다. (\( 1 <= n <= 100 \))
2. 두 번째 줄에는 버스의 개수 \( m \)이 주어집니다. (\( 1 <= m <= 100,000 \))
3. 다음 \( m \)개의 줄에 걸쳐 각 버스의 정보가 주어집니다. 각 줄에는 세 개의 정수 \( a \), \( b \), \( c \)가 주어지며, 이는 버스가 도시 \( a \)에서 출발하여 도시 \( b \)에 도착하며, 비용이 \( c \)임을 의미합니다. (\( 1 <= a, b <= n \), \( 1 <= c <= 100,000 \))

### 출력 조건:

1. \( n \)개의 줄에 걸쳐 각 도시 \( i \)에서 도시 \( j \)로 가는 최소 비용을 출력합니다. 만약 갈 수 없는 경우에는 0을 출력합니다.
2. 그 다음에 \( n \* n \)개의 줄에 걸쳐 도시 \( i \)에서 도시 \( j \)로 가는 최단 경로에 포함된 도시의 수와 경로를 순서대로 출력합니다. 만약 갈 수 없는 경우에는 0을 출력합니다.

## 접근 방식

이 문제는 그래프 이론에서 '모든 쌍 최단 경로(All-Pairs Shortest Paths)' 문제에 해당하며, 이를 해결하기 위해 플로이드-워셜 알고리즘을 사용해야 합니다. 플로이드-워셜 알고리즘은 모든 정점 쌍 간의 최단 경로를 구하는 알고리즘으로, 시간 복잡도는 \(O(n^3)\)입니다. 이 알고리즘은 각 정점을 중간 정점으로 사용하여 경로를 점진적으로 최적화하는 방식으로 동작합니다. 따라서, 도시의 수가 최대 100일 때, 이 알고리즘은 적절한 성능을 발휘합니다. 또한, 플로이드-워셜 알고리즘은 경로 자체를 복원하는 데 필요한 정보를 추적할 수 있으므로, 이 문제에서 요구하는 경로 출력도 가능합니다.

## 풀이 과정

1. **초기화**:

   - 우선 각 도시 간의 최소 비용을 저장할 2차원 배열 `dist`를 무한대로 초기화합니다. 또한, 각 도시 간의 최단 경로를 추적할 2차원 배열 `next`도 함께 초기화합니다. `dist[i][i]`는 0으로 설정하여 각 도시에서 자기 자신으로 가는 비용이 0임을 명시합니다.

2. **초기 비용 설정**:

   - 주어진 버스 정보를 기반으로, 출발 도시와 도착 도시 간의 직접적인 비용을 `dist` 배열에 업데이트합니다. 이때, 이미 등록된 비용보다 더 저렴한 버스가 존재한다면 해당 비용으로 업데이트합니다. 동시에, `next` 배열도 초기화하여, 직접 연결된 도시들 간의 다음 도시 정보를 기록합니다.

3. **플로이드-워셜 알고리즘 적용**:

   - 세 개의 중첩 루프를 통해 모든 도시 쌍에 대해 경유지를 고려한 최단 경로를 계산합니다. 도시 \( k \)를 중간 경유지로 사용하여 도시 \( i \)에서 도시 \( j \)로 가는 비용이 기존보다 저렴할 경우, 해당 비용을 갱신합니다. 이때, `next` 배열도 업데이트하여 경로를 추적합니다.

4. **최단 경로 출력**:

   - 계산된 최단 경로 비용을 `dist` 배열에서 추출하여 출력합니다. 이때, 경로가 존재하지 않는 경우 0을 출력합니다.

5. **경로 재구성 및 출력**:
   - `next` 배열을 사용하여 각 도시 쌍 간의 실제 경로를 재구성합니다. 경로를 재구성할 때, 출발 도시에서 도착 도시까지의 중간 경유지를 차례대로 추적하여 경로를 구성하고, 그 길이와 경로를 출력합니다. 경로가 존재하지 않는 경우에는 0을 출력합니다.

이러한 과정으로 문제를 해결할 수 있으며, 이는 모든 도시 쌍에 대해 최적의 이동 경로를 계산하고, 그 경로를 명확히 제시하는 것을 목표로 합니다.

## 코드 구현

```python
import sys
input = sys.stdin.read
INF = float('inf')

# 플로이드-워셜 알고리즘을 구현하는 함수
def floyd_warshall(n, bus_info):
    # 초기 거리를 무한대로 설정한 n x n 크기의 2차원 배열 생성
    dist = [[INF] * n for _ in range(n)]
    # 경로를 추적하기 위한 n x n 크기의 2차원 배열 생성
    next_city = [[-1] * n for _ in range(n)]

    # 모든 도시에서 자기 자신으로 가는 비용은 0으로 설정
    for i in range(n):
        dist[i][i] = 0

    # 주어진 버스 정보로 dist와 next_city 초기화
    for a, b, c in bus_info:
        # 시작 도시 a에서 도착 도시 b로 가는 비용이 더 적으면 업데이트
        if c < dist[a-1][b-1]:
            dist[a-1][b-1] = c
            next_city[a-1][b-1] = b-1

    # 플로이드-워셜 알고리즘 수행: 모든 도시 쌍 간의 최단 경로 계산
    for k in range(n):
        for i in range(n):
            for j in range(n):
                # i에서 j로 바로 가는 경로보다 i를 거쳐 k를 통해 j로 가는 경로가 더 짧으면 갱신
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    # 경로를 갱신할 때 next_city 배열도 함께 갱신
                    next_city[i][j] = next_city[i][k]

    # 최종적으로 모든 도시 쌍 간의 최단 경로 비용(dist)과 경로(next_city)를 반환
    return dist, next_city

# 경로를 재구성하는 함수
def construct_path(next_city, start, end):
    # start에서 end로 가는 경로가 없으면 빈 리스트 반환
    if next_city[start][end] == -1:
        return []
    # 경로를 저장할 리스트 생성
    path = [start]
    # 다음 도시가 끝 도시와 같아질 때까지 경로를 따라감
    while start != end:
        start = next_city[start][end]
        path.append(start)
    # 완성된 경로 리스트 반환
    return path

# 메인 함수
def main():
    # 입력 데이터를 모두 읽어옴
    data = input().strip().split('\n')
    # 첫 번째 줄에서 도시의 개수 n을 읽어옴
    n = int(data[0])
    # 두 번째 줄에서 버스의 개수 m을 읽어옴
    m = int(data[1])
    # 버스 정보를 저장할 리스트 생성
    bus_info = []

    # 세 번째 줄부터 m개의 버스 정보를 읽어옴
    for i in range(2, 2 + m):
        a, b, c = map(int, data[i].split())
        bus_info.append((a, b, c))

    # 플로이드-워셜 알고리즘을 통해 최단 경로와 경로를 계산
    dist, next_city = floyd_warshall(n, bus_info)

    # 모든 도시 쌍 간의 최단 경로 비용을 출력
    for i in range(n):
        for j in range(n):
            if dist[i][j] == INF:
                print(0, end=" ")  # 경로가 없는 경우 0 출력
            else:
                print(dist[i][j], end=" ")  # 최단 경로 비용 출력
        print()

    # 모든 도시 쌍 간의 최단 경로를 출력
    for i in range(n):
        for j in range(n):
            if dist[i][j] == INF:
                print(0)  # 경로가 없는 경우 0 출력
            else:
                path = construct_path(next_city, i, j)
                print(len(path), ' '.join(map(lambda x: str(x + 1), path)))  # 경로의 도시 개수와 경로 출력

# 프로그램의 시작점
if __name__ == "__main__":
    main()
```
