# 숨바꼭질 문제 풀이 및 설명 

https://www.acmicpc.net/submit/1697

## 문제 이해

이 문제는 수빈이와 그의 동생이 숨바꼭질을 하는 상황을 다루고 있습니다. 수빈이는 점 \(N\)에 있고, 그의 동생은 점 \(K\)에 있습니다. 수빈이는 매 초마다 위치를 바꿀 수 있으며, 한 번에 할 수 있는 이동은 다음 세 가지 중 하나입니다:
1. 현재 위치에서 한 칸 앞으로 이동 (\(X + 1\))
2. 현재 위치에서 한 칸 뒤로 이동 (\(X - 1\))
3. 현재 위치에서 순간이동하여 현재 위치의 두 배로 이동 (\(2 * X\))

수빈이가 동생을 찾기 위해 가장 빠른 시간을 구하는 것이 이 문제의 목표입니다.

## 입출력 조건

**입력 조건:**
- 첫 번째 줄에 수빈이의 위치 \(N\)과 동생의 위치 \(K\)가 공백을 기준으로 주어집니다.
- \(N\)과 \(K\)는 모두 0 이상 100,000 이하의 정수입니다.

**출력 조건:**
- 수빈이가 동생을 찾는 가장 빠른 시간을 출력합니다.

# 접근 방식

이 문제를 해결하기 위해서는 너비 우선 탐색(BFS, Breadth-First Search)을 사용하는 것이 적합합니다. BFS는 최단 경로를 찾는 데 유용한 알고리즘으로, 그래프의 모든 노드를 동일한 깊이로 탐색하기 때문에 최단 경로를 보장합니다.

구체적인 접근 방식은 다음과 같습니다:
1. 수빈이의 현재 위치 \(N\)을 시작점으로 하고, 이동할 수 있는 모든 위치를 큐에 넣어 탐색합니다.
2. 각 위치에서 이동할 수 있는 세 가지 경우(앞으로, 뒤로, 순간이동)를 모두 큐에 추가합니다.
3. 동생의 위치 \(K\)에 도달하면 그때의 시간을 반환합니다.

## 풀이 과정

1. **데이터 구조 초기화**:
   - 최대 위치 값을 기준으로 방문 여부를 기록할 `visited` 리스트를 생성합니다.
   - `deque`를 사용하여 BFS를 위한 큐를 초기화합니다. 큐에는 현재 위치와 현재 시간(초)을 함께 저장합니다.

2. **BFS 탐색 시작**:
   - 큐에서 현재 위치와 현재 시간을 꺼내서 확인합니다.
   - 만약 현재 위치가 동생의 위치 \(K\)라면, 현재 시간을 반환합니다.

3. **이동 가능한 위치 확인**:
   - 현재 위치에서 한 칸 앞으로 이동 (\(X + 1\)), 한 칸 뒤로 이동 (\(X - 1\)), 순간이동 (\(2 * X\)) 세 가지 경우를 확인합니다.
   - 이동한 위치가 범위(0 이상 100,000 이하) 내에 있고, 아직 방문하지 않은 위치라면 큐에 추가하고 방문했다고 표시합니다.

4. **반복**:
   - 큐가 빌 때까지 위 과정을 반복합니다.

## 코드 구현
```python
from collections import deque

def bfs(N, K):
    # 문제에서 주어진 위치의 최대값을 설정합니다.
    max_limit = 100000
    
    # 방문한 위치를 추적하기 위한 리스트를 생성합니다. 인덱스가 위치를 나타내고 값이 방문 여부를 나타냅니다.
    visited = [False] * (max_limit + 1)
    
    # deque를 초기화합니다. 시작 위치 N과 현재 시간을 튜플로 넣어줍니다.
    queue = deque([(N, 0)])
    
    # 큐가 비어있지 않은 동안 반복합니다.
    while queue:
        
        # 큐의 가장 앞에 있는 요소를 꺼내 현재 위치와 시간을 얻습니다.
        position, time = queue.popleft()
        
        # 현재 위치가 동생의 위치와 같으면
        if position == K:
            # 현재 시간을 반환합니다. (최단 시간)
            return time
        
        # 현재 위치에서 이동할 수 있는 세 가지 경우를 모두 확인합니다.
        for next_pos in (position - 1, position + 1, position * 2):
            # 다음 위치가 범위 내에 있고 방문하지 않은 위치라면
            if 0 <= next_pos <= max_limit and not visited[next_pos]:
                # 해당 위치를 방문한 것으로 표시합니다.
                visited[next_pos] = True
                # 다음 위치와 시간을 큐에 추가합니다.
                queue.append((next_pos, time + 1))

# 표준 입력으로부터 수빈이의 위치 N과 동생의 위치 K를 읽어옵니다.
N, K = map(int, input().split())

# BFS 함수의 결과를 출력합니다.
print(bfs(N, K))
