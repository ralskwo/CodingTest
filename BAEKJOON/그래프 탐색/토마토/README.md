# 토마토 문제 풀이 및 설명

https://www.acmicpc.net/problem/7576

## 문제 이해

이 문제는 철수의 토마토 농장에서 저장된 토마토들이 익는 과정을 시뮬레이션하여, 모든 토마토가 익는 데 걸리는 최소 일수를 구하는 문제입니다. 문제에서 주어지는 것은 토마토가 보관된 창고의 크기와 각 칸에 저장된 토마토의 상태입니다. 토마토는 익은 상태, 익지 않은 상태, 혹은 토마토가 없는 상태일 수 있습니다. 익은 토마토는 하루가 지나면 인접한 네 방향(상, 하, 좌, 우)에 있는 익지 않은 토마토들을 익게 합니다. 목표는 모든 토마토가 익는 데 걸리는 최소 일수를 구하는 것입니다. 만약 처음부터 모든 토마토가 익어있다면 0을 출력하며, 일부 토마토가 끝까지 익지 못하는 경우에는 -1을 출력해야 합니다.

## 입출력 조건

- **입력**:

  - 첫 번째 줄에 창고의 크기를 나타내는 두 정수 M과 N이 주어집니다. 여기서 M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 의미합니다. (2 ≤ M, N ≤ 1,000)
  - 두 번째 줄부터 N개의 줄에 걸쳐 각 상자에 저장된 토마토들의 정보가 주어집니다. 각 줄에는 M개의 정수가 공백을 두고 주어지며, 이 정수는 상자의 상태를 나타냅니다.
    - 1은 익은 토마토를 의미합니다.
    - 0은 익지 않은 토마토를 의미합니다.
    - -1은 토마토가 들어있지 않은 칸을 의미합니다.
  - 토마토가 하나 이상 있는 경우만 입력으로 주어집니다.

- **출력**:
  - 모든 토마토가 익을 때까지의 최소 일수를 출력합니다.
  - 만약 저장될 때부터 모든 토마토가 익어있는 상태라면 0을 출력합니다.
  - 토마토가 모두 익지 못하는 상황이면 -1을 출력합니다.

## 접근 방식

이 문제는 BFS(너비 우선 탐색)를 사용하여 해결하는 것이 가장 적합합니다. BFS는 시작점에서 가까운 곳부터 차례대로 탐색을 진행하기 때문에, 여러 개의 시작점에서 동시에 퍼져나가는 상황을 시뮬레이션할 수 있습니다. 이 문제에서는 익은 토마토들을 시작점으로 설정하고, 이들이 하루하루 지나면서 주변의 익지 않은 토마토들을 익히는 과정을 시뮬레이션합니다. BFS를 통해 각 익은 토마토에서 인접한 칸의 익지 않은 토마토로 퍼져나가며, 모든 토마토가 익는 데 걸리는 일수를 계산합니다.

## 풀이 과정

1. **초기 상태 설정**: 먼저 주어진 창고에서 익은 토마토(값이 1인 위치)를 모두 찾아 큐에 추가합니다. 각 토마토는 `(행, 열, 경과일)` 형태로 저장됩니다. 이때, 초기의 경과일은 0으로 설정됩니다. 큐를 사용하는 이유는 BFS 탐색을 통해 익은 토마토가 익지 않은 토마토로 퍼져나가는 과정을 시뮬레이션하기 위함입니다.

2. **BFS 탐색 시작**: 큐에 있는 익은 토마토들을 하나씩 꺼내면서 네 방향(상, 하, 좌, 우)으로 인접한 칸을 탐색합니다. 만약 인접한 칸에 익지 않은 토마토(값이 0)가 있다면, 그 토마토를 익은 상태(값이 1)로 바꾸고 큐에 새롭게 추가합니다. 이때 새로 추가되는 토마토의 경과일은 현재 일수보다 하루 증가된 값입니다. 이러한 과정을 반복하여 모든 토마토가 익을 때까지 탐색을 계속합니다.

3. **결과 확인**: BFS 탐색이 완료된 후, 모든 토마토가 익었는지 확인합니다. 만약 탐색이 종료된 후에도 창고 안에 익지 않은 토마토가 남아있다면, 이는 일부 토마토가 끝까지 익지 못한다는 의미이므로 -1을 출력합니다. 반면, 모든 토마토가 익었다면, 마지막으로 계산된 최대 경과일을 출력합니다. 만약 처음부터 모든 토마토가 익어있는 상태라면, 탐색 과정 없이 바로 0을 출력합니다.

이러한 접근 방식을 통해 주어진 조건 하에서 문제를 효과적으로 해결할 수 있습니다. BFS를 사용하여 모든 토마토가 익는 과정을 시뮬레이션하고, 최소 일수를 정확하게 계산할 수 있습니다.

## 코드 구현

```python
from collections import deque  # deque를 사용하기 위해 collections 모듈에서 deque를 임포트

def bfs_tomato_farm(M, N, farm):
    queue = deque()  # BFS를 위한 큐를 생성
    days = 0  # 걸린 일수를 저장할 변수 초기화

    # 농장의 모든 위치를 순회하면서 익은 토마토(1)의 위치를 큐에 추가
    for i in range(N):
        for j in range(M):
            if farm[i][j] == 1:
                queue.append((i, j, 0))  # (행, 열, 경과일) 형태로 큐에 저장

    # BFS에서 사용할 네 방향(상, 하, 좌, 우) 이동을 위한 좌표 설정
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    # BFS 탐색 시작
    while queue:
        x, y, day = queue.popleft()  # 큐에서 현재 위치와 경과일을 꺼냄
        days = max(days, day)  # 현재까지의 최대 경과일을 갱신

        # 네 방향으로 이동하면서 익지 않은 토마토를 익히기
        for dx, dy in directions:
            nx, ny = x + dx, y + dy  # 다음에 이동할 위치 계산

            # 이동한 위치가 농장 내에 있고, 익지 않은 토마토가 있는 경우
            if 0 <= nx < N and 0 <= ny < M and farm[nx][ny] == 0:
                farm[nx][ny] = 1  # 해당 위치의 토마토를 익힘
                queue.append((nx, ny, day + 1))  # 큐에 새롭게 익은 토마토의 위치와 경과일을 추가

    # BFS가 끝난 후, 농장에 익지 않은 토마토가 남아있는지 확인
    for row in farm:
        if 0 in row:  # 익지 않은 토마토(0)가 존재한다면
            return -1  # 모든 토마토가 익지 않는 경우이므로 -1 반환

    return days  # 모든 토마토가 익은 최소 일수를 반환

# 입력값 처리
M, N = map(int, input().split())  # 상자의 가로 크기 M, 세로 크기 N을 입력받음
farm = [list(map(int, input().split())) for _ in range(N)]  # 농장 상태를 2차원 리스트로 입력받음

# BFS를 이용한 최소 일수 계산 및 출력
result = bfs_tomato_farm(M, N, farm)

print(result)  # 결과를 출력
```
