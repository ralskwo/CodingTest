# 아기 상어 문제 풀이

https://www.acmicpc.net/problem/16236

## 문제 이해

이 문제는 아기 상어가 물고기를 먹으며 성장하는 과정을 시뮬레이션하는 것입니다. 문제를 해결하기 위해 다음과 같은 관점을 가지고 접근해야 합니다:

1. **상어의 초기 상태**:
   - 아기 상어의 초기 크기는 2입니다.
   - 초기 위치는 입력에서 9로 주어지며, 상어는 이 위치에서 시작합니다.

2. **물고기 탐색 및 이동**:
   - 상어는 자기보다 작은 크기의 물고기만 먹을 수 있습니다.
   - 상어는 가장 가까운 물고기를 우선적으로 먹습니다. 여기서 "가까운"의 정의는 이동 거리가 짧은 순입니다.
   - 만약 가장 가까운 물고기가 여러 마리라면, 우선적으로 가장 위쪽에 있는 물고기를 먹고, 그런 물고기가 여러 마리라면 가장 왼쪽에 있는 물고기를 먹습니다.

3. **상어의 성장**:
   - 상어가 자신의 크기와 같은 수의 물고기를 먹을 때마다 크기가 1씩 증가합니다.
   - 크기가 커지면 더 큰 물고기를 먹을 수 있게 됩니다.

4. **탐색 알고리즘**:
   - 가장 가까운 물고기를 찾기 위해 너비 우선 탐색(BFS)을 사용합니다.
   - BFS는 최단 경로를 찾는 데 적합하며, 이는 상어가 물고기를 먹기 위해 최단 시간 내에 도달할 수 있는 경로를 찾는 데 유리합니다.

5. **우선순위 큐**:
   - BFS 탐색 중에 먹을 수 있는 물고기를 우선순위 큐에 넣어 거리, 행, 열 순으로 정렬합니다.
   - 이는 가장 가까운 물고기를 선택할 때, 거리 -> 행 -> 열 순으로 우선순위를 적용하기 위함입니다.

## 접근 방식

1. **BFS 탐색으로 물고기 찾기**:
   - 상어의 현재 위치에서 시작하여 BFS를 수행하여 먹을 수 있는 물고기를 탐색합니다.
   - BFS는 상하좌우 네 방향으로 이동하며, 이동 가능한 칸과 물고기의 크기를 고려합니다.

2. **물고기 선택**:
   - BFS 결과에서 먹을 수 있는 물고기들을 거리, 행, 열 순으로 정렬하여 가장 가까운 물고기를 선택합니다.
   - 선택된 물고기를 먹고, 상어의 위치를 업데이트하며 경과 시간을 누적합니다.

3. **상어의 성장 처리**:
   - 먹은 물고기의 수가 현재 상어의 크기와 같아지면, 상어의 크기를 1 증가시킵니다.
   - 상어의 크기와 먹은 물고기의 수를 업데이트하여 시뮬레이션을 계속 진행합니다.

4. **시뮬레이션 종료 조건**:
   - 더 이상 먹을 수 있는 물고기가 없을 때 시뮬레이션을 종료하고 총 경과 시간을 반환합니다.

## 풀이 과정

1. **입력 받기**

   - 첫째 줄에서 공간의 크기 \( N \)을 입력받습니다.
   - 다음 \( N \)개의 줄에서 공간의 상태를 입력받아 2차원 리스트로 저장합니다.
   - 아기 상어의 초기 위치를 찾고 이를 기록한 후, 해당 위치를 빈 칸(0)으로 설정합니다.

2. **BFS 함수 정의**

   - BFS를 통해 아기 상어가 현재 위치에서 먹을 수 있는 물고기를 찾습니다.
   - BFS 탐색 중, 방문한 위치를 기록하여 재방문을 방지합니다.
   - 먹을 수 있는 물고기가 발견되면, 이를 리스트에 저장합니다.
   - 모든 탐색이 끝난 후, 먹을 수 있는 물고기 리스트를 거리, 행, 열 순으로 정렬하고 가장 가까운 물고기를 반환합니다.

3. **메인 함수 정의**

   - 초기 상어의 크기와 먹은 물고기 수, 경과 시간을 설정합니다.
   - BFS 탐색을 반복하여 먹을 수 있는 물고기를 찾고, 이를 먹은 후 상어의 상태를 업데이트합니다.
   - 더 이상 먹을 수 있는 물고기가 없을 때까지 반복하며, 총 경과 시간을 반환합니다.

4. **결과 출력**
    - 메인 함수를 호출하여 결과를 출력합니다.

## 코드 구현
```python
from collections import deque

def bfs(start_x, start_y, size, grid):
    N = len(grid)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 네 방향(상, 하, 좌, 우)을 나타내는 리스트
    queue = deque([(start_x, start_y, 0)])  # BFS를 위한 큐 초기화, 초기 위치와 거리를 큐에 추가
    visited = set()  # 방문한 위치를 저장하기 위한 집합
    visited.add((start_x, start_y))
    fish = []  # 먹을 수 있는 물고기 리스트 초기화

    while queue:
        x, y, dist = queue.popleft()
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited:
                if grid[nx][ny] <= size:  # 상어가 지나갈 수 있거나 먹을 수 있는 경우
                    visited.add((nx, ny))
                    queue.append((nx, ny, dist + 1))
                    if 0 < grid[nx][ny] < size:  # 상어가 먹을 수 있는 물고기
                        fish.append((dist + 1, nx, ny))
    
    if not fish:  # 먹을 수 있는 물고기가 없으면 None 반환
        return None
    fish.sort()  # 거리, 행, 열 순으로 정렬하여 가장 가까운 물고기 반환
    return fish[0]  # (거리, x, y)

def baby_shark(grid):
    N = len(grid)
    for i in range(N):
        for j in range(N):
            if grid[i][j] == 9:
                shark_x, shark_y = i, j
                grid[i][j] = 0  # 상어의 초기 위치를 찾고 grid에서 제거

    size = 2  # 상어의 초기 크기 설정
    eaten = 0  # 먹은 물고기의 수 초기화
    time = 0  # 경과 시간 초기화

    while True:
        result = bfs(shark_x, shark_y, size, grid)  # BFS를 사용하여 먹을 수 있는 물고기 탐색
        if not result:  # 더 이상 먹을 수 있는 물고기가 없으면 종료
            break
        dist, shark_x, shark_y = result  # 가장 가까운 물고기의 거리와 위치 업데이트
        time += dist  # 물고기를 먹는 데 걸린 시간 누적
        grid[shark_x][shark_y] = 0  # 물고기를 먹은 위치를 빈 칸으로 설정
        eaten += 1  # 먹은 물고기 수 증가
        if eaten == size:  # 상어가 현재 크기만큼 물고기를 먹으면 크기 증가
            size += 1
            eaten = 0

    return time  # 총 경과 시간 반환

# 입력 받기
N = int(input().strip())
grid = [list(map(int, input().split())) for _ in range(N)]

# 결과 출력
print(baby_shark(grid))
