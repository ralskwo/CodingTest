# 텀 프로젝트 문제 풀이 및 설명

https://www.acmicpc.net/problem/9466

## 문제 이해
주어진 문제는 모든 학생이 선택을 마친 후 팀에 속하지 않은 학생이 몇 명인지 계산하는 것입니다. 각 학생은 함께 일하고 싶은 다른 학생을 선택하고, 선택의 사이클이 형성되면 팀이 구성됩니다. 우리의 과제는 이러한 팀에 속하지 않은 학생의 수를 세는 것입니다.

## 입출력 조건
- **입력:**
  - 첫 번째 줄에는 테스트 케이스의 수 \( T \) (1 ≤ \( T \) ≤ 100)가 주어집니다.
  - 각 테스트 케이스에 대해:
    - 첫 번째 줄에는 학생의 수 \( n \) (2 ≤ \( n \) ≤ 100,000)이 주어집니다.
    - 두 번째 줄에는 \( n \)개의 정수가 주어지며, \( i \)번째 정수는 학생 \( i \)가 선택한 학생을 나타냅니다.

- **출력:**
  - 각 테스트 케이스마다 팀에 속하지 않은 학생의 수를 출력합니다.

## 접근 방법
이 문제를 해결하기 위해 깊이 우선 탐색(DFS)을 사용하여 학생 선택으로 형성된 그래프에서 사이클을 탐지할 수 있습니다. 각 학생을 그래프의 노드로 나타내고, 학생 \( i \)가 학생 \( j \)를 선택하면 노드 \( i \)에서 노드 \( j \)로의 간선이 존재합니다. 모든 사이클을 찾아 팀을 형성하는 학생들을 결정할 수 있습니다. 어떤 사이클에도 포함되지 않은 학생들이 팀에 속하지 않은 학생들입니다.

## 풀이 과정
1. **데이터 구조 초기화:**
   - 각 테스트 케이스에 대해, DFS 동안 학생이 방문되었는지를 추적하기 위해 `visited` 배열을 초기화합니다.
   - 학생이 팀에 속해 있는지를 추적하기 위해 `team` 배열을 초기화합니다.
   - 형성된 팀의 수를 세기 위해 `team_count` 변수를 초기화합니다.

2. **DFS를 이용한 사이클 탐지:**
   - 각 학생에 대해, 해당 학생이 방문되지 않은 경우 스택을 사용하여 그래프를 탐색하는 DFS를 수행합니다.
   - DFS 동안 스택을 사용하여 현재 경로를 추적합니다. 각 학생을 고유한 식별자로 방문된 것으로 표시하여 사이클을 탐지합니다.
   - 사이클이 탐지되면(즉, 동일한 경로 내에서 다시 방문된 노드를 만난 경우), 사이클에 속한 모든 학생을 팀에 속한 것으로 표시합니다.

3. **팀 정보 업데이트:**
   - 한 학생에 대해 DFS를 완료한 후, 탐지된 사이클의 모든 학생이 팀에 속한 것으로 표시되도록 합니다.
   - DFS 동안 방문되었지만 탐지된 사이클에 속하지 않은 학생은 팀에 속하지 않은 것으로 표시합니다.

4. **결과 계산 및 출력:**
   - 각 테스트 케이스에 대해, 총 학생 수에서 팀에 속한 학생 수를 빼서 팀에 속하지 않은 학생 수를 계산합니다.
   - 각 테스트 케이스에 대한 결과를 출력합니다.

## 코드 구현
```python
import sys

def find_teams(n, choices):
    visited = [0] * (n + 1)  # 방문 상태를 저장하는 배열 초기화
    team = [0] * (n + 1)  # 팀에 속한 상태를 저장하는 배열 초기화
    team_count = 0  # 팀의 개수 초기화

    for student in range(1, n + 1):  # 모든 학생에 대해 탐색 시작
        if not visited[student]:  # 해당 학생이 방문되지 않은 경우
            stack = []  # 스택 초기화
            current = student  # 현재 학생을 현재 위치로 설정

            while not visited[current]:  # 현재 학생이 방문되지 않은 경우 반복
                visited[current] = student  # 현재 학생을 방문 상태로 설정
                stack.append(current)  # 현재 학생을 스택에 추가
                current = choices[current]  # 다음 학생으로 이동

            if visited[current] == student:  # 싸이클이 형성된 경우
                while stack and stack[-1] != current:  # 스택에서 싸이클의 시작점까지 팝
                    team[stack.pop()] = 1  # 싸이클에 속한 학생을 팀에 속한 것으로 설정
                team[stack.pop()] = 1  # 싸이클의 시작점을 팀에 속한 것으로 설정
                team_count += 1  # 팀의 개수 증가

            while stack:  # 남아있는 스택 요소 처리
                team[stack.pop()] = 0  # 싸이클에 속하지 않은 학생을 팀에 속하지 않은 것으로 설정

    return n - sum(team)  # 팀에 속하지 않은 학생의 수 반환

def main():
    input = sys.stdin.read  # 표준 입력을 읽어옴
    data = input().split()  # 입력 데이터를 공백으로 분리

    index = 0  # 데이터 인덱스 초기화
    T = int(data[index])  # 테스트 케이스의 수
    index += 1
    results = []  # 결과를 저장할 리스트 초기화

    for _ in range(T):  # 각 테스트 케이스에 대해
        n = int(data[index])  # 학생의 수
        index += 1
        choices = [0] + list(map(int, data[index:index + n]))  # 학생들이 선택한 학생 배열
        index += n
        result = find_teams(n, choices)  # 팀에 속하지 않은 학생의 수 계산
        results.append(result)  # 결과 리스트에 추가

    for res in results:  # 각 테스트 케이스의 결과 출력
        print(res)

if __name__ == "__main__":  # 메인 함수 실행
    main()
