# 체스판 다시 칠하기 2 문제 풀이 및 설명

<https://www.acmicpc.net/problem/25682>

<https://mayquartet.com/python-백준-25682/>

## 문제 이해

주어진 보드는 가로와 세로가 각각 M, N의 크기로 이루어져 있으며, 각 칸은 흰색 또는 검은색으로 칠해져 있습니다. 이 보드에서 특정 영역을 골라 K×K 크기로 잘라낸 뒤, 그 부분을 체스판 형태로 만들기 위해 필요한 최소한의 색칠 횟수를 구해야 합니다. 체스판은 인접한 칸끼리 서로 다른 색을 가져야 하므로, (행 인덱스와 열 인덱스 합이 짝수인 칸은 흰색, 홀수인 칸은 검은색)인 패턴과 그 반대 패턴 두 가지가 가능하며, 이 문제에서는 보드의 다양한 위치에서 K×K 크기로 잘라냈을 때 다시 칠해야 하는 최소 칸 수를 계산하는 것이 목표입니다.

## 입출력 조건

-   입력으로는 먼저 세 정수 N, M, K가 주어집니다.
-   이후 N개의 줄에 걸쳐 보드의 상태가 주어지며, 각 줄은 M개의 문자로 구성됩니다.
-   각 문자는 W 또는 B 중 하나이며, W는 흰색, B는 검은색을 의미합니다.
-   N과 M은 최대 2000까지 가능하며, K는 그보다 작거나 같은 값으로 주어집니다.
-   출력은 K×K 크기의 부분 보드를 체스판으로 만들기 위해 다시 칠해야 하는 칸의 최소 개수를 한 줄에 하나의 정수로 작성합니다.

## 접근 방식

-   체스판이 될 수 있는 두 가지 패턴을 고려합니다. 하나는 맨 왼쪽 위 칸이 흰색인 경우이고, 다른 하나는 맨 왼쪽 위 칸이 검은색인 경우입니다.
-   두 패턴 각각에 대해 보드의 각 칸이 기대되는 색과 동일한지 비교하여 불일치 여부를 기록합니다.
-   보드의 크기가 최대 2000×2000이므로 모든 K×K 구역을 단순 반복으로 불일치 개수를 세면 시간 복잡도가 매우 커집니다.
-   2차원 누적합을 활용하여 각 K×K 구역의 불일치 개수를 빠르게 O(1)에 계산할 수 있도록 설계합니다.
-   두 패턴에 대해 누적합 테이블을 구성한 후, 모든 K×K 영역을 검사하면서 두 패턴 중 더 적은 수정 횟수를 선택하여 최종 최소값을 구합니다.

## 풀이 과정

-   보드의 각 칸에 대해 행 인덱스와 열 인덱스의 합이 짝수일 때와 홀수일 때 각각 기대되는 색을 결정합니다.
-   두 가지 체스판 패턴에 대해 실제 칸의 색이 기대되는 색과 다르면 1, 같으면 0을 기록하는 불일치 배열을 각각 생성합니다.
-   각 불일치 배열에 대해 2차원 누적합을 계산하여, 특정 영역 내의 불일치 개수를 빠르게 구할 수 있는 자료구조를 만듭니다.
-   가능한 모든 K×K 구역의 시작 위치를 순회하면서, 누적합 테이블을 이용해 해당 영역 내의 불일치 개수를 O(1)로 계산합니다.
-   두 패턴에서 계산된 불일치 개수 중 더 작은 값을 해당 구역의 최소 수정 횟수로 고려하고, 전체 영역 중 최소값을 최종 답으로 결정합니다.

## 코드 구현

```python
import sys

def main():
    input = sys.stdin.readline
    N, M, K = map(int, input().split())
    board = [input().strip() for _ in range(N)]

    p1 = [[0] * (M + 1) for _ in range(N + 1)]
    p2 = [[0] * (M + 1) for _ in range(N + 1)]

    for i in range(N):
        row = board[i]
        for j in range(M):
            if ((i + j) & 1) == 0:
                expected1 = 'W'
                expected2 = 'B'
            else:
                expected1 = 'B'
                expected2 = 'W'

            v1 = 1 if row[j] != expected1 else 0
            v2 = 1 if row[j] != expected2 else 0

            p1[i+1][j+1] = v1 + p1[i][j+1] + p1[i+1][j] - p1[i][j]
            p2[i+1][j+1] = v2 + p2[i][j+1] + p2[i+1][j] - p2[i][j]

    ans = float('inf')

    for i in range(0, N - K + 1):
        for j in range(0, M - K + 1):
            mismatches1 = p1[i+K][j+K] - p1[i][j+K] - p1[i+K][j] + p1[i][j]
            mismatches2 = p2[i+K][j+K] - p2[i][j+K] - p2[i+K][j] + p2[i][j]
            if mismatches1 < ans:
                ans = mismatches1
            if mismatches2 < ans:
                ans = mismatches2

    sys.stdout.write(str(ans))

if __name__ == '__main__':
    main()

```
