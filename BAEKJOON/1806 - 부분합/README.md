# 부분합 문제 풀이 및 설명

https://www.acmicpc.net/problem/1806

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-1806-%eb%b6%80%eb%b6%84%ed%95%a9-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 주어진 수열에서 연속된 숫자들의 부분합 중, 그 합이 주어진 값 `S` 이상이 되는 가장 짧은 부분 수열의 길이를 구하는 문제입니다. 수열의 각 원소는 자연수로 이루어져 있으며, 길이가 `N`입니다. 여기서 주어진 조건을 만족하는 최소 길이의 부분 수열을 찾아내야 합니다. 만약 그런 수열을 만들 수 없는 경우에는 `0`을 출력해야 합니다. 중요한 포인트는 수열에서 연속된 숫자들로만 부분합을 구할 수 있다는 점입니다.

## 입출력 조건

1. **입력**

   - 첫 번째 줄에는 두 개의 정수 `N`과 `S`가 공백으로 구분되어 주어집니다.
     - `N`은 수열의 길이로, 10 이상 100,000 미만의 값을 가집니다.
     - `S`는 목표로 하는 부분합의 최소 값으로, 0보다 크고 100,000,000 이하의 값을 가집니다.
   - 두 번째 줄에는 `N`개의 정수가 공백으로 구분되어 주어집니다.
     - 각 정수는 수열을 구성하는 원소로, 각각 10,000 이하의 자연수입니다.

2. **출력**
   - 합이 `S` 이상이 되는 가장 짧은 부분 수열의 길이를 출력합니다. 만약 그런 부분 수열이 존재하지 않으면 `0`을 출력합니다.

## 접근 방식

이 문제는 효율적인 탐색 알고리즘이 필요합니다. 단순히 모든 부분합을 계산하는 방법은 시간 복잡도가 너무 커서, `N`이 최대 100,000일 때는 사용할 수 없습니다. 따라서 **슬라이딩 윈도우**(two-pointer) 방법을 사용하여 문제를 해결하는 것이 적합합니다. 슬라이딩 윈도우는 두 개의 포인터(`start`, `end`)를 이용해 구간을 확장하거나 축소하면서 조건을 만족하는 구간을 빠르게 찾는 방식입니다.

이 알고리즘은 구간을 점진적으로 확장하고 축소하며 조건을 만족하는 부분합을 찾기 때문에, 연속된 숫자들의 합을 효율적으로 계산할 수 있습니다. 슬라이딩 윈도우 방법을 사용하면 O(N)의 시간 복잡도로 문제를 해결할 수 있어 큰 입력값도 빠르게 처리할 수 있습니다.

## 풀이 과정

1. 먼저 두 개의 포인터 `start`와 `end`를 0으로 초기화합니다. 이 포인터들은 수열 내에서 부분 수열의 시작과 끝을 가리키며, 연속된 부분합을 구하는 구간을 나타냅니다.
2. 또한, 현재 구간의 합을 저장할 변수 `current_sum`을 0으로 설정하고, 최소 길이를 저장할 `min_length` 변수를 매우 큰 값으로 초기화합니다. 이렇게 함으로써 추후에 조건을 만족하는 가장 짧은 길이를 찾아낼 수 있습니다.

3. 이제 슬라이딩 윈도우를 이용하여 반복문을 돌립니다.

   - 현재 구간의 합이 목표로 하는 값 `S` 이상이면, 그 구간의 길이와 최소 길이를 비교합니다. 만약 현재 구간의 길이가 더 짧다면, 최소 길이를 갱신합니다.
   - 그런 다음, 구간을 축소하기 위해 `start` 포인터를 한 칸 오른쪽으로 이동시키고, 해당 시작점에 있던 값을 부분합에서 제외합니다.
   - 만약 현재 구간의 합이 `S`보다 작다면, 구간을 확장하기 위해 `end` 포인터를 오른쪽으로 이동시키고, 그 값만큼을 부분합에 더해줍니다.
   - 끝 포인터가 수열의 끝에 도달했을 때 반복을 종료합니다.

4. 반복문이 종료된 후에도 최소 길이가 갱신되지 않았으면, 부분합이 `S` 이상인 구간을 찾지 못한 것이므로 `0`을 출력합니다. 반면, 최소 길이가 갱신되었으면 그 값을 출력합니다.

## 코드 구현

```python
# 첫 번째 줄에서 N(수열의 길이)과 S(부분합의 최소 값)를 입력받아 각각 N과 S에 저장한다.
N, S = map(int, input().split())

# 두 번째 줄에서 수열의 각 원소를 공백으로 구분하여 입력받고, 이를 리스트로 변환하여 numbers에 저장한다.
numbers = list(map(int, input().split()))

# 시작 포인터(start)와 끝 포인터(end)를 0으로 초기화한다. 이 포인터들은 슬라이딩 윈도우를 구성하는 데 사용된다.
start, end = 0, 0

# 현재까지 계산한 부분합을 저장할 변수 current_sum을 0으로 초기화한다.
current_sum = 0

# 최소 길이를 저장할 변수 min_length를 무한대(inf)로 초기화한다. 나중에 더 작은 값이 나오면 갱신할 것이다.
min_length = float('inf')

# 종료 조건을 만족할 때까지 반복을 계속한다.
while True:

    # 현재 부분합이 S 이상인 경우, 해당 부분합을 만족하는 구간이므로 처리한다.
    if current_sum >= S:

        # 현재 부분합을 만족하는 구간의 길이와 현재까지의 최소 길이를 비교하여 더 작은 값을 min_length에 저장한다.
        min_length = min(min_length, end - start)

        # 현재 시작점의 값을 부분합에서 제외하여 슬라이딩 윈도우를 줄인다.
        current_sum -= numbers[start]

        # 시작 포인터를 오른쪽으로 한 칸 이동시킨다.
        start += 1

    # 끝 포인터가 수열의 끝에 도달한 경우, 더 이상 확장할 수 없으므로 반복을 종료한다.
    elif end == N:
        break

    # 현재 부분합이 S보다 작고, 아직 수열의 끝에 도달하지 않은 경우.
    else:

        # 끝 포인터가 가리키는 값을 부분합에 더하여 슬라이딩 윈도우를 확장한다.
        current_sum += numbers[end]

        # 끝 포인터를 오른쪽으로 한 칸 이동시킨다.
        end += 1

# 만약 최소 길이가 여전히 무한대인 경우, 부분합을 만족하는 구간이 없다는 의미이므로 0을 출력한다.
if min_length == float('inf'):
    print(0)

# 최소 길이가 갱신되었으면 그 값을 출력한다.
else:
    print(min_length)
```
