# 최솟값 찾기 문제 풀이 및 설명

https://www.acmicpc.net/problem/11003

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-11003-%ec%b5%9c%ec%86%9f%ea%b0%92-%ec%b0%be%ea%b8%b0-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 주어진 수열에서 슬라이딩 윈도우 방식으로 각 범위 내의 최솟값을 구하는 문제입니다. 구체적으로, 수열 `A`가 주어졌을 때, 크기 `L`인 윈도우를 이동하면서 각 범위 내에서 가장 작은 값을 찾아야 합니다. 이때 윈도우는 앞에서부터 한 칸씩 이동하며, `i`번째 윈도우는 `Ai-L+1`부터 `Ai`까지의 값들 중 최솟값을 의미합니다. 이 과정에서 수열의 인덱스가 음수가 되는 경우는 무시해야 하며, 빠르게 계산할 수 있는 알고리즘을 설계해야 합니다. 단순히 각 범위를 모두 탐색하는 방식은 비효율적이므로, 적절한 자료 구조를 활용해 최솟값을 빠르게 갱신하는 것이 중요합니다.

## 입출력 조건

- **입력 조건**:
  - 첫 번째 줄에 두 개의 자연수 `N`과 `L`이 주어집니다. `N`은 수열의 길이, `L`은 슬라이딩 윈도우의 크기입니다. (`1 ≤ L ≤ N ≤ 5,000,000`)
  - 두 번째 줄에 `N`개의 정수로 이루어진 수열 `A`가 주어집니다. 수열의 각 요소는 -10^9부터 10^9까지의 범위를 가집니다.
- **출력 조건**:
  - 주어진 수열에서 크기 `L`인 슬라이딩 윈도우의 각 범위에서 구한 최솟값을 공백으로 구분하여 한 줄로 출력합니다.
  - 출력되는 값의 순서는 슬라이딩 윈도우가 이동하면서 계산된 순서대로 출력해야 합니다.

## 접근 방식

이 문제는 슬라이딩 윈도우 범위에서 매번 최솟값을 구해야 하므로, 범위 내의 값들을 효율적으로 관리할 수 있는 자료 구조를 사용해야 합니다. 이를 위해 **덱(Deque)** 자료 구조를 사용한 최적화된 방법을 채택할 수 있습니다.

1. **덱을 활용한 슬라이딩 윈도우 최솟값 계산**:

   - 덱은 양쪽 끝에서 삽입과 삭제가 가능하므로, 슬라이딩 윈도우에서 값을 추가하거나 제거할 때 유용합니다.
   - 윈도우의 범위가 이동하면서 범위에서 벗어난 값들을 덱에서 제거하고, 새로운 값이 들어올 때 덱 안에서 현재 값보다 큰 값들을 제거하면 항상 덱의 앞쪽에는 최솟값이 남게 됩니다.
   - 각 위치에서 덱의 첫 번째 요소는 해당 윈도우의 최솟값을 가리키므로, 이 값을 기록하면 됩니다.

2. **시간 복잡도 고려**:
   - 단순히 매번 슬라이딩 윈도우 범위 내에서 최솟값을 찾으려면 `O(N * L)`의 시간 복잡도가 소요됩니다. 이는 최악의 경우 매우 비효율적입니다.
   - 덱을 사용하면, 각 값이 덱에 한 번 들어가고 한 번 나가므로, 시간 복잡도를 **O(N)**으로 줄일 수 있습니다. 이는 최대 `N = 5,000,000`까지도 효율적으로 처리할 수 있습니다.

## 풀이 과정

1. **입력 처리**: 먼저 `N`과 `L` 값을 입력받고, 그다음으로 수열 `A`를 입력받습니다. 이때 수열은 리스트 형태로 저장됩니다.
2. **덱 사용**: 슬라이딩 윈도우에서 최솟값을 효율적으로 구하기 위해 덱을 사용합니다. 덱에는 실제 값이 아닌 인덱스를 저장하며, 해당 인덱스를 통해 수열의 값을 참조하여 연산을 진행합니다.
3. **윈도우 이동과 최솟값 계산**:

   - 수열의 각 인덱스를 순차적으로 탐색하며, 현재 인덱스가 속한 윈도우 범위를 유지합니다.
   - 덱의 첫 번째 값이 윈도우 범위를 벗어나면 이를 제거합니다.
   - 현재 값보다 덱의 마지막 값이 크다면, 덱에서 그 값을 제거합니다. 이는 현재 값이 더 작은데도 큰 값을 유지할 필요가 없기 때문입니다.
   - 그 후, 현재 인덱스를 덱에 추가합니다.
   - 덱의 첫 번째 값은 항상 현재 윈도우에서의 최솟값을 가리키므로, 이를 결과 리스트에 추가합니다.

4. **결과 출력**: 모든 연산이 끝나면 최솟값들이 저장된 결과 리스트를 공백으로 구분하여 출력합니다.

## 코드 구현

```python
from collections import deque

# N과 L을 입력받는다. N은 수열의 길이, L은 슬라이딩 윈도우의 크기
N, L = map(int, input().split())

# N개의 수열 A를 입력받는다.
A = list(map(int, input().split()))

# 덱(deque) 자료 구조를 초기화한다. 이 덱은 윈도우의 인덱스를 저장하는 데 사용된다.
dq = deque()

# 결과값을 저장할 리스트를 초기화한다.
result = []

# 수열의 각 원소에 대해 반복문을 실행한다.
for i in range(N):
    # 덱의 첫 번째 요소가 현재 윈도우의 범위를 벗어나면 제거한다.
    if dq and dq[0] < i - L + 1:
        dq.popleft()

    # 새로운 값이 들어올 때, 덱의 마지막 값이 현재 값보다 크면 덱에서 제거한다.
    # 이렇게 하면 덱은 항상 최솟값을 유지하게 된다.
    while dq and A[dq[-1]] > A[i]:
        dq.pop()

    # 현재 인덱스를 덱에 추가한다.
    dq.append(i)

    # 덱의 첫 번째 값은 현재 윈도우에서의 최솟값을 가리키므로, 이를 결과 리스트에 추가한다.
    result.append(A[dq[0]])

# 결과 리스트의 값을 공백으로 구분하여 출력한다.
print(" ".join(map(str, result)))
```
