# 냅색문제 문제 풀이 및 설명

https://www.acmicpc.net/problem/1450

## 문제 이해

이 문제는 주어진 물건들을 최대 무게 제한이 있는 가방에 담는 방법의 수를 구하는 문제입니다. N개의 물건이 주어지고, 각 물건의 무게가 주어질 때, 무게의 합이 C를 넘지 않도록 하면서 물건을 선택하는 모든 가능한 경우의 수를 계산해야 합니다. 이는 조합 문제로, 물건의 선택 여부에 따라 가능한 모든 부분 집합을 고려해야 합니다. 물건을 선택하지 않는 경우부터 시작해서 모든 물건을 선택하는 경우까지 고려해야 합니다.

이 문제에서 중요한 점은 N이 최대 30이기 때문에, 모든 경우의 수를 전부 다 계산하는 브루트포스(완전탐색) 방식은 효율적이지 않을 수 있다는 것입니다. 대신, 더 효율적인 알고리즘이나 전략을 사용해야 합니다.

## 입출력 조건

- **입력 조건**:

  - 첫 줄에 물건의 수 `N`과 가방의 최대 무게 `C`가 주어집니다.
  - `N`은 30보다 작거나 같은 자연수이며, `C`는 0 이상 10^9 이하의 정수입니다.
  - 두 번째 줄에는 각 물건의 무게가 주어지며, 각 무게도 10^9 이하의 자연수입니다.

- **출력 조건**:
  - 가방에 넣는 방법의 수를 출력합니다. 이는 선택한 물건들의 무게 합이 C 이하가 되도록 하는 모든 가능한 조합의 수입니다.

## 접근 방식

이 문제를 해결하기 위해서 사용할 수 있는 적절한 방법은 "Meet in the middle" 기법입니다. 이 방법은 전체 리스트를 두 부분으로 나누어 각각의 부분 집합의 합을 계산한 뒤, 이 두 집합을 합쳐 가능한 모든 경우를 계산하는 방식입니다.

이 방법은 다음과 같은 이유로 유리합니다:

- N이 최대 30이므로, 리스트를 반으로 나누면 각각의 크기는 최대 15가 됩니다. 15개의 원소에 대해 모든 부분 집합을 생성하는 것은 2^15 = 32768개로, 계산 가능한 범위 내에 있습니다.
- 이렇게 나눈 두 리스트에 대해 부분 집합의 합을 계산하고, 두 리스트의 합이 C를 넘지 않는 조합의 수를 세어줍니다.

이 방법을 사용하면 가능한 모든 경우의 수를 계산하면서도, 탐색 공간을 효과적으로 줄일 수 있습니다.

## 풀이 과정

1. **리스트 분할**:

   - 주어진 물건들의 리스트를 두 개의 하위 리스트로 나눕니다. 예를 들어, N개의 물건이 주어졌을 때, 첫 번째 하위 리스트는 앞쪽 절반, 두 번째 하위 리스트는 나머지 절반을 가집니다.

2. **부분 집합의 합 계산**:

   - 각 하위 리스트에 대해 가능한 모든 부분 집합을 생성하고, 각 부분 집합의 합을 계산합니다. 이때, 부분 집합에는 어떤 물건도 선택하지 않은 경우(합이 0인 경우)도 포함됩니다.

3. **이진 탐색을 위한 정렬**:

   - 두 번째 하위 리스트에서 계산한 부분 집합의 합을 정렬합니다. 정렬된 리스트는 이후 이진 탐색을 통해 가능한 조합의 수를 빠르게 찾는 데 사용됩니다.

4. **가능한 조합의 수 계산**:

   - 첫 번째 하위 리스트에서 계산한 부분 집합의 합을 하나씩 순회하면서, 이 합에 대해 두 번째 하위 리스트에서 더할 수 있는 부분 집합의 합을 이진 탐색으로 찾습니다. 이때, 두 부분 집합의 합이 C를 넘지 않는 경우만을 고려합니다.

5. **최종 출력**:
   - 모든 가능한 조합을 계산한 후, 그 결과를 출력합니다.

이 과정을 통해 문제에서 요구하는 모든 경우의 수를 효율적으로 계산할 수 있습니다. 특히, "Meet in the middle" 기법은 리스트의 크기가 크지 않을 때 매우 유용하며, 이 문제에서도 적합하게 사용됩니다.

## 코드 구현

```python
from itertools import combinations
from bisect import bisect_right

def get_subsets(weights):
    n = len(weights)  # 리스트의 길이(원소의 개수)를 변수 n에 저장
    subsets = []  # 부분 집합의 합을 저장할 빈 리스트 생성
    for i in range(n + 1):  # 부분 집합의 크기를 0부터 n까지 반복
        for comb in combinations(weights, i):  # 각 크기에 해당하는 모든 조합을 생성
            subsets.append(sum(comb))  # 조합의 합을 계산하여 subsets 리스트에 추가
    return subsets  # 계산된 부분 집합의 합 리스트를 반환

def count_valid_combinations(N, C, weights):
    left_weights = weights[:N//2]  # 리스트의 첫 번째 절반을 left_weights로 설정
    right_weights = weights[N//2:]  # 리스트의 나머지 절반을 right_weights로 설정

    left_subsets = get_subsets(left_weights)  # 왼쪽 절반의 부분 집합의 합 계산
    right_subsets = get_subsets(right_weights)  # 오른쪽 절반의 부분 집합의 합 계산

    right_subsets.sort()  # 이진 탐색을 위해 오른쪽 부분 집합의 합을 오름차순으로 정렬

    count = 0  # 가능한 조합의 수를 저장할 변수 초기화

    for left_sum in left_subsets:  # 왼쪽 부분 집합의 합을 하나씩 순회
        if left_sum <= C:  # 왼쪽 부분 집합의 합이 C 이하인 경우에만 처리
            count += bisect_right(right_subsets, C - left_sum)
            # 오른쪽 부분 집합에서 left_sum과 합쳐서 C 이하가 되는 경우의 수를 이진 탐색으로 계산하여 count에 더함

    return count  # 최종 계산된 가능한 조합의 수 반환

N, C = map(int, input().split())  # 첫 번째 줄의 입력 값을 받아 N과 C에 저장
weights = list(map(int, input().split()))  # 두 번째 줄의 입력 값을 리스트로 받아 weights에 저장

print(count_valid_combinations(N, C, weights))  # 가능한 조합의 수를 계산하여 출력
```
