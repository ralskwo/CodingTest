# LCS 3 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1958>

<https://mayquartet.com/python-백준-1958-lcs-3/>

## 문제 이해

주어진 문제는 세 개의 문자열에 대해 가장 긴 공통 부분 수열(Longest Common Subsequence, LCS)의 길이를 구하는 것입니다. LCS는 두 개 이상의 문자열이 가지고 있는 부분 수열 중 가장 긴 공통된 부분을 말합니다. 예를 들어, 문자열 "abcde"와 "ace"의 LCS는 "ace"이며 길이는 3입니다. 이번 문제에서는 세 개의 문자열에 대해 이 값을 계산해야 하며, 이를 위해 적절한 알고리즘을 설계해야 합니다.

---

## 입출력 조건

### 입력 조건

1. 첫 번째 줄에는 첫 번째 문자열이 주어집니다.
2. 두 번째 줄에는 두 번째 문자열이 주어집니다.
3. 세 번째 줄에는 세 번째 문자열이 주어집니다.
4. 모든 문자열은 소문자 알파벳으로 구성되어 있으며, 길이는 100 이하입니다.

### 출력 조건

1. 첫 줄에 세 개의 문자열에 대한 LCS의 길이를 정수로 출력합니다.

---

## 접근 방식

이 문제를 해결하기 위해 다이나믹 프로그래밍(Dynamic Programming, DP) 방식을 사용해야 합니다. 두 문자열의 LCS를 구할 때는 2차원 DP 테이블을 활용하지만, 세 문자열의 LCS를 구하기 위해서는 3차원 DP 테이블을 생성해야 합니다.

1. `dp[i][j][k]`를 정의합니다. 이 값은 첫 번째 문자열의 첫 `i`개 문자, 두 번째 문자열의 첫 `j`개 문자, 세 번째 문자열의 첫 `k`개 문자에 대해 LCS의 길이를 나타냅니다.
2. 점화식을 수립합니다.
   - 세 문자열의 현재 문자가 모두 같다면, `dp[i][j][k]`는 이전 상태 `dp[i-1][j-1][k-1]`에 1을 더한 값입니다.
   - 세 문자가 같지 않다면, 세 가지 경우 중 최대값을 선택합니다.
     - 첫 번째 문자열만 하나 줄인 상태
     - 두 번째 문자열만 하나 줄인 상태
     - 세 번째 문자열만 하나 줄인 상태
3. 기본 초기값으로는 모든 DP 테이블의 값을 0으로 설정합니다.
4. 반복문을 통해 DP 테이블을 채운 후, 최종적으로 계산된 `dp[len1][len2][len3]` 값을 반환합니다.

---

## 풀이 과정

1. 문자열의 길이를 각각 `len1`, `len2`, `len3`에 저장합니다. 이를 통해 반복문의 범위를 설정할 수 있습니다.
2. 3차원 DP 테이블을 생성합니다. 크기는 `(len1+1) x (len2+1) x (len3+1)`로 설정하고, 모든 값을 0으로 초기화합니다.
3. 세 개의 중첩 반복문을 사용하여 DP 테이블을 채웁니다. 반복문의 범위는 각각 1부터 `len1+1`, `len2+1`, `len3+1`까지입니다.
4. 현재 위치의 세 문자가 같다면 `dp[i][j][k]`에 이전 상태인 `dp[i-1][j-1][k-1]`에 1을 더한 값을 저장합니다.
5. 세 문자가 같지 않다면 `dp[i][j][k]`에 세 가지 경우 중 최대값을 저장합니다.
   - `dp[i-1][j][k]`: 첫 번째 문자열만 하나 줄인 상태
   - `dp[i][j-1][k]`: 두 번째 문자열만 하나 줄인 상태
   - `dp[i][j][k-1]`: 세 번째 문자열만 하나 줄인 상태
6. 반복문이 끝나면 DP 테이블의 마지막 값인 `dp[len1][len2][len3]`에 세 문자열의 LCS 길이가 저장됩니다.
7. 이 값을 반환하여 출력합니다.

## 코드 구현

```python
def longest_common_subsequence(str1, str2, str3):
    # 각 문자열의 길이를 구한다.
    len1, len2, len3 = len(str1), len(str2), len(str3)

    # 3차원 DP 테이블을 생성하고, 초기값은 모두 0으로 설정한다.
    # dp[i][j][k]는 str1의 i번째 문자까지, str2의 j번째 문자까지, str3의 k번째 문자까지의 LCS 길이를 의미한다.
    dp = [[[0] * (len3 + 1) for _ in range(len2 + 1)] for __ in range(len1 + 1)]

    # 세 문자열의 각 문자를 비교하여 DP 테이블을 채운다.
    for i in range(1, len1 + 1):  # 첫 번째 문자열의 길이만큼 반복
        for j in range(1, len2 + 1):  # 두 번째 문자열의 길이만큼 반복
            for k in range(1, len3 + 1):  # 세 번째 문자열의 길이만큼 반복
                # 현재 위치의 세 문자가 모두 같으면 이전 상태의 값에서 1을 더한다.
                if str1[i-1] == str2[j-1] == str3[k-1]:
                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1
                # 그렇지 않다면, 가능한 세 가지 경우 중 최대값을 선택한다.
                else:
                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])

    # 최종 결과값은 dp[len1][len2][len3]에 저장되어 있다.
    return dp[len1][len2][len3]

# 첫 번째 문자열 입력을 받는다.
str1 = input().strip()
# 두 번째 문자열 입력을 받는다.
str2 = input().strip()
# 세 번째 문자열 입력을 받는다.
str3 = input().strip()

# 세 문자열의 LCS 길이를 계산하여 출력한다.
print(longest_common_subsequence(str1, str2, str3))
```
