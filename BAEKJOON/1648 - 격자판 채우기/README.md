# 격자판 채우기 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1648>

<https://mayquartet.com/python-백준-1648-격자판-채우기/>

## 문제 이해

이 문제는 격자판을 2x1 크기의 도미노로 빈 공간 없이 채우는 경우의 수를 계산하는 것입니다. 도미노는 세로로 놓을 수도 있고 가로로 회전시켜서 놓을 수도 있으며, 이때 격자판이 완전히 채워져야 합니다. 주어진 격자판의 세로 크기 `N`과 가로 크기 `M`을 만족하는 격자판에 대해 가능한 모든 도미노 배치의 수를 계산하는 것이 목표입니다.

문제를 해결하기 위해서 중요한 점은 다음과 같습니다:

1. **격자판 크기가 홀수**인 경우, 모든 칸을 도미노로 채울 수 없습니다. 도미노는 2개의 칸을 차지하기 때문에 칸의 총 개수가 짝수여야만 완전히 채워질 수 있습니다.
2. 격자판의 크기가 **1 이상 14 이하의 작은 정수**이므로, 비트마스킹과 DP를 활용한 효율적인 접근 방식이 필요합니다.
3. 최종 결과를 `9901`로 나눈 나머지를 출력해야 하므로, 계산 과정에서도 이 조건을 반영해 큰 수를 제한하는 연산이 필요합니다.

## 입출력 조건

**입력 조건**

- 첫 줄에 격자판의 세로 크기 `N`과 가로 크기 `M`이 주어집니다.
- `1 ≤ N, M ≤ 14`의 범위를 가집니다.

**출력 조건**

- 격자판을 2x1 크기의 도미노로 빈 공간 없이 채울 수 있는 모든 경우의 수를 `9901`로 나눈 나머지를 출력합니다.

## 접근 방식

이 문제는 **동적 계획법(DP)**과 **비트마스킹(Bitmasking)**을 결합해 풀 수 있는 문제입니다. 격자판을 빈틈없이 채워야 하는 특성상, **현재 상태를 기준으로 가능한 모든 다음 상태로의 전이를 정의**하여 이를 통해 가능한 배치 수를 효율적으로 계산할 수 있습니다. 이 문제를 해결하기 위한 주요 전략은 다음과 같습니다.

1. **비트마스킹을 사용하여 격자 상태 관리**  
   각 열의 상태를 `비트마스크`를 통해 표현하여 모든 경우의 수를 DP 배열에 저장합니다. 예를 들어, 격자의 각 칸을 비트로 나타내어 도미노가 놓인 위치와 비어있는 위치를 표현합니다. 이를 통해 메모리와 연산량을 줄일 수 있습니다.

2. **DP 배열을 통해 열 단위 상태 전이 계산**  
   각 열에서 가능한 모든 상태를 저장한 후, 다음 열로 전이될 수 있는 상태를 확인하면서 가능한 배치 수를 누적 계산합니다. 현재 열의 상태에 따라 다음 열에서의 상태가 어떻게 될지 전이하는 방식으로 진행합니다.

3. **문제를 작은 문제들로 나누어 해결**  
   각 열에 대해 독립적으로 계산하고, 열 단위로 상태 전이를 반복하여 마지막 열까지 격자판을 채워 나갑니다. 이렇게 작은 문제로 나누어 해결하면 전체 계산이 효율적으로 가능합니다.

4. **MOD 값 적용**  
   계산 과정에서 값이 커지는 것을 방지하기 위해 매 연산마다 `9901`로 나누어 값을 갱신합니다.

## 풀이 과정

1. **DP 배열 초기화**  
   격자판의 모든 열에 대해 가능한 상태를 저장하는 `dp` 배열을 선언합니다. `dp[열][상태]`는 특정 열과 상태에서 도미노 배치를 완료할 수 있는 경우의 수를 나타냅니다. 초기 상태로 `dp[0][0] = 1`로 설정하여 시작합니다. 이때 `1 << N`은 세로 크기 `N`에 대한 모든 상태를 표현하는 비트 수입니다.

2. **각 열에 대한 상태 전이**  
   첫 번째 열부터 마지막 열까지 순차적으로 가능한 모든 상태 전이를 계산합니다. 열 단위로 현재 상태에 맞추어 가능한 모든 다음 상태를 생성하여 `generate_next_states` 함수를 통해 `next_states` 리스트에 저장합니다. 이때, 현재 상태가 이미 `dp`에서 불가능한 상태(배치 수가 0인 경우)라면 건너뜁니다.

3. **다음 상태 생성 함수**  
   `generate_next_states` 함수는 비어 있는 위치에 도미노를 놓을 수 있는지 확인하고, 가능한 경우 다음 상태를 생성하여 리스트에 저장합니다. 현재 위치가 이미 채워져 있으면 `pos + 1`로 이동하고, 비어 있으면 도미노를 세로로 배치하거나(2x1), 가로로 배치(1x2)하여 다음 위치로 이동합니다. 이 과정에서 열의 마지막 칸까지 채워졌다면 완성된 상태를 `next_states`에 추가합니다.

4. **모든 열의 상태 전이 완료 후 마지막 열 검사**  
   각 열의 모든 가능한 상태 전이를 마친 후 마지막 열이 모두 채워진 상태(`dp[M][0]`)의 값을 반환합니다. 이 값이 바로 격자판을 완전히 채우는 모든 경우의 수입니다.

5. **최종 출력**  
   최종적으로 `count_ways_to_fill` 함수를 호출하여 가능한 배치 수를 계산한 뒤 출력합니다.

## 코드 구현

```python
MOD = 9901  # 나눌 모듈러 값 설정

def count_ways_to_fill(N, M):
    if (N * M) % 2 != 0:  # 격자판의 칸 수가 홀수일 경우 도미노로 채울 수 없음
        return 0  # 홀수일 경우 0 반환

    # dp 테이블 생성: dp[열][상태 비트마스크]로 설정
    dp = [[0] * (1 << N) for _ in range(M + 1)]
    dp[0][0] = 1  # 초기 상태에서 가능한 배치 수 1로 설정

    # 각 열에 대해 상태를 갱신하며 도미노 배치 계산
    for col in range(M):
        for state in range(1 << N):  # 각 상태 비트마스크에 대해 반복
            if dp[col][state] == 0:  # 해당 상태에서 가능하지 않으면 건너뜀
                continue
            next_states = []  # 다음 열로 전이 가능한 상태 저장할 리스트
            generate_next_states(0, N, state, 0, next_states)  # 현재 상태에서 다음 상태 생성
            for next_state in next_states:
                dp[col + 1][next_state] = (dp[col + 1][next_state] + dp[col][state]) % MOD
                # 모듈러를 사용해 다음 상태에 가능한 배치 수 추가

    return dp[M][0]  # 마지막 열이 모두 채워진 상태에서 가능한 배치 수 반환

def generate_next_states(pos, N, current_state, next_state, next_states):
    if pos == N:  # 현재 위치가 N이라면 전체 열이 채워졌음을 의미
        next_states.append(next_state)  # 완성된 다음 상태를 리스트에 추가
        return
    if (current_state & (1 << pos)) != 0:  # 현재 위치에 도미노가 이미 차있는 경우
        generate_next_states(pos + 1, N, current_state, next_state, next_states)  # 다음 칸으로 이동
    else:
        generate_next_states(pos + 1, N, current_state, next_state | (1 << pos), next_states)  # 2x1 세로 배치
        if pos + 1 < N and (current_state & (1 << (pos + 1))) == 0:  # 1x2 가로 배치가 가능한지 확인
            generate_next_states(pos + 2, N, current_state, next_state, next_states)  # 가로 배치로 전이 가능하면 다음 상태 생성

# 입력 값을 받아 count_ways_to_fill 함수로 가능한 배치 수 계산
N, M = map(int, input().split())
print(count_ways_to_fill(N, M))
```
