# 공주님의 정원 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2457>

<https://mayquartet.com/python-파이썬-백준-2457-공주님의-정원/>

## 문제 이해

이 문제는 주어진 꽃들 중에서 특정 기간(3월 1일부터 11월 30일까지) 동안 매일 최소 한 가지 꽃이 피어 있도록 선택해야 하며, 이때 선택한 꽃들의 수를 최소화하는 것이 목표입니다.

각 꽃은 `시작일`과 `종료일`이 있으며, 꽃이 피는 기간 동안만 정원에 있는 것으로 간주됩니다. 예를 들어, `3월 8일`에 피어서 `7월 31일`에 지는 꽃이라면, 이 꽃은 `3월 8일`부터 `7월 30일`까지 정원에 피어 있고, `7월 31일`부터는 정원에 더 이상 존재하지 않습니다.

이 문제는 그리디 알고리즘을 사용하여 해결할 수 있으며, 가장 적은 수의 꽃을 선택하여 3월 1일부터 11월 30일까지의 기간을 커버해야 합니다. 이를 위해 꽃의 시작일과 종료일을 날짜 형식으로 변환하고, 정렬 및 선택 과정을 통해 문제를 해결할 수 있습니다.

## 입출력 조건

- **입력**

  - 첫 줄에는 꽃의 개수 `N`이 주어지며, `1 ≤ N ≤ 100,000`의 범위를 가집니다.
  - 다음 `N`개의 줄에는 각 꽃이 피는 시작일과 지는 종료일이 주어지며, 각 날짜는 월과 일로 표현됩니다.
  - 예를 들어 `3 8 7 31`은 꽃이 `3월 8일`에 피어서 `7월 31일`에 진다는 의미입니다.

- **출력**
  - 주어진 조건을 만족하는 최소한의 꽃 개수를 출력합니다.
  - 만약 3월 1일부터 11월 30일까지 매일 꽃이 피어 있는 것이 불가능하면 `0`을 출력합니다.

## 접근 방식

이 문제는 `그리디 알고리즘`을 사용하여 해결할 수 있습니다. 그리디 알고리즘을 사용하기 위해 다음과 같은 접근 방식을 사용합니다.

1. **날짜 변환 및 정렬**

   - 입력으로 주어진 월과 일을 `MMDD` 형식의 숫자로 변환하여 비교하기 쉽게 만듭니다. 예를 들어, `3월 8일`을 `308`, `7월 31일`을 `731`로 변환합니다.
   - 꽃들을 피는 `시작 날짜`를 기준으로 오름차순 정렬하되, 시작 날짜가 같은 경우 `종료 날짜`를 기준으로 내림차순 정렬합니다. 이렇게 하면 먼저 시작하는 꽃들 중에서 가장 늦게 지는 꽃을 쉽게 선택할 수 있습니다.

2. **그리디 알고리즘을 통한 최소 꽃 선택**
   - 3월 1일(`301`)부터 11월 30일(`1130`)까지의 기간을 매일 꽃이 피어 있도록 하기 위해, 현재 커버할 수 있는 `최대 종료일`을 추적하며 꽃을 선택합니다.
   - 현재 커버할 수 있는 기간의 끝(`current_end`)을 초기화한 후, 이 기간을 확장할 수 있는 가장 늦게 지는 꽃을 선택합니다.
   - 선택된 꽃의 종료일이 11월 30일을 넘어가면 종료하고, 이때 선택된 꽃의 수를 최소화하여 출력합니다.
   - 만약 11월 30일까지의 기간을 모두 커버하지 못하면 `0`을 출력합니다.

<https://mayquartet.com/algorithm-알고리즘-greedy-그리디-알고리즘탐욕법-이해하기/>

## 풀이 과정

1. **입력 처리 및 날짜 변환**

   - 먼저 꽃의 개수 `N`을 입력받습니다.
   - 각 꽃의 시작일과 종료일을 `MMDD` 형식으로 변환하여 리스트 `flowers`에 저장합니다. 예를 들어 `3 8 7 31`이라는 입력이 들어오면, 이를 `(308, 731)`로 변환하여 저장합니다.

2. **정렬**

   - `flowers` 리스트를 `시작 날짜`를 기준으로 오름차순 정렬하되, 시작 날짜가 같은 경우 `종료 날짜`를 기준으로 내림차순 정렬합니다. 이렇게 하면 시작 날짜가 같을 때 더 오래 피어 있는 꽃이 앞에 오게 됩니다.

3. **변수 초기화**

   - `START`와 `END`를 각각 `301`(3월 1일)과 `1130`(11월 30일)으로 설정하여, 커버해야 하는 날짜 범위를 정합니다.
   - `current_end`를 `START`로 초기화하여, 현재 커버할 수 있는 마지막 날짜를 3월 1일로 설정합니다.
   - `max_end`와 `count`를 각각 0으로 초기화하여, `max_end`는 선택한 꽃들이 커버할 수 있는 최대 종료일을, `count`는 선택한 꽃의 수를 추적합니다.
   - `i`를 0으로 설정하여, `flowers` 리스트의 인덱스를 추적합니다.

4. **그리디 알고리즘 적용**

   - 모든 꽃을 순회하거나, 커버할 수 있는 날짜가 11월 30일을 넘어갈 때까지 반복합니다.
   - `current_end` 이하에서 피는 꽃들 중에서, 가장 늦게 지는 꽃을 선택하여 `max_end`로 설정합니다.
   - 만약 더 이상 커버할 수 있는 날짜를 연장할 수 없다면(즉, `max_end`가 `current_end`보다 크지 않다면), 이는 3월 1일부터 11월 30일까지 모든 날짜를 커버할 수 없는 경우이므로 반복을 종료하고 `0`을 출력합니다.
   - 선택한 꽃을 기반으로 `current_end`를 `max_end`로 갱신하고, 선택한 꽃의 수 `count`를 1 증가시킵니다.

5. **결과 출력**
   - 반복문이 끝난 후 `current_end`가 11월 30일보다 작다면, 이는 3월 1일부터 11월 30일까지 모든 날짜를 커버할 수 없음을 의미하므로 `0`을 출력합니다.
   - 그렇지 않다면, 선택된 꽃의 수 `count`를 출력합니다.

## 코드 구현

```python
import sys
input = sys.stdin.read
data = input().splitlines()  # 입력을 한 번에 받아 각 줄을 리스트로 저장

N = int(data[0])  # 첫 번째 줄에 있는 꽃의 개수 N을 정수로 변환하여 저장
flowers = []  # 꽃의 시작 날짜와 종료 날짜를 저장할 리스트

for i in range(1, N+1):  # 1번 인덱스부터 N번까지의 꽃의 정보들을 처리
    sm, sd, em, ed = map(int, data[i].split())  # 각 꽃의 시작 월, 시작 일, 종료 월, 종료 일을 정수로 변환
    start = sm * 100 + sd  # 시작 날짜를 MMDD 형식으로 변환 (예: 3월 8일 → 308)
    end = em * 100 + ed    # 종료 날짜를 MMDD 형식으로 변환 (예: 7월 31일 → 731)
    flowers.append((start, end))  # 변환된 시작일과 종료일을 flowers 리스트에 추가

flowers.sort(key=lambda x: (x[0], -x[1]))  # 시작 날짜를 기준으로 오름차순 정렬, 같은 시작일이면 종료일을 내림차순 정렬

START = 301  # 꽃이 피어야 하는 기간의 시작일 (3월 1일)을 MMDD 형식으로 설정
END = 1130   # 꽃이 피어야 하는 기간의 종료일 (11월 30일)을 MMDD 형식으로 설정

current_end = START  # 현재 커버할 수 있는 마지막 날짜를 START로 초기화 (처음에는 3월 1일부터 시작)
max_end = 0          # 선택된 꽃들이 커버할 수 있는 최대 종료 날짜
count = 0            # 선택된 꽃의 수
i = 0                # flowers 리스트의 인덱스를 추적할 변수

while i < N and current_end <= END:  # 모든 꽃을 순회하거나, 커버할 수 있는 날짜가 END를 넘어갈 때까지 반복
    while i < N and flowers[i][0] <= current_end:  # 현재 커버할 수 있는 날짜 이하에서 피는 꽃을 찾음
        max_end = max(max_end, flowers[i][1])  # 현재 꽃이 지는 날짜를 기준으로 가장 늦게 지는 꽃을 선택
        i += 1  # 다음 꽃으로 이동

    if max_end <= current_end:  # 만약 더 이상 커버할 수 있는 날짜를 연장할 수 없는 경우 (사각지대 발생)
        break  # 조건을 만족하지 못하므로 반복문 종료

    current_end = max_end  # 현재 커버 가능한 마지막 날짜를 갱신
    count += 1  # 꽃을 하나 선택했으므로 count 증가

if current_end <= END:  # 만약 커버한 마지막 날짜가 END보다 작다면 (즉, 11월 30일까지 도달하지 못하면)
    print(0)  # 두 조건을 만족하지 못하므로 0을 출력
else:
    print(count)  # 11월 30일까지 커버했다면 선택된 꽃의 개수 출력
```
