# 과일 탕후루 문제 풀이 및 설명

<https://www.acmicpc.net/problem/30804>

<https://mayquartet.com/python-백준-30804-과일-탕후루/>

## 문제 이해

이 문제는 "슬라이딩 윈도우"와 "투 포인터" 알고리즘을 활용하여 효율적으로 풀어야 하는 문제입니다. 문제의 핵심은 긴 막대에 꽂힌 과일 배열에서 앞과 뒤의 일부 과일을 제거하여 배열 내 과일 종류가 2개 이하가 되도록 하면서, 그 배열의 길이를 최대화하는 것입니다.

주어진 과일 배열에서 특정 부분만 남겨야 하므로, 연속된 구간(서브어레이)을 고려해야 하며, 이를 효율적으로 탐색하려면 과일의 종류를 제한하며 가능한 가장 긴 구간을 찾아야 합니다.

## 입출력 조건

### 입력 조건

1. 첫 번째 줄에 과일의 개수 `N`이 주어집니다. (`1 ≤ N ≤ 200,000`)
2. 두 번째 줄에 `N`개의 정수로 이루어진 배열 `S`가 주어지며, 각 정수는 과일의 종류를 나타냅니다. (`1 ≤ S[i] ≤ 9`)

### 출력 조건

1. 배열 내 과일 종류가 2개 이하인 연속된 부분 배열 중 가장 긴 배열의 길이를 정수로 출력합니다.

## 접근 방식

1. **문제 조건 분석**:

   - 과일 종류가 2개 이하로 제한되므로, 슬라이딩 윈도우 방식으로 연속된 구간을 확인합니다.
   - 연속된 구간 안에 포함된 과일의 종류와 개수를 효율적으로 관리해야 합니다.

2. **슬라이딩 윈도우와 투 포인터 사용**:

   - 두 개의 포인터(`left`, `right`)를 사용하여 배열 내 연속된 구간을 탐색합니다.
   - `right` 포인터는 구간을 확장하고, `left` 포인터는 필요에 따라 구간을 축소합니다.
   - 윈도우 안에 포함된 과일의 종류와 개수를 딕셔너리로 관리합니다.

3. **조건 만족 여부 확인**:

   - 윈도우 내 과일 종류가 2개 이하일 때 구간의 길이를 계산하고 최대 길이를 갱신합니다.
   - 윈도우 내 과일 종류가 2개를 초과하면, `left` 포인터를 이동해 구간에서 과일을 제거합니다.

4. **효율성 고려**:
   - 배열의 크기 `N`이 최대 200,000이므로, 시간 복잡도가 \(O(N)\)인 알고리즘을 설계해야 합니다.
   - 딕셔너리를 사용해 과일 종류와 개수를 관리하므로 추가 연산은 \(O(1)\)로 수행됩니다.

<https://mayquartet.com/algorithm-투-포인터two-pointer-알고리즘-이해하기/>

## 풀이 과정

1. **초기화**:

   - `fruit_count`라는 딕셔너리를 만들어, 현재 슬라이딩 윈도우에 포함된 과일과 그 개수를 관리합니다.
   - `left` 포인터를 0으로 초기화하고, 배열을 처음부터 탐색할 준비를 합니다.
   - 최대 길이를 저장할 변수 `max_length`를 0으로 초기화합니다.

2. **배열 순회 및 오른쪽 포인터 확장**:

   - `right` 포인터를 0부터 시작해 배열 끝까지 이동하며 구간을 확장합니다.
   - 현재 과일을 `fruit_count`에 추가하고, 해당 과일 개수를 1 증가시킵니다.

3. **윈도우 조건 확인 및 왼쪽 포인터 이동**:

   - 윈도우 내 과일 종류가 2개를 초과하면, 조건을 만족할 때까지 `left` 포인터를 이동합니다.
   - `left` 포인터가 가리키는 과일의 개수를 감소시키고, 개수가 0이 되면 딕셔너리에서 삭제합니다.
   - 이 과정을 통해 윈도우 내 과일 종류를 항상 2개 이하로 유지합니다.

4. **현재 구간 길이 계산 및 최대값 갱신**:

   - `right - left + 1`로 현재 윈도우의 길이를 계산합니다.
   - 기존 `max_length`와 비교하여 더 큰 값을 저장합니다.

5. **결과 반환**:
   - 배열 탐색이 끝난 후, `max_length`에 저장된 값을 반환합니다.
   - 이는 과일 종류가 2개 이하인 최대 길이의 부분 배열입니다.

## 코드 구현

```python
def max_fruit_length(N, fruits):
    from collections import defaultdict  # 딕셔너리를 기본값으로 초기화하는 defaultdict를 임포트

    fruit_count = defaultdict(int)  # 과일의 종류와 개수를 저장할 딕셔너리 생성
    left = 0  # 슬라이딩 윈도우의 시작 위치를 나타내는 포인터
    max_length = 0  # 최대 과일 길이를 저장할 변수

    for right in range(N):  # 슬라이딩 윈도우의 끝 위치를 나타내는 포인터를 N까지 순회
        fruit_count[fruits[right]] += 1  # 현재 과일을 딕셔너리에 추가하고 개수를 증가

        while len(fruit_count) > 2:  # 윈도우 내 과일 종류가 2개를 초과하면
            fruit_count[fruits[left]] -= 1  # 왼쪽 포인터의 과일 개수를 감소
            if fruit_count[fruits[left]] == 0:  # 과일 개수가 0이 되면 딕셔너리에서 삭제
                del fruit_count[fruits[left]]
            left += 1  # 왼쪽 포인터를 오른쪽으로 이동하여 윈도우 크기를 줄임

        max_length = max(max_length, right - left + 1)  # 현재 윈도우 길이와 최대 길이를 비교하여 갱신

    return max_length  # 최종적으로 가장 긴 윈도우 길이를 반환

N = int(input())  # 과일 개수를 입력받음
fruits = list(map(int, input().split()))  # 과일 배열을 입력받음
print(max_fruit_length(N, fruits))  # 최대 과일 길이를 출력
```
