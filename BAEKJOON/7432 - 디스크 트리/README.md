# 디스크 트리 문제 풀이 및 설명 

https://www.acmicpc.net/problem/7432

## 문제 이해

주어진 디렉토리 경로들을 트리(트라이) 자료구조를 이용해 계층적으로 저장하고, 이를 계층적인 깊이 구조로 출력하는 것이 목표입니다. 입력으로 주어지는 디렉토리 경로들은 '\\'로 구분된 서브 디렉토리들로 구성되어 있으며, 이러한 경로들을 트리에 저장하여 계층적으로 출력해야 합니다. 출력 시에는 각 서브 디렉토리의 깊이를 나타내기 위해 공백을 사용합니다.

## 입출력 조건

### 입력
- 첫 줄에는 중요한 디렉토리 전체 경로의 개수 \( N \) (1 ≤ \( N \) ≤ 500)이 주어집니다.
- 다음 \( N \)개의 줄에는 디렉토리 경로가 주어집니다. 경로는 공백 없이 '\\'로 구분된 서브 디렉토리로 구성됩니다.
- 각 디렉토리의 이름은 1~8글자이며, 알파벳 대문자, 숫자, 특수 문자('#', '$', '%', '&', '(', ')', '-', '@', '^', '_', '{', '}')로 이루어져 있습니다.

### 출력
- 트리 구조를 보기 좋게 출력합니다. 한 줄에 하나씩 디렉토리 이름을 출력하되, 공백은 디렉토리 구조 상에서 깊이를 의미합니다.
- 각 서브 디렉토리는 사전순으로 출력해야 하며, 부모 디렉토리에서 출력한 공백의 개수보다 1개 많게 공백을 출력합니다.

## 접근 방식

이 문제를 해결하기 위해 트라이(Trie) 자료구조를 사용할 수 있습니다. 트라이는 문자열을 저장하고 탐색하기 위한 트리 기반 자료구조로, 특히 문자열의 공통 접두사를 효율적으로 저장할 수 있습니다. 주어진 디렉토리 경로를 트라이에 삽입하고, 트라이를 깊이 우선 탐색(DFS)을 통해 출력함으로써 계층적 구조를 출력할 수 있습니다.

## 풀이 과정

1. **TrieNode 클래스 정의**:
   - 각 TrieNode는 자식 노드를 저장할 딕셔너리와, 경로의 끝을 나타내는 플래그를 가집니다.

2. **Trie 클래스 정의**:
   - `__init__` 메서드: 루트 노드를 생성합니다.
   - `insert` 메서드: 주어진 경로를 트라이에 삽입합니다. 경로를 '\\' 기준으로 분리하여 각 부분을 트라이에 추가합니다. 자식 노드 중 현재 부분이 없다면 새로운 노드를 생성하고, 현재 노드를 자식 노드로 이동합니다. 경로의 끝에 도달하면 플래그를 설정합니다.
   - `display` 메서드: 트라이 구조를 출력합니다. 재귀적으로 자식 노드를 탐색하여 깊이 우선 탐색(DFS)을 수행합니다. 자식 노드들을 사전순으로 정렬하여 출력하며, 현재 깊이만큼 공백을 추가하여 트리 구조를 시각적으로 표현합니다.

3. **메인 함수**:
   - 표준 입력으로부터 전체 데이터를 읽어와 첫 번째 줄에서 디렉토리 경로의 개수를 얻고, 나머지 줄에서 경로들을 리스트로 저장합니다.
   - Trie 객체를 생성하고, 각 경로를 트라이에 삽입합니다.
   - 트라이 구조를 출력하여 계층적 디렉토리 구조를 표시합니다.

## 코드 구현
```python
class TrieNode:
    def __init__(self):
        # 각 TrieNode는 자식 노드를 저장할 딕셔너리와 경로의 끝을 나타내는 플래그를 가진다.
        self.children = {}
        self.is_end_of_path = False

class Trie:
    def __init__(self):
        # Trie는 루트 노드를 가진다.
        self.root = TrieNode()

    def insert(self, path):
        # 주어진 경로를 트라이에 삽입하는 함수
        node = self.root
        # 경로를 '\' 기준으로 나눈다.
        parts = path.split("\\")
        for part in parts:
            # 자식 노드 중 현재 part가 없다면 새로운 노드를 추가
            if part not in node.children:
                node.children[part] = TrieNode()
            # 현재 노드를 자식 노드로 이동
            node = node.children[part]
        # 경로의 끝 부분 표시
        node.is_end_of_path = True

    def display(self, node=None, depth=0):
        # 트라이 구조를 출력하는 함수
        if node is None:
            # 초기 호출 시 루트 노드부터 시작
            node = self.root
        # 자식 노드들을 이름순으로 정렬하여 순회
        for key in sorted(node.children.keys()):
            # 현재 깊이만큼 공백을 추가하고 디렉토리 이름 출력
            print(" " * depth + key)
            # 재귀적으로 자식 노드들을 출력
            self.display(node.children[key], depth + 1)

if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    # 표준 입력으로부터 전체 데이터를 읽어온다.
    data = input().strip().split('\n')
    
    # 첫 번째 줄은 디렉토리 경로의 개수 N
    n = int(data[0])
    # 나머지 줄들은 디렉토리 경로
    paths = data[1:]
    
    # Trie 객체 생성
    trie = Trie()
    
    # 각 경로를 트라이에 삽입
    for path in paths:
        trie.insert(path)
    
    # 트라이 구조를 출력
    trie.display()
