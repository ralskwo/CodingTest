# 빗물 문제 풀이 및 설명

<https://www.acmicpc.net/problem/14719>

<https://mayquartet.com/python-백준-14719-빗물/>

## 문제 이해

이 문제는 블록들이 2차원 세계에 쌓여 있고, 그 위로 비가 왔을 때 블록 사이에 고이는 빗물의 양을 계산하는 문제입니다. 블록은 가로 방향으로 나열된 형태로 쌓여 있으며, 각 블록의 높이가 주어지기 때문에 빗물은 높은 블록 사이의 낮은 공간에 고이게 됩니다. 따라서, 각 위치마다 고일 수 있는 물의 양을 계산하여 총합을 구해야 합니다. 문제에서 주어진 정보에 따라 물이 고일 수 있는 위치는 블록의 양쪽에 더 높은 블록이 있는 경우이며, 물은 가장 낮은 부분에 쌓이게 됩니다.

고여 있는 물의 총량을 계산할 때는 각 위치에서 고일 수 있는 최대 높이를 결정하여야 하며, 이때 높이 제한을 받는 요소는 해당 위치의 왼쪽과 오른쪽에 있는 블록의 최대 높이입니다. 각 위치에서 왼쪽과 오른쪽 블록들 중 더 낮은 높이를 기준으로 그 높이까지 물이 고이게 되며, 고인 물의 높이는 해당 위치의 블록 높이보다 높을 수 없습니다.

## 입출력 조건

입력 조건은 다음과 같습니다.

1. 첫 번째 줄에 2차원 세계의 세로 길이 `H`와 가로 길이 `W`가 주어집니다. 여기서 `H`와 `W`는 각각 1 이상 500 이하의 값입니다.
2. 두 번째 줄에는 블록이 쌓인 높이를 의미하는 정수들이 가로 방향으로 나열된 형태로 주어집니다. 각 정수는 0 이상 `H` 이하이며, 블록이 없는 경우 0으로 표시됩니다.
3. 블록 내부에는 빈 공간이 없다고 가정하며, 2차원 세계의 바닥은 물이 고일 수 없도록 막혀 있습니다.

출력 조건은 다음과 같습니다.

- 고인 빗물의 총량을 출력합니다.
- 만약 빗물이 전혀 고이지 않는 경우 `0`을 출력합니다.

## 접근 방식

이 문제는 각 위치에서 빗물이 고일 수 있는 최대 높이를 계산하기 위해 **양쪽에서의 최대 높이를 비교하는 방식**을 사용해야 합니다. 구체적으로, **두 개의 보조 리스트**를 활용하여 각 위치에서의 **왼쪽과 오른쪽의 최대 높이**를 각각 기록한 후, 각 위치에서 가능한 물의 높이를 계산합니다. 이때 필요한 알고리즘적인 접근 방식은 다음과 같습니다.

1. `left_max` 리스트와 `right_max` 리스트를 생성하여 각 위치에서의 왼쪽 최대 높이와 오른쪽 최대 높이를 기록합니다. 이는 현재 위치에서 고일 수 있는 물의 높이가 왼쪽과 오른쪽 최대 높이에 의해 결정되기 때문입니다.
2. 각 위치에서 고일 수 있는 물의 양은 `left_max[i]`와 `right_max[i]`의 최소값에서 현재 위치의 블록 높이를 뺀 값이 됩니다. 이때 결과값이 양수일 경우에만 그 값을 빗물의 총량에 더해줍니다.
3. 시간 복잡도를 최소화하기 위해 각 리스트를 한 번의 반복문을 통해 왼쪽 최대 높이와 오른쪽 최대 높이를 각각 누적 계산합니다.

이 알고리즘은 **시간 복잡도 `O(W)`**로 수행할 수 있으며, 이는 문제의 최대 입력 크기에서도 효율적으로 동작합니다.

## 풀이 과정

1. `left_max`와 `right_max` 리스트를 생성합니다. 이 두 리스트는 각 위치의 왼쪽 및 오른쪽에서 가장 높은 블록 높이를 저장하는 역할을 합니다. 리스트는 가로 길이 `W`만큼 생성하고 0으로 초기화합니다.
2. 첫 번째 위치에서의 `left_max[0]` 값은 첫 번째 블록의 높이로 설정합니다. 이후 두 번째 위치부터는 현재 위치의 `left_max` 값을 이전 위치의 `left_max` 값과 현재 위치의 높이 중 큰 값으로 설정합니다. 이 과정을 반복하여, 각 위치에서 왼쪽의 최대 높이를 `left_max` 리스트에 누적 저장합니다.
3. 마지막 위치에서의 `right_max[W-1]` 값은 마지막 블록의 높이로 설정합니다. 이후 마지막에서 두 번째 위치부터 첫 번째 위치까지 역순으로 반복하며 현재 위치의 `right_max` 값을 다음 위치의 `right_max` 값과 현재 위치의 높이 중 큰 값으로 설정합니다. 이 과정을 반복하여 각 위치에서 오른쪽의 최대 높이를 `right_max` 리스트에 누적 저장합니다.
4. 모든 위치에서 고일 수 있는 빗물의 양을 계산하기 위해 `total_water` 변수를 0으로 초기화합니다. 각 위치 `i`에서 고일 수 있는 물의 양은 `min(left_max[i], right_max[i]) - heights[i]`로 계산합니다. 이 값이 양수일 경우에만 `total_water`에 더해줍니다.
5. 모든 위치를 검사한 후, `total_water`에 저장된 값을 최종적으로 반환하여 고일 수 있는 빗물의 총량을 계산합니다.

## 코드 구현

```python
def calculate_trapped_rainwater(H, W, heights):
    # 왼쪽 최대 높이를 저장할 리스트를 0으로 초기화하여 생성
    left_max = [0] * W
    # 오른쪽 최대 높이를 저장할 리스트를 0으로 초기화하여 생성
    right_max = [0] * W

    # 첫 번째 위치의 왼쪽 최대 높이는 그 위치의 높이로 설정
    left_max[0] = heights[0]
    # 두 번째 위치부터 끝까지 각 위치의 왼쪽 최대 높이를 계산
    for i in range(1, W):
        # 현재 위치의 왼쪽 최대 높이는 이전 위치의 최대 높이와 현재 높이 중 큰 값
        left_max[i] = max(left_max[i - 1], heights[i])

    # 마지막 위치의 오른쪽 최대 높이는 그 위치의 높이로 설정
    right_max[W - 1] = heights[W - 1]
    # 마지막에서 두 번째 위치부터 첫 번째 위치까지 각 위치의 오른쪽 최대 높이를 계산
    for i in range(W - 2, -1, -1):
        # 현재 위치의 오른쪽 최대 높이는 다음 위치의 최대 높이와 현재 높이 중 큰 값
        right_max[i] = max(right_max[i + 1], heights[i])

    # 총 고이는 빗물의 양을 저장할 변수를 0으로 초기화
    total_water = 0
    # 각 위치에서 고일 수 있는 물의 양을 계산
    for i in range(W):
        # 현재 위치에서 고일 수 있는 빗물의 양은 왼쪽과 오른쪽 최대 높이 중 작은 값에서 현재 높이를 뺀 값
        water = min(left_max[i], right_max[i]) - heights[i]
        # 만약 물의 양이 양수일 경우에만 총 빗물 양에 추가
        if water > 0:
            total_water += water

    # 최종적으로 고일 수 있는 빗물의 총량을 반환
    return total_water

# 첫 줄의 입력값을 받아 세로 길이(H)와 가로 길이(W)로 저장
H, W = map(int, input().split())
# 두 번째 줄의 입력값을 받아 각 위치의 높이를 리스트로 저장
heights = list(map(int, input().split()))
# 고인 빗물의 총량을 계산하고 결과를 출력
print(calculate_trapped_rainwater(H, W, heights))
```
