# 센서 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2212>

<https://mayquartet.com/python-백준-2212-센서/>

## 문제 이해

이 문제는 고속도로 위에 설치된 `센서`와 `집중국` 간의 수신 가능 영역을 최소화하는 문제입니다. 각 집중국은 센서들과 통신할 수 있는 구간(연결된 구간)을 설정할 수 있으며, 집중국의 개수가 제한되어 있습니다. 목표는 모든 센서가 적어도 하나의 집중국과 통신할 수 있도록 하면서, 모든 집중국의 수신 가능 영역 길이의 합을 최소화하는 것입니다.

센서의 위치는 정수 좌표로 제공되며, 고속도로는 1차원 직선으로 가정합니다. 각 센서와 집중국의 위치 관계를 고려하여 거리의 합을 최소화하는 방법을 찾아야 합니다.

문제는 "센서를 그룹화하여 각 그룹의 최대 간격 합을 최소화하는 방식"으로 풀이할 수 있습니다. 이때, 센서를 `K`개의 그룹으로 나눌 때 가장 큰 간격부터 제거하는 방식이 핵심입니다.

## 입출력 조건

### 입력 조건

1. 첫 번째 줄: 센서의 개수 `N` (1 ≤ `N` ≤ 10,000)
   - 센서의 개수는 최대 10,000개로, 이 문제는 효율적인 알고리즘이 필요합니다.
2. 두 번째 줄: 집중국의 개수 `K` (1 ≤ `K` ≤ 1,000)
   - 집중국은 최대 1,000개까지 설치할 수 있습니다. 이는 그룹으로 나눌 수 있는 센서 구간의 수를 의미합니다.
3. 세 번째 줄: 센서의 좌표를 나타내는 정수 `N`개
   - 각 센서의 좌표는 공백으로 구분되며, 좌표의 절댓값은 최대 1,000,000입니다.

### 출력 조건

1. 모든 센서를 적어도 하나의 집중국과 연결하면서, 집중국의 수신 가능 영역 길이의 최소 합을 출력해야 합니다.

## 접근 방식

이 문제를 해결하려면 **그리디 알고리즘**과 **정렬**을 사용해야 합니다. 전체적인 접근 방식은 다음과 같습니다.

1. **센서 좌표 정렬**  
   센서 좌표를 오름차순으로 정렬하면, 인접한 센서들 간의 거리를 계산하여 처리할 수 있습니다. 이렇게 하면 각 센서 사이의 간격을 구하는 것이 간단해집니다.

2. **거리 계산**  
   정렬된 센서 좌표를 이용해 인접한 두 센서 간의 거리(간격)를 계산합니다. 이 간격들은 전체 수신 가능 영역 길이를 최소화하기 위해 중요한 정보가 됩니다.

3. **큰 간격 제거**  
   집중국이 `K`개라면, `K - 1`개의 가장 큰 간격을 제거해야 합니다. 이렇게 하면 센서를 `K`개의 그룹으로 나눌 수 있고, 각 그룹은 하나의 집중국에 의해 커버됩니다. 이 방식은 거리 합을 최소화하는 데 유리합니다.

4. **최소 거리 합 계산**  
   제거된 간격을 제외한 나머지 간격들의 합을 계산하면, 각 집중국의 수신 가능 영역 길이의 합이 최소화됩니다.

<https://mayquartet.com/algorithm-알고리즘-greedy-그리디-알고리즘탐욕법-이해하기/>

## 풀이 과정

### 1. 센서 입력값 정렬

센서 좌표를 오름차순으로 정렬합니다. 이는 인접한 센서 간의 거리를 계산하기 위해 필요합니다.  
예를 들어, 입력값이 `[6, 2, 9, 4]`라면, 이를 `[2, 4, 6, 9]`로 정렬합니다.

### 2. 센서 간 거리 계산

정렬된 센서 배열에서 인접한 두 센서 간의 거리를 계산하여 리스트로 저장합니다.  
예를 들어, 정렬된 배열 `[2, 4, 6, 9]`에서 거리는 `[2, 2, 3]`이 됩니다.

### 3. 거리 내림차순 정렬

거리 리스트를 내림차순으로 정렬하여 큰 간격부터 처리할 수 있도록 합니다.  
예를 들어, 거리가 `[2, 2, 3]`이라면, 이를 `[3, 2, 2]`로 정렬합니다.

### 4. 큰 간격 제거

집중국이 `K`개일 경우, 가장 큰 `K - 1`개의 간격을 제거합니다.  
이는 센서를 `K`개의 그룹으로 나누는 작업과 같습니다.  
예를 들어, `K = 2`라면, 가장 큰 간격 하나를 제거하고 `[2, 2]`만 남깁니다.

### 5. 최소 거리 합 계산

남은 거리들의 합을 계산하여 출력합니다.  
예를 들어, 제거된 리스트 `[2, 2]`의 합은 `4`가 됩니다.

## 코드 구현

```python
def min_total_distance(N, K, sensors):
    # 집중국의 수가 센서의 개수 이상이면 모든 센서를 개별적으로 커버할 수 있으므로 거리 합은 0
    if K >= N:
        return 0

    # 센서 좌표를 오름차순으로 정렬하여 계산을 간단하게 만듦
    sensors.sort()

    # 인접한 센서들 간의 거리 차이를 저장할 리스트 생성
    distances = []
    for i in range(1, N):
        # 각 센서 간의 거리를 계산하여 distances 리스트에 추가
        distances.append(sensors[i] - sensors[i - 1])

    # 거리를 내림차순으로 정렬하여 가장 큰 간격부터 처리 가능하게 함
    distances.sort(reverse=True)

    # 집중국이 K개라면, 가장 큰 K-1개의 간격을 제거
    for _ in range(K - 1):
        distances.pop(0)

    # 남은 간격의 합을 반환하여 최종 최소 거리 합을 계산
    return sum(distances)


# 첫 번째 입력: 센서의 개수
N = int(input().strip())

# 두 번째 입력: 집중국의 개수
K = int(input().strip())

# 세 번째 입력: 센서의 좌표들
sensors = list(map(int, input().strip().split()))

# 최종 계산 결과를 출력
print(min_total_distance(N, K, sensors))
```
