# 청소년 상어 문제 풀이 및 설명

<https://www.acmicpc.net/problem/19236>

<https://mayquartet.com/python-파이썬-백준-19236-청소년-상어/>

## 문제 이해

이 문제는 4×4 크기의 공간에서 물고기와 상어가 이동하는 상황을 시뮬레이션하고, 상어가 먹을 수 있는 물고기 번호의 합의 최댓값을 계산하는 문제입니다. 공간은 각 칸이 (x, y)로 표현되며, 각 칸에는 물고기 한 마리가 있습니다. 물고기는 번호(1~16)와 방향을 가지며, 두 물고기가 동일한 번호를 가지지 않습니다. 방향은 8가지로, 상하좌우와 대각선 방향으로 나뉩니다.

상어는 (0, 0) 위치에 있는 물고기를 먹고 시작하며, 이때 상어의 방향은 먹은 물고기의 방향과 같아집니다. 이후 물고기가 이동하고, 상어가 이동하는 순서로 진행됩니다. 물고기는 이동할 수 있는 칸을 향할 때까지 반시계 방향으로 45도씩 회전하여 이동하며, 이동할 수 없는 경우에는 그 자리에 머무릅니다. 상어는 자신의 방향으로 여러 칸을 이동할 수 있으며, 물고기가 있는 칸으로 이동할 때 그 물고기를 먹고 그 방향을 이어받습니다. 이러한 과정에서 상어가 먹을 수 있는 물고기 번호의 합의 최댓값을 찾는 것이 목표입니다.

## 입출력 조건

- **입력**:
  - 첫째 줄부터 4개의 줄에 걸쳐 공간에 있는 물고기의 정보가 주어집니다. 각 줄은 8개의 정수로 이루어져 있으며, 각 칸에 있는 물고기의 번호와 방향을 나타냅니다.
  - 물고기의 번호 `a_i`는 1 이상 16 이하의 자연수입니다.
  - 방향 `b_i`는 1부터 8까지의 자연수로, 문제에서 제공된 순서대로 방향을 나타냅니다(1: ↑, 2: ↖, 3: ←, 4: ↙, 5: ↓, 6: ↘, 7: →, 8: ↗).
- **출력**:
  - 상어가 먹을 수 있는 물고기 번호의 합의 최댓값을 출력합니다.

## 접근 방식

- 이 문제는 시뮬레이션과 백트래킹을 결합한 문제로, 상어와 물고기의 이동을 재귀적으로 탐색하면서 가능한 모든 경우를 시뮬레이션해야 합니다.
- **DFS(깊이 우선 탐색)**과 **상태 저장**을 이용하여 상어가 이동할 수 있는 모든 경로를 탐색합니다.
  - 상어가 특정 칸에 있는 물고기를 먹고 이동할 때마다 현재의 공간 상태를 저장하고, 물고기의 이동이 끝난 후에 다음 상어의 이동을 처리합니다.
  - 이를 통해 상어가 가능한 모든 이동 경로를 탐색하면서 최댓값을 찾아나갈 수 있습니다.
- **재귀와 깊은 복사**:
  - 상어가 이동한 후 상태를 다시 저장하여 원래 상태로 복구하기 위해 `copy.deepcopy`를 사용합니다. 이를 통해 공간 상태를 보존하고, 재귀적으로 다른 이동 경로를 시도할 수 있습니다.
- **시뮬레이션 구현**:
  - 물고기의 이동 규칙과 상어의 이동 규칙을 충실히 코드로 구현해야 합니다. 물고기는 이동할 수 있는 방향을 찾기 위해 회전하며, 상어는 물고기가 있는 칸으로만 이동할 수 있습니다.

<https://mayquartet.com/algorithm-알고리즘-dfs-깊이-우선-탐색-알고리즘-이해하기/>

## 풀이 과정

1. **입력 처리 및 초기 상태 설정**:

   - 4×4 크기의 공간을 입력받아 각 칸에 물고기의 번호와 방향을 저장합니다.
   - 입력으로 들어오는 방향 값은 1부터 8까지이지만, 코드에서 편리하게 사용하기 위해 0부터 시작하도록 조정합니다.
   - 상어는 (0, 0)에 위치한 물고기를 먹고 시작하며, 이때 상어의 방향은 해당 물고기의 방향으로 설정됩니다.

2. **물고기 이동 구현**:

   - 각 물고기를 1번부터 16번까지 순서대로 이동시킵니다.
   - 물고기는 현재 방향을 기준으로 이동할 수 있는 칸을 찾으며, 이동할 수 없다면 45도씩 반시계 방향으로 회전하여 이동할 수 있는 방향을 찾습니다.
   - 이동할 수 있는 칸은 빈 칸이거나 다른 물고기가 있는 칸이며, 상어가 있는 칸으로는 이동할 수 없습니다.
   - 물고기가 이동할 때는 이동하려는 위치의 물고기와 현재 물고기의 위치를 서로 바꿉니다.

3. **상어 이동 및 재귀적 탐색**:

   - 상어는 현재 위치에서 여러 칸까지 이동할 수 있습니다. 상어는 자신의 방향으로 물고기가 있는 칸을 향해 1칸, 2칸, 3칸 등 최대 3칸까지 이동할 수 있습니다.
   - 상어가 이동할 수 있는 위치에 물고기가 있다면, 해당 물고기를 먹고 그 물고기의 방향을 이어받아 이동합니다.
   - 상어가 먹을 수 있는 모든 위치에 대해 `dfs`를 재귀적으로 호출하며, 각 호출마다 상어가 먹은 물고기 번호의 합을 계산합니다.
   - 이 과정에서 상어가 먹은 물고기 번호의 합의 최댓값을 추적하여 `answer` 변수를 갱신합니다.

4. **재귀 호출과 깊은 복사**:

   - `dfs` 함수가 호출될 때마다 현재 상태를 깊은 복사하여, 상어의 이동 및 물고기의 이동에 따른 공간의 변화를 기록합니다.
   - 깊은 복사를 통해 상어가 다른 경로를 탐색할 때 이전 상태로 돌아갈 수 있어, 다양한 경로를 시도해 볼 수 있습니다.
   - 상어가 특정 위치에서 물고기를 먹고 이동한 후, 다시 이전 상태로 돌아와 다른 경로를 시도할 수 있도록 합니다.

5. **최댓값 출력**:
   - 상어가 가능한 모든 경로를 탐색한 후, `answer` 변수에는 상어가 먹을 수 있는 물고기 번호의 합의 최댓값이 저장됩니다.
   - 최종적으로 `answer`를 출력하여 문제의 요구사항을 만족하는 결과를 반환합니다.

## 코드 구현

```python
import copy  # 공간의 상태를 복사하기 위해 copy 모듈을 사용

# 8방향에 대한 이동 좌표 (↑, ↖, ←, ↙, ↓, ↘, →, ↗ 순서)
dx = [-1, -1, 0, 1, 1, 1, 0, -1]  # x 좌표 변화량
dy = [0, -1, -1, -1, 0, 1, 1, 1]  # y 좌표 변화량

# 물고기를 이동시키는 함수
def move_fish(space, shark_x, shark_y):
    # 물고기 번호 1부터 16까지 순서대로 이동
    for i in range(1, 17):
        fish_x, fish_y = -1, -1  # 물고기의 현재 위치를 저장할 변수
        # 공간을 탐색하여 현재 물고기의 위치를 찾음
        for x in range(4):
            for y in range(4):
                if space[x][y][0] == i:
                    fish_x, fish_y = x, y
                    break
            if fish_x != -1:
                break

        # 물고기가 이미 먹혀서 공간에 없을 경우 건너뜀
        if fish_x == -1:
            continue

        fish_dir = space[fish_x][fish_y][1]  # 물고기의 현재 방향

        # 8방향을 시계 방향으로 회전하며 이동할 수 있는 위치를 찾음
        for _ in range(8):
            nx, ny = fish_x + dx[fish_dir], fish_y + dy[fish_dir]  # 이동할 위치 계산
            # 이동할 위치가 공간 안에 있고, 상어의 위치가 아닐 때 이동
            if 0 <= nx < 4 and 0 <= ny < 4 and (nx, ny) != (shark_x, shark_y):
                # 이동할 수 있는 방향으로 물고기의 방향을 업데이트
                space[fish_x][fish_y][1] = fish_dir
                # 물고기가 이동할 위치에 있는 물고기와 위치를 바꿈
                space[fish_x][fish_y], space[nx][ny] = space[nx][ny], space[fish_x][fish_y]
                break
            # 이동할 수 없는 경우 45도 반시계 회전
            fish_dir = (fish_dir + 1) % 8

# 깊이 우선 탐색(DFS) 함수
def dfs(space, shark_x, shark_y, total):
    global answer  # 최댓값을 저장할 전역 변수
    space = copy.deepcopy(space)  # 공간의 상태를 복사하여 재귀 호출 간 상태 유지

    # 상어가 현재 위치의 물고기를 먹고 해당 물고기의 번호와 방향을 얻음
    number = space[shark_x][shark_y][0]
    direction = space[shark_x][shark_y][1]
    space[shark_x][shark_y][0] = -1  # 물고기를 먹은 자리를 빈칸으로 표시

    total += number  # 현재까지 먹은 물고기 번호의 합에 현재 물고기 번호를 추가
    answer = max(answer, total)  # 최댓값 갱신

    # 물고기 이동 처리
    move_fish(space, shark_x, shark_y)

    # 상어가 현재 방향으로 이동할 수 있는 모든 경우를 탐색
    for i in range(1, 4):  # 1, 2, 3 칸까지 이동 가능
        nx, ny = shark_x + dx[direction] * i, shark_y + dy[direction] * i  # 다음 위치 계산
        # 이동할 위치가 공간 내에 있고, 물고기가 있는 위치일 때만 이동
        if 0 <= nx < 4 and 0 <= ny < 4 and space[nx][ny][0] > 0:
            # 재귀적으로 상어를 이동시켜 새로운 상태에서 탐색 진행
            dfs(space, nx, ny, total)

# 4x4 공간을 초기화하고 입력을 받아 저장
space = [[] for _ in range(4)]  # 각 칸에 물고기의 번호와 방향 저장
for i in range(4):
    row = list(map(int, input().split()))  # 한 줄씩 입력받아 물고기 번호와 방향으로 분리
    for j in range(4):
        space[i].append([row[j*2], row[j*2+1]-1])  # 물고기 번호와 방향을 저장 (방향은 0부터 시작하도록 조정)

answer = 0  # 상어가 먹을 수 있는 물고기 번호의 합의 최댓값을 저장할 변수
dfs(space, 0, 0, 0)  # DFS 탐색 시작 (상어는 (0, 0)에서 시작)
print(answer)  # 최댓값 출력
```
