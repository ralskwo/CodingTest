# 달빛 여우 문제 풀이 및 설명

https://www.acmicpc.net/problem/16118

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-16118-%eb%8b%ac%eb%b9%9b-%ec%97%ac%ec%9a%b0-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 그래프 이론을 기반으로 하는 최단 경로 문제입니다. 달빛 여우와 달빛 늑대는 관악산에 있는 여러 그루터기 중에서 특정 그루터기에 가장 먼저 도착하려고 합니다. 달빛 여우는 항상 일정한 속도로 이동하지만, 달빛 늑대는 첫 번째 오솔길을 빠르게 달린 후, 다음 오솔길을 느리게 걸어가며 체력을 회복한 후 다시 빠르게 달리는 방식으로 이동합니다. 이 문제에서는 주어진 오솔길 정보와 달빛 여우와 달빛 늑대의 이동 방식에 따라, 달빛 여우가 달빛 늑대보다 먼저 도착할 수 있는 그루터기의 개수를 계산하는 것이 목표입니다.

문제를 이해하는 중요한 포인트는 두 캐릭터의 이동 방식의 차이를 명확히 파악하는 것입니다. 특히, 달빛 늑대는 번갈아가며 속도를 다르게 하는 특수한 이동 패턴을 사용하기 때문에, 이를 어떻게 효과적으로 모델링할지가 문제 해결의 핵심입니다.

## 입출력 조건

**입력:**

- 첫 번째 줄에 나무 그루터기의 개수 `N`과 오솔길의 개수 `M`이 주어집니다. (2 ≤ N ≤ 4,000, 1 ≤ M ≤ 100,000)
- 다음 `M`개의 줄에는 각 오솔길에 대한 정보가 주어집니다. 각 줄은 세 개의 정수 `a`, `b`, `d`로 구성되며, 이는 `a번 그루터기`와 `b번 그루터기` 사이에 길이가 `d`인 오솔길이 있다는 의미입니다. (1 ≤ a, b ≤ N, a ≠ b, 1 ≤ d ≤ 100,000)

**출력:**

- 달빛 여우가 달빛 늑대보다 먼저 도착할 수 있는 그루터기의 개수를 출력합니다.

## 접근 방식

이 문제를 해결하기 위해서는 그래프 탐색 알고리즘 중 하나인 다익스트라 알고리즘을 사용해야 합니다. 다익스트라 알고리즘은 가중 그래프에서 하나의 출발점으로부터 다른 모든 정점까지의 최단 거리를 계산하는 데 매우 유용합니다.

우선 달빛 여우의 경우, 항상 일정한 속도로 이동하기 때문에 일반적인 다익스트라 알고리즘을 그대로 사용할 수 있습니다. 반면, 달빛 늑대는 번갈아가며 두 가지 다른 속도로 이동하기 때문에, 이를 고려하여 다익스트라 알고리즘을 변형해서 적용해야 합니다. 구체적으로, 달빛 늑대가 어떤 그루터기에 도착했을 때 두 가지 상태(빠르게 이동한 상태와 느리게 이동한 상태)를 따로 관리하여 최단 거리를 계산해야 합니다.

## 풀이 과정

1. **그래프 초기화:**

   - 주어진 `N`과 `M`을 기반으로 그루터기와 오솔길을 표현하는 인접 리스트를 생성합니다. 이는 각 그루터기에서 연결된 다른 그루터기와 오솔길의 길이를 저장하는 자료구조입니다.

2. **달빛 여우의 최단 거리 계산:**

   - 달빛 여우의 경우, 일반적인 다익스트라 알고리즘을 적용하여 각 그루터기까지의 최단 거리를 계산합니다. 시작점(1번 그루터기)에서 출발하여 각 그루터기에 대해 최단 거리를 업데이트합니다.

3. **달빛 늑대의 최단 거리 계산:**

   - 달빛 늑대는 두 가지 상태를 번갈아 가며 이동하므로, 두 가지 상태에 대해 별도로 최단 거리를 계산합니다. 이를 위해 다익스트라 알고리즘을 변형하여 사용합니다. 초기에는 빠르게 이동하는 상태로 시작하여, 인접한 그루터기에 대해 느리게 이동하는 상태로 전환하면서 최단 거리를 계산합니다.
   - 각 그루터기마다 두 가지 상태에서의 최단 거리를 저장해야 하므로, 2차원 리스트를 사용하여 거리 정보를 관리합니다.

4. **여우가 더 빨리 도착할 수 있는 그루터기의 수 계산:**

   - 모든 그루터기에 대해 달빛 여우와 달빛 늑대의 최단 거리를 비교합니다. 달빛 여우의 최단 거리가 달빛 늑대의 두 가지 상태 중 작은 값보다 짧으면, 그루터기에서 달빛 여우가 먼저 도착할 수 있다고 판단하여 카운트를 증가시킵니다.

5. **결과 출력:**
   - 최종적으로 달빛 여우가 더 빨리 도착할 수 있는 그루터기의 개수를 출력합니다.

## 코드 구현

```python
import heapq  # 우선순위 큐를 사용하기 위해 heapq 모듈을 가져옵니다.
import sys  # 입력 속도를 빠르게 하기 위해 sys 모듈을 가져옵니다.
input = sys.stdin.readline  # 빠른 입력을 위해 sys.stdin.readline을 사용합니다.
INF = float('inf')  # 무한대를 나타내기 위해 INF를 정의합니다.

def dijkstra_fox(n, adj):
    dist = [INF] * (n + 1)  # 각 그루터기까지의 최단 거리를 저장할 배열을 초기화합니다.
    dist[1] = 0  # 시작점인 1번 그루터기의 거리는 0으로 설정합니다.
    pq = [(0, 1)]  # 우선순위 큐에 (거리, 그루터기 번호) 형식으로 초기 상태를 추가합니다.

    while pq:  # 우선순위 큐가 빌 때까지 반복합니다.
        current_dist, u = heapq.heappop(pq)  # 가장 작은 거리를 가진 그루터기를 꺼냅니다.
        if current_dist > dist[u]:  # 이미 처리된 거리보다 크다면 무시합니다.
            continue
        for v, length in adj[u]:  # 현재 그루터기 u와 연결된 모든 인접 그루터기를 탐색합니다.
            new_dist = current_dist + length  # 새로운 경로의 거리를 계산합니다.
            if new_dist < dist[v]:  # 계산된 거리가 기존 거리보다 짧다면 갱신합니다.
                dist[v] = new_dist
                heapq.heappush(pq, (new_dist, v))  # 갱신된 거리를 우선순위 큐에 추가합니다.

    return dist  # 모든 그루터기에 대한 최단 거리를 반환합니다.

def dijkstra_wolf(n, adj):
    dist = [[INF, INF] for _ in range(n + 1)]  # 늑대의 두 가지 상태에 따른 최단 거리를 저장할 배열을 초기화합니다.
    dist[1][0] = 0  # 시작점에서 빠르게 출발하는 상태의 거리는 0으로 설정합니다.
    pq = [(0, 1, 0)]  # 우선순위 큐에 (거리, 그루터기 번호, 현재 속도 상태) 형식으로 초기 상태를 추가합니다.

    while pq:  # 우선순위 큐가 빌 때까지 반복합니다.
        current_dist, u, speed_state = heapq.heappop(pq)  # 가장 작은 거리를 가진 상태를 꺼냅니다.
        if current_dist > dist[u][speed_state]:  # 이미 처리된 거리보다 크다면 무시합니다.
            continue
        for v, length in adj[u]:  # 현재 그루터기 u와 연결된 모든 인접 그루터기를 탐색합니다.
            if speed_state == 0:  # 현재 상태가 빠르게 이동하는 상태인 경우
                new_dist = current_dist + length / 2  # 새로운 거리를 계산(절반 속도로 이동)
                if new_dist < dist[v][1]:  # 느리게 이동하는 상태에서의 거리와 비교하여 갱신
                    dist[v][1] = new_dist
                    heapq.heappush(pq, (new_dist, v, 1))  # 갱신된 거리를 우선순위 큐에 추가합니다.
            else:  # 현재 상태가 느리게 이동하는 상태인 경우
                new_dist = current_dist + length * 2  # 새로운 거리를 계산(두 배 속도로 이동)
                if new_dist < dist[v][0]:  # 빠르게 이동하는 상태에서의 거리와 비교하여 갱신
                    dist[v][0] = new_dist
                    heapq.heappush(pq, (new_dist, v, 0))  # 갱신된 거리를 우선순위 큐에 추가합니다.

    return dist  # 모든 그루터기에 대한 늑대의 두 가지 상태에서의 최단 거리를 반환합니다.

def count_fox_faster(n, dist_fox, dist_wolf):
    count = 0  # 여우가 더 빨리 도착할 수 있는 그루터기의 수를 세기 위한 변수를 초기화합니다.
    for i in range(2, n + 1):  # 2번 그루터기부터 n번 그루터기까지 순회합니다.
        if dist_fox[i] < min(dist_wolf[i][0], dist_wolf[i][1]):  # 여우의 최단 거리가 늑대의 두 상태에서의 최단 거리보다 짧다면
            count += 1  # 해당 그루터기를 카운트합니다.
    return count  # 최종적으로 카운트된 그루터기의 수를 반환합니다.

def main():
    n, m = map(int, input().split())  # 그루터기의 개수와 오솔길의 개수를 입력받습니다.
    adj = [[] for _ in range(n + 1)]  # 인접 리스트를 초기화합니다.

    for _ in range(m):
        a, b, d = map(int, input().split())  # 각 오솔길의 정보를 입력받습니다.
        adj[a].append((b, d))  # 그루터기 a에서 b로 가는 오솔길을 추가합니다.
        adj[b].append((a, d))  # 그루터기 b에서 a로 가는 오솔길을 추가합니다 (양방향).

    dist_fox = dijkstra_fox(n, adj)  # 여우의 최단 거리를 계산합니다.
    dist_wolf = dijkstra_wolf(n, adj)  # 늑대의 최단 거리를 계산합니다.
    result = count_fox_faster(n, dist_fox, dist_wolf)  # 여우가 더 빨리 도착할 수 있는 그루터기의 수를 계산합니다.

    print(result)  # 계산된 결과를 출력합니다.

if __name__ == "__main__":
    main()  # 메인 함수 호출을 통해 프로그램을 실행합니다.
```
