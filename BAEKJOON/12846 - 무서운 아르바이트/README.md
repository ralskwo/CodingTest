# 무서운 아르바이트 문제 풀이 및 설명

<https://www.acmicpc.net/problem/12846>

<https://mayquartet.com/python-파이썬-백준-12846-무서운-아르바이트-문제-풀이-및-설/>

## 문제 이해

이 문제는 성화라는 편의점 사장 아래서 준수가 일할 때 벌 수 있는 최대 이익을 구하는 문제입니다. 성화의 편의점에서는 퇴사할 때 일한 기간 동안의 급여를 한 번에 받으며, 그 급여는 일한 기간 동안의 가장 낮은 일급을 기준으로 계산됩니다. 따라서 준수는 일한 기간 동안 최저 일급이 높은 구간을 찾아서 최대 이익을 얻어야 합니다.

예를 들어, 5일 동안의 일급이 `[10, 20, 30, 20, 10]`이라면, 준수가 1일부터 5일까지 모두 일했을 때 얻는 급여는 최소 일급인 10을 기준으로 계산되어 `10 * 5 = 50`이 됩니다. 하지만 2일부터 4일까지 일했을 때의 최소 일급은 20이므로 이 경우에는 `20 * 3 = 60`으로 더 높은 이익을 얻을 수 있습니다. 따라서 준수는 연속적인 구간을 선택할 때 항상 "최소 일급"을 기준으로 전체 이익을 계산해야 합니다.

이 문제의 핵심은 **연속된 구간을 선택했을 때 최소 일급을 기준으로 최대 이익을 계산**하는 것입니다. 모든 구간을 완전 탐색으로 처리할 경우 시간 복잡도가 `O(n^2)` 이상이 되어 비효율적이므로, **효율적인 방법**으로 구간을 처리해야 합니다.

## 입출력 조건

### 입력

1. 첫 번째 줄에는 일할 수 있는 날의 수 `n`이 주어집니다. (`0 < n ≤ 100,000`)
2. 두 번째 줄에는 1일부터 n일까지의 일급 `Ti`가 순서대로 주어집니다. (`0 < Ti ≤ 1,000,000`)

### 출력

1. 준수가 일을 해서 벌 수 있는 최대 이익을 출력합니다.

## 접근 방식

이 문제는 `스택을 이용한 구간 최소값 계산` 방식을 사용하여 해결할 수 있습니다. 연속된 구간에서 최소 일급을 기준으로 최대 이익을 구하는 문제는 모든 구간을 반복적으로 확인하는 완전 탐색 방식으로는 비효율적입니다. 따라서 이 문제를 해결하기 위해 다음과 같은 접근 방식을 사용해야 합니다.

1. **스택을 이용한 왼쪽, 오른쪽 확장 가능한 최대 범위 찾기**:

   - 특정 날의 일급을 기준으로 왼쪽 또는 오른쪽으로 확장할 수 있는 최대 범위를 구합니다.
   - 확장 가능한 범위는 해당 날의 일급보다 작은 일급이 나타날 때까지 확장 가능합니다.
   - 스택 자료구조를 사용하여 각 날의 일급에 대해 확장 가능한 범위를 효율적으로 찾을 수 있습니다.

2. **최대 이익 계산**:
   - 각 날의 일급을 기준으로 해당 일급이 구간의 최소 일급이 되는 최대 구간을 찾아야 합니다.
   - 이를 위해 각 날의 왼쪽 및 오른쪽으로 확장할 수 있는 최대 범위를 계산하고, 해당 범위 내에서 얻을 수 있는 이익을 계산합니다.
   - 최종적으로 각 날에 대해 계산한 이익 중 가장 큰 값을 반환합니다.

이러한 방식은 스택을 사용하여 각 날의 확장 가능한 범위를 `O(n)`의 시간 복잡도로 계산할 수 있어, 전체 알고리즘의 시간 복잡도는 `O(n)`이 됩니다.

## 풀이 과정

1. **왼쪽으로 확장 가능한 최대 범위 찾기**:

   - 왼쪽으로 확장 가능한 최대 범위를 찾기 위해 스택을 사용합니다.
   - 배열 `left`를 생성하여 각 날에 대해 왼쪽으로 확장 가능한 최대 범위를 저장합니다.
   - 스택에 현재 일급의 인덱스를 추가하고, 이전 일급이 현재 일급보다 크거나 같은 경우 스택에서 제거합니다. 이 과정을 통해 왼쪽으로 확장 가능한 최대 범위를 결정합니다.
   - 스택이 비어있다면, 현재 위치에서 왼쪽으로 확장할 수 있는 범위는 0이 됩니다.

2. **오른쪽으로 확장 가능한 최대 범위 찾기**:

   - 오른쪽으로 확장 가능한 최대 범위를 찾기 위해 동일하게 스택을 사용합니다.
   - 배열 `right`를 생성하여 각 날에 대해 오른쪽으로 확장 가능한 최대 범위를 저장합니다.
   - 스택에 현재 일급의 인덱스를 추가하고, 이전 일급이 현재 일급보다 크거나 같은 경우 스택에서 제거합니다. 이 과정을 통해 오른쪽으로 확장 가능한 최대 범위를 결정합니다.
   - 스택이 비어있다면, 현재 위치에서 오른쪽으로 확장할 수 있는 범위는 `n-1`이 됩니다.

3. **각 날을 기준으로 최대 이익 계산**:

   - 각 날의 일급을 기준으로 해당 일급이 최소 일급이 되는 최대 구간의 이익을 계산합니다.
   - 이익은 `wages[i] * (right[i] - left[i] + 1)`로 계산되며, `right[i] - left[i] + 1`은 해당 구간의 길이(일수)를 의미합니다.
   - 각 날에 대해 계산된 이익 중 가장 큰 값을 `max_profit` 변수에 저장하고, 최종적으로 반환합니다.

4. **입력 처리 및 함수 호출**:
   - 입력으로 주어진 일할 수 있는 날의 수 `n`과 n일 동안의 일급 정보를 리스트 형태로 입력받습니다.
   - `max_profit` 함수를 호출하여 최대 이익을 계산하고, 그 결과를 출력합니다.

## 코드 구현

```python
def max_profit(n, wages):  # 최대 이익을 계산하는 함수
    left = [0] * n  # 각 일에 대해 왼쪽으로 확장 가능한 최대 범위를 저장하는 배열 초기화
    right = [0] * n  # 각 일에 대해 오른쪽으로 확장 가능한 최대 범위를 저장하는 배열 초기화
    stack = []  # 현재 일급을 기준으로 왼쪽 범위를 찾기 위한 스택

    for i in range(n):  # 0부터 n-1일까지 각 날에 대해 반복
        while stack and wages[stack[-1]] >= wages[i]:  # 스택의 마지막 값보다 현재 일급이 작거나 같으면
            stack.pop()  # 스택에서 제거 (왼쪽 확장 불가능한 범위)
        if stack:  # 스택이 비어있지 않으면
            left[i] = stack[-1] + 1  # 현재 위치에서 왼쪽으로 확장 가능한 범위 설정
        else:  # 스택이 비어있으면
            left[i] = 0  # 현재 위치에서 왼쪽으로 더 이상 확장 불가, 시작 지점이 0
        stack.append(i)  # 현재 위치를 스택에 추가

    stack = []  # 오른쪽 범위를 계산하기 위해 스택 초기화

    for i in range(n - 1, -1, -1):  # n-1부터 0까지 각 날에 대해 반복 (오른쪽 방향으로 탐색)
        while stack and wages[stack[-1]] >= wages[i]:  # 스택의 마지막 값보다 현재 일급이 작거나 같으면
            stack.pop()  # 스택에서 제거 (오른쪽 확장 불가능한 범위)
        if stack:  # 스택이 비어있지 않으면
            right[i] = stack[-1] - 1  # 현재 위치에서 오른쪽으로 확장 가능한 범위 설정
        else:  # 스택이 비어있으면
            right[i] = n - 1  # 현재 위치에서 오른쪽으로 더 이상 확장 불가, 끝 지점이 n-1
        stack.append(i)  # 현재 위치를 스택에 추가

    max_profit = 0  # 최대 이익을 저장할 변수 초기화
    for i in range(n):  # 0부터 n-1까지 각 날에 대해 반복
        current_profit = wages[i] * (right[i] - left[i] + 1)  # 현재 일급을 기준으로 가능한 최대 이익 계산
        max_profit = max(max_profit, current_profit)  # 현재 최대 이익과 비교하여 더 큰 값으로 갱신

    return max_profit  # 최대 이익 반환

n = int(input().strip())  # 일을 할 수 있는 날의 수 입력 받기
wages = list(map(int, input().strip().split()))  # n일 동안의 일급 정보를 리스트로 입력 받기

print(max_profit(n, wages))  # 최대 이익을 계산하여 출력
```
