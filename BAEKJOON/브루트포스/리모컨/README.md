# 리모컨 문제 풀이 및 설명

https://www.acmicpc.net/problem/1107

## 문제 이해

이 문제는 현재 채널(100)에서 목표 채널 \( N \)으로 이동하기 위해 필요한 최소 버튼 누름 횟수를 구하는 것입니다. 문제의 복잡성은 리모컨의 일부 숫자 버튼이 고장나서 특정 채널을 직접 입력할 수 없다는 점에서 발생합니다. 또한 "+" 및 "-" 버튼을 사용하여 채널 번호를 증가하거나 감소시킬 수 있는 옵션이 있습니다. 주어진 제약 조건에서 채널 \( N \)에 도달하는 가장 효율적인 방법을 찾는 것이 목표입니다.

## 입출력 조건

- **입력:**
  - 목표 채널 \( N \) (0 ≤ \( N \) ≤ 500,000).
  - 고장난 버튼의 수 \( M \) (0 ≤ \( M \) ≤ 10).
  - \( M > 0 \)인 경우, 고장난 버튼의 목록이 주어집니다.

- **출력:**
  - 채널 100에서 채널 \( N \)으로 이동하기 위해 필요한 최소 버튼 누름 횟수.

## 접근 방법

이 문제를 해결하기 위해서는 채널 범위가 비교적 작고 버튼 수가 제한적이므로 브루트 포스 알고리즘이 적합합니다. 해결 방법은 사용할 수 있는(고장나지 않은) 버튼을 사용하여 입력할 수 있는 모든 가능한 채널을 확인하는 것입니다. 각 유효 채널에 대해 직접 입력과 "+" 또는 "-" 버튼 사용을 고려하여 필요한 버튼 누름 횟수를 계산합니다. 모든 가능성 중에서 최소 누름 횟수가 원하는 솔루션입니다.

## 풀이 과정

1. **가장 간단한 경우 식별:**
   - "+" 및 "-" 버튼만 사용하여 채널 100에서 \( N \)으로 이동하는 경우 최소 버튼 누름 횟수를 계산합니다. 이는 100과 \( N \)의 절대 차이입니다.

2. **모든 가능한 채널 확인:**
   - 0부터 999,999까지의 모든 가능한 채널을 반복합니다. 이 범위는 \( N \)에 가장 가까운 유효 채널이 멀리 떨어져 있을 때와 같은 극단적인 경우를 포함하여 모든 경우를 다룹니다.

3. **각 채널 유효성 검사:**
   - 각 채널이 고장나지 않은 버튼을 사용하여 입력할 수 있는지 확인합니다. 이를 위해 채널 번호를 문자열로 변환한 후 해당 숫자 중 하나라도 고장난 버튼에 포함되어 있는지 확인합니다.

4. **버튼 누름 횟수 계산 및 비교:**
   - 유효한 각 채널에 대해 필요한 전체 버튼 누름 횟수를 계산합니다. 여기에는 채널을 입력하는 데 필요한 버튼 누름 횟수(채널의 숫자 수)와 이 채널에서 "+" 및 "-" 버튼을 사용하여 \( N \)으로 조정하는 데 필요한 버튼 누름 횟수가 포함됩니다.
   - 반복 중에 발견된 최소 버튼 누름 횟수를 기록합니다.

5. **결과 출력:**
   - 모든 가능한 채널을 반복한 후, 발견된 최소 버튼 누름 횟수가 솔루션입니다. 이 값을 최종 결과로 출력합니다.

## 코드 구현
```python
def is_possible(channel, broken_buttons):  # 특정 채널을 고장난 버튼을 사용하지 않고 입력할 수 있는지 확인하는 함수
    for ch in str(channel):  # 채널의 각 숫자를 순회
        if int(ch) in broken_buttons:  # 만약 그 숫자가 고장난 버튼 중 하나라면
            return False  # 그 채널은 입력할 수 없으므로 False 반환
    return True  # 고장난 버튼 없이 입력할 수 있으면 True 반환

def min_button_presses(N, broken_buttons):  # 최소 버튼 클릭 수를 계산하는 함수
    min_presses = abs(N - 100)  # 초기값: 100번 채널에서 N번 채널로 이동할 때 +,- 버튼만 사용하는 경우

    for channel in range(1000000):  # 0부터 999,999까지의 채널을 순회
        if is_possible(channel, broken_buttons):  # 해당 채널을 입력할 수 있는지 확인
            presses = len(str(channel)) + abs(N - channel)  # 채널을 입력하는 버튼 수 + 해당 채널에서 N으로 이동하는 +,- 버튼 수
            min_presses = min(min_presses, presses)  # 최소 버튼 수를 갱신

    return min_presses  # 최소 버튼 클릭 수 반환

N = int(input())  # 이동하려는 채널 N 입력
M = int(input())  # 고장난 버튼의 수 M 입력

if M > 0:  # 만약 고장난 버튼이 있으면
    broken_buttons = list(map(int, input().split()))  # 고장난 버튼 리스트 입력
else:  # 고장난 버튼이 없으면
    broken_buttons = []  # 빈 리스트 할당

print(min_button_presses(N, broken_buttons))  # 최소 버튼 클릭 수 출력
