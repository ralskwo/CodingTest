# 0 만들기 문제 풀이 및 설명

<https://www.acmicpc.net/problem/7490>

<https://mayquartet.com/python-백준-7490-0-만들기/>

## 문제 이해

이 문제는 주어진 자연수 `N`에 대해 1부터 `N`까지의 숫자를 나열한 수열에서 숫자들 사이에 `+`, `-`, 혹은 공백을 삽입하여 계산한 결과가 0이 되는 모든 수식을 찾아내는 것입니다. 예를 들어 `N = 3`일 경우, 수열 `1 2 3` 사이에 연산자를 조합하여 결과가 0이 되는 수식을 만들어야 합니다.

핵심은 세 가지 연산자의 사용입니다:

- `+`는 더하기 연산자로 두 숫자를 더합니다.
- `-`는 빼기 연산자로 두 숫자를 뺍니다.
- 공백(` `)은 두 숫자를 이어붙이는 역할을 합니다. 예를 들어 `1`과 `2` 사이에 공백을 넣으면 `12`라는 숫자로 처리됩니다.

모든 가능한 조합을 고려해야 하며, 결과가 0이 되는 수식만을 출력해야 합니다.

## 입출력 조건

### 입력 조건

- 첫 줄에는 테스트 케이스의 개수 `T`가 주어집니다. `T`는 10보다 작습니다.
- 그다음 `T`줄에 걸쳐 각 테스트 케이스마다 하나의 자연수 `N`이 주어집니다. `N`은 3 이상 9 이하입니다.

### 출력 조건

- 각 테스트 케이스마다 가능한 모든 수식을 ASCII 순서로 출력합니다.
- 각 테스트 케이스의 결과는 빈 줄로 구분합니다.
- 출력되는 수식은 반드시 공백을 포함한 원래의 형태를 유지해야 합니다.

## 접근 방식

이 문제는 모든 가능한 연산자 조합을 생성해야 하므로 **백트래킹(Backtracking)** 기법을 사용해야 합니다. 백트래킹은 재귀를 통해 가능한 모든 조합을 탐색하고, 조건을 만족하는 경우에만 결과를 저장합니다.

구체적인 접근 방식은 다음과 같습니다:

1. 숫자 `1`로 시작하여 가능한 연산자를 추가하면서 다음 숫자로 진행합니다.
2. 연산자를 추가할 때마다 현재까지의 수식을 문자열 형태로 저장합니다.
3. 수식의 길이가 완성되면(즉, 모든 숫자가 포함되면) 공백을 제거하고 계산 결과를 확인합니다.
4. 계산 결과가 0이면 결과 리스트에 추가합니다.
5. 모든 연산자를 탐색한 후 결과를 정렬하여 출력합니다.

이 과정에서 재귀 호출을 이용하여 모든 경우를 탐색하되, 조건을 만족하지 않으면 더 깊은 탐색을 중단합니다.

<https://mayquartet.com/algorithm-알고리즘-backtracking-백트래킹-알고리즘-이해하기/>

## 풀이 과정

1. **입력 처리**

   - 먼저 테스트 케이스의 개수를 입력받고, 각 테스트 케이스에 대해 `N` 값을 리스트로 저장합니다.
   - 이후 각 테스트 케이스를 반복적으로 처리합니다.

2. **백트래킹 함수 정의**

   - 함수 `generate_expressions`를 정의하여 백트래킹을 수행합니다.
   - 함수의 매개변수로는 현재 숫자의 범위 `n`, 현재까지 생성된 수식 `current_expr`, 그리고 결과 리스트 `results`를 받습니다.
   - 현재 수식의 길이가 완성되었는지 확인하고, 완성되었다면 공백을 제거하여 계산합니다. 계산 결과가 0이라면 결과 리스트에 추가합니다.
   - 그렇지 않은 경우, 가능한 연산자(`+`, `-`, 공백`)를 하나씩 추가하여 재귀 호출을 진행합니다.

3. **수식 계산 및 결과 저장**

   - 공백을 포함한 문자열 수식을 처리하기 위해, 최종적으로 수식에서 공백을 제거하고 `eval` 함수를 사용하여 계산합니다.
   - 계산 결과가 0인 경우에만 리스트에 추가하여 유효한 수식으로 간주합니다.

4. **결과 출력**

   - 각 테스트 케이스마다 생성된 결과 리스트를 ASCII 순서로 정렬합니다.
   - 정렬된 결과를 순서대로 출력합니다.
   - 테스트 케이스 사이에는 빈 줄을 출력하여 구분합니다.

5. **프로그램 실행**
   - 위 과정을 통해 모든 테스트 케이스를 처리하며, 모든 결과를 출력합니다.
   - 테스트 케이스가 10개 미만이고 `N`이 9 이하로 제한되어 있으므로 시간 복잡도는 허용 가능한 수준입니다.

## 코드 구현

```python
def generate_expressions(n, current_expr, results):
    # 현재 생성된 수식이 완성되었는지 확인. 숫자와 연산자가 모두 포함된 경우
    if len(current_expr) == 2 * n - 1:
        # 공백을 제거하고 계산 가능한 수식으로 변환
        expr = current_expr.replace(" ", "")
        # 계산 결과가 0인 경우 결과 리스트에 추가
        if eval(expr) == 0:
            results.append(current_expr)
        return

    # 다음에 추가될 숫자를 계산 (현재 길이를 기준으로 계산)
    next_num = len(current_expr) // 2 + 2
    # '+' 연산자를 추가한 수식으로 재귀 호출
    generate_expressions(n, current_expr + "+" + str(next_num), results)
    # '-' 연산자를 추가한 수식으로 재귀 호출
    generate_expressions(n, current_expr + "-" + str(next_num), results)
    # ' '(공백)을 추가한 수식으로 재귀 호출
    generate_expressions(n, current_expr + " " + str(next_num), results)


def solve_zero_sum_expressions():
    # 테스트 케이스의 개수를 입력 받음
    t = int(input().strip())
    # 테스트 케이스에서 주어지는 숫자 N들을 리스트로 저장
    test_cases = [int(input().strip()) for _ in range(t)]

    # 각 테스트 케이스에 대해 반복
    for case_idx, n in enumerate(test_cases):
        # 0이 되는 수식을 저장할 리스트 초기화
        results = []
        # 숫자 1로 시작하는 수식을 생성하는 재귀 호출 시작
        generate_expressions(n, "1", results)
        # 생성된 결과를 ASCII 순서로 정렬
        results.sort()
        # 결과 리스트의 각 수식을 출력
        for result in results:
            print(result)
        # 테스트 케이스 사이에 빈 줄 출력 (마지막 테스트 케이스 제외)
        if case_idx != len(test_cases) - 1:
            print()


# 프로그램 실행
solve_zero_sum_expressions()
```
