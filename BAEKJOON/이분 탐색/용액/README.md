# 용액 문제 풀이 및 설명

https://www.acmicpc.net/problem/2467

## 문제 이해
**문제 설명**:
- KOI 부설 과학연구소에서는 산성 용액과 알칼리성 용액을 여러 종류 보유하고 있으며, 각 용액에는 해당 용액의 특성을 나타내는 정수가 주어집니다.
- 산성 용액의 특성값은 양의 정수(1부터 1,000,000,000까지)이고, 알칼리성 용액의 특성값은 음의 정수(-1부터 -1,000,000,000까지)입니다.
- 두 용액을 혼합하면 그 특성값의 합이 됩니다.
- 이 연구소에서는 두 용액을 혼합하여 특성값이 0에 가장 가까운 혼합 용액을 만들려고 합니다.
- 입력으로 주어진 용액들의 특성값이 정렬된 순서로 주어질 때, 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만드는 프로그램을 작성해야 합니다.

## 입력/출력 조건
**입력**:
1. 첫째 줄에는 전체 용액의 수 \( N \)이 주어집니다. \( N \)은 2 이상 100,000 이하의 정수입니다.
2. 둘째 줄에는 \( N \)개의 용액의 특성값이 오름차순으로 주어집니다. 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하의 정수입니다.
3. 용액들의 특성값은 모두 서로 다릅니다.

**출력**:
- 특성값이 0에 가장 가까운 혼합 용액을 만들기 위해 혼합해야 하는 두 용액의 특성값을 공백으로 구분하여 출력합니다. 두 용액은 특성값의 오름차순으로 출력해야 합니다.
- 특성값이 0에 가장 가까운 용액을 만드는 경우가 두 개 이상일 경우에는 그 중 아무거나 하나를 출력합니다.

## 접근 방식
- 문제를 해결하기 위해 두 포인터(투 포인터) 알고리즘을 사용합니다. 두 포인터 알고리즘은 정렬된 배열에서 특정 조건을 만족하는 두 요소를 찾는 데 유용합니다.
- 시작 포인터(left)를 배열의 첫 번째 요소에, 끝 포인터(right)를 배열의 마지막 요소에 두고, 두 포인터의 합이 0에 가까워지도록 이동시키며 최적의 값을 찾습니다.

## 문제 해결 과정
1. **함수 정의 및 초기화**
    - `find_closest_to_zero` 함수를 정의하고, 배열의 길이 `n`을 저장합니다.
    - 시작 포인터(`left`)는 배열의 첫 번째 요소에, 끝 포인터(`right`)는 배열의 마지막 요소에 설정합니다.
    - `closest_sum`은 0에 가장 가까운 합을 저장하기 위한 변수로, 초기값을 무한대로 설정하여 첫 번째 비교가 항상 이기도록 합니다.
    - `answer`는 가장 가까운 합을 만드는 두 용액의 특성값을 저장하는 튜플입니다.

2. **두 포인터를 이용한 합 계산**
    - `while` 루프는 두 포인터가 교차할 때까지 반복됩니다.
    - `current_sum`은 현재 두 포인터가 가리키는 용액의 특성값 합을 계산합니다.
    - 현재 합이 0에 더 가까운 경우, `closest_sum`과 `answer`를 갱신합니다.
    - `current_sum`이 0보다 작으면 시작 포인터를 오른쪽으로 이동하여 더 큰 값을 탐색하고, 0보다 크거나 같으면 끝 포인터를 왼쪽으로 이동하여 더 작은 값을 탐색합니다.

3. **결과 반환**
    - `while` 루프가 끝나면, `answer` 변수에 저장된 두 용액의 특성값을 반환합니다.

4. **입력 및 함수 호출**
    - 전체 용액의 수 `n`을 입력받습니다.
    - 용액의 특성값을 입력받아 리스트로 변환합니다.
    - `find_closest_to_zero` 함수를 호출하여 0에 가장 가까운 합을 만드는 두 용액의 특성값을 찾고, 결과를 출력합니다.

## 코드 구현
```python
def find_closest_to_zero(arr):
    n = len(arr)  # 배열의 길이를 변수 n에 저장
    left = 0  # 시작 포인터를 배열의 첫 번째 요소로 설정
    right = n - 1  # 끝 포인터를 배열의 마지막 요소로 설정
    closest_sum = float('inf')  # 0에 가장 가까운 합을 저장할 변수, 초기값은 무한대로 설정
    answer = (arr[left], arr[right])  # 가장 가까운 합을 만드는 두 용액의 특성값을 저장할 변수

    while left < right:  # 두 포인터가 교차할 때까지 반복
        current_sum = arr[left] + arr[right]  # 현재 두 포인터가 가리키는 용액의 합 계산
        if abs(current_sum) < abs(closest_sum):  # 현재 합이 0에 더 가까운 경우
            closest_sum = current_sum  # 가장 가까운 합을 갱신
            answer = (arr[left], arr[right])  # 두 용액의 특성값을 갱신
        
        if current_sum < 0:  # 현재 합이 0보다 작은 경우
            left += 1  # 시작 포인터를 오른쪽으로 이동
        else:  # 현재 합이 0보다 크거나 같은 경우
            right -= 1  # 끝 포인터를 왼쪽으로 이동

    return answer  # 0에 가장 가까운 합을 만드는 두 용액의 특성값 반환

# 입력
n = int(input())  # 전체 용액의 수 입력
arr = list(map(int, input().split()))  # 용액의 특성값을 입력받아 리스트로 변환

# 특성값이 0에 가장 가까운 두 용액 찾기
result = find_closest_to_zero(arr)  # find_closest_to_zero 함수 호출
print(result[0], result[1])  # 결과 출력
