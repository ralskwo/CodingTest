# 원판 돌리기 문제 풀이 및 설명

<https://www.acmicpc.net/problem/17822>

<https://mayquartet.com/python-파이썬-백준-17822-원판-돌리기/>

## 문제 이해

이 문제는 원판이 여러 개 겹쳐진 상태에서, 각 원판을 회전시키고 회전 후에 원판 위의 수를 특정 규칙에 따라 처리하는 문제입니다. 각 원판은 크기가 다르며, 원판 위에는 여러 개의 정수가 적혀 있습니다. 문제의 핵심은 회전한 후 인접한 수가 같은지 확인하고, 같은 수가 있으면 제거하며, 만약 인접한 수가 모두 다른 경우에는 수의 평균을 기준으로 조정하는 것입니다. 이 과정을 T번 반복한 후, 최종적으로 원판 위에 남은 수들의 합을 구하는 것이 목표입니다.

이 문제에서 중요한 것은 원판이 회전할 때, 원판 내부의 숫자들이 어떻게 이동하는지, 그리고 인접한 숫자들의 관계를 어떻게 정의하고 처리할지입니다. 각 회전 명령은 독립적으로 수행되며, 각 명령에 따라 특정 원판들이 회전합니다. 이후 원판 위의 수를 특정 규칙에 따라 변경하는 과정이 필요합니다.

## 입출력 조건

1. **입력**

   - 첫 번째 줄에는 세 개의 정수 `N`, `M`, `T`가 주어집니다. `N`은 원판의 개수, `M`은 각 원판에 적힌 숫자의 개수, `T`는 회전 명령의 개수입니다.
     - `2 ≤ N, M ≤ 50`
     - `1 ≤ T ≤ 50`
   - 두 번째 줄부터는 `N`개의 줄에 걸쳐 각 원판에 적힌 정수들이 주어집니다. i번째 줄에는 i번째 원판에 적힌 `M`개의 정수가 주어지며, 정수는 시계 방향으로 배열되어 있습니다.
     - 원판에 적힌 정수는 1 이상 1000 이하입니다.
   - 그다음 `T`개의 줄에는 세 개의 정수 `xi`, `di`, `ki`가 주어집니다.
     - `xi`는 회전시킬 원판의 배수를 의미하며, `2 ≤ xi ≤ N`입니다.
     - `di`는 회전 방향을 의미하며, `0`은 시계 방향, `1`은 반시계 방향을 나타냅니다.
     - `ki`는 회전할 칸 수를 의미하며, `1 ≤ ki < M`입니다.

2. **출력**
   - T번의 회전이 모두 끝난 후, 원판 위에 남아있는 숫자들의 합을 출력합니다.

## 접근 방식

이 문제를 풀기 위해서는 다음과 같은 알고리즘과 방식을 사용해야 합니다.

1. **Deque를 사용한 회전 구현**: 각 원판을 `deque`로 처리하면 원판 회전을 효율적으로 구현할 수 있습니다. `deque`의 `rotate` 함수를 사용하면 시계 방향과 반시계 방향 회전을 쉽게 구현할 수 있습니다. 이때, `deque`는 리스트처럼 원소를 저장하지만, 양방향에서의 삽입과 삭제가 매우 효율적이기 때문에 회전 연산에 적합합니다.

2. **인접 수 탐색**: 원판 내에서 좌우로 인접한 수를 찾는 것은 리스트 내 인덱스를 통해 해결할 수 있습니다. 또한, 원판 사이에서 상하로 인접한 수를 찾기 위해서는 각 원판의 같은 인덱스를 비교하는 방식으로 구현할 수 있습니다. 이 과정에서 각 원판을 순차적으로 확인하고, 인접한 수를 저장한 후, 인접한 수가 있으면 그 수를 제거합니다.

3. **평균 계산 및 조정**: 인접한 수를 제거한 후에도 원판 위에 남아있는 수들이 있으면, 전체 원판의 수의 평균을 계산하고, 평균보다 큰 수는 1을 빼고, 작은 수는 1을 더하는 과정을 거칩니다. 이때, 제거된 수는 0으로 표시하여 처리합니다.

4. **각 회전 명령 처리**: 주어진 회전 명령에 따라 특정 원판을 회전시키고, 그 후 인접한 수가 있는지 확인한 다음 처리하는 과정을 반복합니다. 이 과정을 T번 반복한 후 최종 결과를 계산합니다.

## 풀이 과정

1. **입력 처리 및 초기 설정**:

   - 먼저, 입력으로 주어진 `N`, `M`, `T`를 읽어 원판의 개수와 원판에 적힌 숫자의 개수를 저장합니다. 각 원판의 상태는 `deque`로 저장하여 나중에 회전 연산을 쉽게 처리할 수 있도록 합니다. 또한 회전 명령을 읽어 각각의 명령을 `commands` 리스트에 저장합니다.

2. **회전 함수 구현**:

   - 주어진 명령에 따라 특정 원판을 회전시키는 함수 `rotate`를 작성합니다. 이 함수는 `xi`의 배수인 원판만 선택하여 회전하며, `di` 값에 따라 시계 방향 또는 반시계 방향으로 `ki`칸 만큼 회전시킵니다. `deque`의 `rotate` 메서드를 사용하면 시계 방향 회전은 양수로, 반시계 방향 회전은 음수로 처리할 수 있습니다.

3. **인접한 수를 제거하는 함수 구현**:

   - 각 회전 후에는 인접한 수를 찾아 제거해야 합니다. 이를 위해 모든 원판을 순회하며, 원판 내에서는 좌우로, 원판 간에는 상하로 인접한 수를 비교합니다. 같은 수가 있는 경우, 그 수를 제거합니다. 제거된 수는 0으로 표시하여 처리하며, 인접한 수가 없어 제거되지 않았을 경우 평균을 기준으로 수를 조정하는 과정으로 넘어갑니다.

4. **평균을 기준으로 수 조정 함수 구현**:

   - 인접한 수가 없을 경우, 남아있는 수들의 평균을 계산하고 그 평균을 기준으로 각 수를 조정합니다. 평균보다 큰 수는 1을 빼고, 평균보다 작은 수는 1을 더합니다. 평균과 같은 수는 그대로 유지합니다. 이 과정을 통해 수를 조정한 후에도 여전히 남아있는 수들이 있을 수 있으므로 이 과정은 매우 중요합니다.

5. **전체 로직 구현**:
   - 입력받은 모든 회전 명령을 순차적으로 처리하며, 회전 후에는 인접한 수를 제거하고, 인접한 수가 없으면 평균을 기준으로 수를 조정하는 과정을 반복합니다. 이 과정을 T번 반복한 후, 최종적으로 원판 위에 남아있는 수들의 합을 계산하여 출력합니다.

## 코드 구현

```python
from collections import deque

# N: 원판의 수, M: 각 원판에 적힌 숫자의 개수, T: 회전 명령의 개수
N, M, T = map(int, input().split())

# 각 원판의 상태를 입력받아 deque로 저장 (deque는 회전이 용이함)
board = [deque(map(int, input().split())) for _ in range(N)]

# 회전 명령을 (x, d, k) 형태로 입력받아 리스트에 저장
commands = [tuple(map(int, input().split())) for _ in range(T)]

# 인접한 좌표를 탐색할 때 사용할 상하좌우 이동 방향 (dx, dy)
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# 인접한 수를 제거하는 함수
def remove_adjacent():
    # 제거할 좌표들을 저장할 집합 (중복 방지를 위해 set 사용)
    to_remove = set()

    # 모든 원판의 좌표를 순회하며 인접한 같은 수를 찾음
    for i in range(N):
        for j in range(M):
            # 현재 위치의 수가 0이면 (이미 제거된 수) 탐색하지 않음
            if board[i][j] == 0:
                continue
            # 원판 내부에서 좌우로 인접한 수를 검사
            if board[i][j] == board[i][(j + 1) % M]:
                to_remove.add((i, j))  # 현재 위치
                to_remove.add((i, (j + 1) % M))  # 오른쪽 위치
            if board[i][j] == board[i][(j - 1) % M]:
                to_remove.add((i, j))  # 현재 위치
                to_remove.add((i, (j - 1) % M))  # 왼쪽 위치
            # 상하로 인접한 수를 검사 (다른 원판과 연결된 부분)
            if i > 0 and board[i][j] == board[i - 1][j]:
                to_remove.add((i, j))  # 현재 위치
                to_remove.add((i - 1, j))  # 위쪽 원판의 같은 j 위치
            if i < N - 1 and board[i][j] == board[i + 1][j]:
                to_remove.add((i, j))  # 현재 위치
                to_remove.add((i + 1, j))  # 아래쪽 원판의 같은 j 위치

    # 제거할 수가 있다면 그 좌표의 수를 0으로 변경
    if to_remove:
        for i, j in to_remove:
            board[i][j] = 0
        return True  # 인접한 수를 제거한 경우 True 반환
    return False  # 제거할 수가 없는 경우 False 반환

# 원판에 적힌 수들의 평균을 기준으로 값을 조정하는 함수
def adjust_by_average():
    total_sum = 0  # 전체 수의 합
    total_count = 0  # 전체 수의 개수

    # 모든 원판을 순회하며 0이 아닌 수의 합과 개수를 계산
    for i in range(N):
        for j in range(M):
            if board[i][j] != 0:
                total_sum += board[i][j]
                total_count += 1

    # 남아있는 수가 없다면 조정할 필요가 없으므로 함수 종료
    if total_count == 0:
        return

    # 평균을 계산
    average = total_sum / total_count

    # 모든 원판을 순회하며 평균보다 크면 1을 빼고, 작으면 1을 더함
    for i in range(N):
        for j in range(M):
            if board[i][j] != 0:
                if board[i][j] > average:
                    board[i][j] -= 1
                elif board[i][j] < average:
                    board[i][j] += 1

# 주어진 명령에 따라 원판을 회전시키는 함수
def rotate(x, d, k):
    # x의 배수인 원판을 선택하여 회전
    for i in range(x - 1, N, x):
        if d == 0:  # 시계 방향 회전
            board[i].rotate(k)
        else:  # 반시계 방향 회전
            board[i].rotate(-k)

# T번의 명령을 차례로 수행
for x, d, k in commands:
    rotate(x, d, k)  # 주어진 원판을 회전
    if not remove_adjacent():  # 인접한 수를 제거할 수 없으면
        adjust_by_average()  # 평균을 기준으로 수를 조정

# 최종적으로 원판에 남아있는 수들의 합을 계산
result = sum(sum(row) for row in board)
print(result)  # 결과 출력
```
