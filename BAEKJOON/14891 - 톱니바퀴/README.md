# 톱니바퀴 문제 풀이 및 설명

https://www.acmicpc.net/problem/14891

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-14891-%ed%86%b1%eb%8b%88%eb%b0%94%ed%80%b4-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 여러 개의 톱니바퀴가 회전하며 서로 영향을 주는 상황을 시뮬레이션하는 문제입니다. 각 톱니바퀴는 8개의 톱니로 구성되어 있으며, 이 톱니들은 N극(0) 또는 S극(1)으로 표시되어 있습니다. 톱니바퀴는 한 번에 시계 방향 또는 반시계 방향으로 회전할 수 있습니다. 이때, 톱니바퀴가 회전할 때 인접한 톱니바퀴와 맞닿은 톱니의 극이 다르면 인접한 톱니바퀴도 반대 방향으로 회전하게 됩니다. 이 문제는 톱니바퀴들이 주어진 회전 명령에 따라 정확하게 회전하는지, 그리고 회전 후의 결과를 정확히 계산하는 것이 핵심입니다. 문제를 풀기 위해서는 톱니바퀴의 회전 규칙과 서로 간의 영향 전파를 정확하게 시뮬레이션해야 합니다.

## 입출력 조건

### 입력 조건

- 첫째 줄부터 넷째 줄까지 각 톱니바퀴의 초기 상태가 주어집니다. 각 상태는 8개의 숫자로 구성되며, 12시 방향부터 시계 방향 순서로 N극(0)과 S극(1)으로 이루어져 있습니다.
- 다섯째 줄에는 회전 횟수 `K`가 주어집니다. (`1 ≤ K ≤ 100`)
- 그다음 줄부터 `K`개의 줄에는 회전 명령이 주어집니다. 각 명령은 두 개의 정수로 이루어져 있습니다. 첫 번째 정수는 회전시킬 톱니바퀴의 번호(1부터 4까지), 두 번째 정수는 회전 방향을 나타냅니다. 방향이 `1`인 경우 시계 방향, `-1`인 경우 반시계 방향을 의미합니다.

### 출력 조건

- 모든 회전이 끝난 후, 네 개의 톱니바퀴의 점수의 합을 출력해야 합니다. 각 톱니바퀴의 점수는 다음과 같이 계산됩니다:
  - 1번 톱니바퀴의 12시 방향이 N극이면 0점, S극이면 1점
  - 2번 톱니바퀴의 12시 방향이 N극이면 0점, S극이면 2점
  - 3번 톱니바퀴의 12시 방향이 N극이면 0점, S극이면 4점
  - 4번 톱니바퀴의 12시 방향이 N극이면 0점, S극이면 8점

## 접근 방식

이 문제를 풀기 위해서는 주어진 회전 규칙을 정확하게 시뮬레이션하는 것이 중요합니다. 톱니바퀴가 회전할 때 인접한 톱니바퀴에 영향을 줄 수 있는지 판단하고, 그에 따라 연쇄적인 회전을 정확하게 처리해야 합니다. 이를 위해 다음과 같은 알고리즘 또는 방식을 사용해야 합니다:

1. **시뮬레이션 및 상태 변화 관리**:

   - 톱니바퀴들의 현재 상태를 관리하는 데이터 구조(리스트)를 사용하여 각 톱니바퀴의 회전과 상태 변화를 추적합니다.
   - 주어진 회전 명령에 따라 톱니바퀴를 회전시키고, 각 회전마다 인접 톱니바퀴에 미치는 영향을 판단합니다.

2. **연쇄적 회전 처리**:

   - 톱니바퀴가 회전할 때 인접한 톱니바퀴의 맞닿은 톱니의 극이 다르면 반대 방향으로 회전해야 합니다. 이를 양방향으로 처리해야 합니다.
   - 현재 톱니바퀴의 회전이 좌측과 우측의 톱니바퀴에 미치는 영향을 동시에 고려하여 각 회전마다 모든 톱니바퀴의 회전 상태를 결정합니다.

3. **효율적인 구현**:
   - 최대 100번의 회전 명령이 주어질 수 있으므로, 각 회전마다 모든 톱니바퀴의 상태를 효율적으로 업데이트할 수 있는 로직이 필요합니다.
   - 이 과정에서 톱니바퀴의 상태와 회전 방향을 기록하고 관리하여 정확한 시뮬레이션을 수행해야 합니다.

## 풀이 과정

1. **톱니바퀴 상태 초기화**:

   - 각 톱니바퀴의 상태를 리스트로 관리합니다. 주어진 입력을 파싱하여 4개의 톱니바퀴 상태를 저장합니다.

2. **회전 명령 처리**:

   - 각 회전 명령을 처리할 때마다, 회전시킬 톱니바퀴의 번호와 방향을 가져옵니다.
   - 각 톱니바퀴의 회전 방향을 저장할 리스트를 초기화하여 현재 명령이 모든 톱니바퀴에 미치는 영향을 추적합니다.

3. **좌측과 우측의 영향 전파**:

   - 회전시킬 톱니바퀴를 기준으로 왼쪽 톱니바퀴들과 오른쪽 톱니바퀴들로 각각 영향을 전파합니다.
   - 인접한 톱니바퀴의 맞닿은 톱니가 서로 다른 극을 가지는지 확인하고, 반대 방향으로 회전시킬지 결정합니다.
   - 왼쪽으로 전파하는 경우는 톱니바퀴의 6번 인덱스와 그 왼쪽 톱니바퀴의 2번 인덱스를 비교하여 결정하고, 오른쪽으로 전파하는 경우는 현재 톱니바퀴의 2번 인덱스와 오른쪽 톱니바퀴의 6번 인덱스를 비교합니다.

4. **회전 방향에 따라 톱니바퀴 회전**:

   - 모든 톱니바퀴의 회전 방향을 결정한 후, 각 톱니바퀴를 실제로 회전시킵니다.
   - 시계 방향 회전은 리스트의 마지막 요소를 맨 앞으로 이동시키고, 반시계 방향 회전은 리스트의 첫 번째 요소를 맨 뒤로 이동시킵니다.

5. **최종 점수 계산**:

   - 모든 회전이 끝나면 각 톱니바퀴의 12시 방향이 S극인지 확인하여 점수를 계산합니다.
   - 톱니바퀴 번호에 따라 점수 가중치를 부여하여 총합을 계산합니다.

6. **결과 출력**:
   - 계산된 최종 점수를 출력합니다.

## 코드 구현

```python
def rotate_gear(gear, direction):
    # 톱니바퀴를 시계 방향으로 회전
    if direction == 1:
        # 톱니바퀴를 오른쪽으로 한 칸씩 이동
        return [gear[-1]] + gear[:-1]
    # 톱니바퀴를 반시계 방향으로 회전
    elif direction == -1:
        # 톱니바퀴를 왼쪽으로 한 칸씩 이동
        return gear[1:] + [gear[0]]

def simulate_gears(gears, rotations):
    # 주어진 회전 명령들을 순차적으로 처리
    for gear_index, direction in rotations:
        # 각 톱니바퀴의 회전 방향을 저장하는 리스트 초기화
        rotation_directions = [0, 0, 0, 0]
        # 현재 회전시킬 톱니바퀴의 방향 설정
        rotation_directions[gear_index - 1] = direction

        # 현재 톱니바퀴의 왼쪽에 있는 톱니바퀴들에 대해 회전 영향 전파
        for i in range(gear_index - 1, 0, -1):
            # 현재 톱니바퀴와 왼쪽 톱니바퀴의 맞닿은 극이 다를 경우
            if gears[i][6] != gears[i - 1][2]:
                # 왼쪽 톱니바퀴는 현재 톱니바퀴와 반대 방향으로 회전
                rotation_directions[i - 1] = -rotation_directions[i]
            else:
                # 맞닿은 극이 같으면 더 이상 왼쪽으로 전파되지 않음
                break

        # 현재 톱니바퀴의 오른쪽에 있는 톱니바퀴들에 대해 회전 영향 전파
        for i in range(gear_index - 1, 3):
            # 현재 톱니바퀴와 오른쪽 톱니바퀴의 맞닿은 극이 다를 경우
            if gears[i][2] != gears[i + 1][6]:
                # 오른쪽 톱니바퀴는 현재 톱니바퀴와 반대 방향으로 회전
                rotation_directions[i + 1] = -rotation_directions[i]
            else:
                # 맞닿은 극이 같으면 더 이상 오른쪽으로 전파되지 않음
                break

        # 저장된 회전 방향에 따라 톱니바퀴들을 회전
        for i in range(4):
            if rotation_directions[i] != 0:
                gears[i] = rotate_gear(gears[i], rotation_directions[i])

    # 회전 후의 톱니바퀴 상태 반환
    return gears

def calculate_score(gears):
    # 최종 점수를 저장할 변수 초기화
    score = 0
    # 각 톱니바퀴의 12시 방향을 검사하여 점수 계산
    for i in range(4):
        if gears[i][0] == '1':
            # 톱니바퀴의 12시 방향이 S극('1')이면 점수를 추가
            score += 2 ** i
    # 최종 점수 반환
    return score

def main():
    import sys
    input = sys.stdin.read
    data = input().split()

    # 첫 4개의 줄을 통해 톱니바퀴의 초기 상태를 저장
    gears = [list(data[i]) for i in range(4)]

    # 회전 횟수 K를 입력받음
    K = int(data[4])

    # 회전 정보들을 저장할 리스트 초기화
    rotations = []
    # 회전 정보는 톱니바퀴 번호와 회전 방향으로 주어지므로 이를 파싱하여 저장
    for i in range(5, 5 + K * 2, 2):
        gear_index = int(data[i])
        direction = int(data[i + 1])
        rotations.append((gear_index, direction))

    # 주어진 회전 정보에 따라 톱니바퀴들을 회전시킴
    gears = simulate_gears(gears, rotations)

    # 회전이 모두 끝난 후 최종 점수를 계산
    score = calculate_score(gears)

    # 최종 점수 출력
    print(score)

if __name__ == "__main__":
    main()
```
