# 검문 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2981>

<https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-2981-%ea%b2%80%eb%ac%b8-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/>

## 문제 이해

이 문제는 주어진 여러 개의 자연수를 모두 동일한 나머지를 가지도록 만드는 특정 값 `M`을 찾는 문제입니다. 상근이는 `N`개의 자연수를 적은 후, 이 수들을 `M`으로 나눴을 때 나머지가 모두 같아야 한다는 조건을 만족하는 `M`을 찾으려 합니다. 중요한 점은, `M`은 1보다 큰 자연수여야 하며, 가능한 `M`들을 모두 찾아야 합니다.

이 문제의 핵심은 모든 수의 차이가 `M`으로 나눠떨어져야 한다는 점입니다. 즉, 주어진 수들의 차이들에서 공통된 규칙을 찾아 그 규칙을 따르는 `M`들을 구하는 것이 목표입니다. 이 문제를 잘 이해하려면 두 수의 차이를 생각해보고, 그 차이를 나눌 수 있는 공통된 약수들을 구하는 과정이 필요합니다.

## 입출력 조건

### 입력

1. 첫 번째 줄에는 자연수의 개수 `N`이 주어집니다. (2 ≤ N ≤ 100)
2. 두 번째 줄부터 `N`개의 자연수가 각각 한 줄에 주어집니다.
   - 자연수는 모두 1보다 크거나 같고, 1,000,000,000보다 작거나 같은 범위의 수입니다.
   - 같은 수가 두 번 이상 주어지지 않으며, 항상 적어도 하나 이상의 `M`이 존재하는 입력이 주어집니다.

### 출력

1. 가능한 `M` 값들을 공백으로 구분하여 출력합니다.
2. 출력되는 `M` 값들은 오름차순으로 정렬되어 있어야 합니다.

## 접근 방식

이 문제는 수학적인 관점에서 **최대 공약수(GCD)**와 **약수** 개념을 기반으로 해결할 수 있습니다. 문제를 풀기 위한 기본 아이디어는 다음과 같습니다:

1. 주어진 여러 수에서 나머지가 모두 동일하려면, 그 수들 간의 차이가 일정한 규칙을 가져야 합니다.
2. 그 규칙을 찾는 방법은 두 수의 차이의 **최대 공약수(GCD)**를 구하는 것입니다. 이때, 모든 수들의 차이를 계산하고 그 차이들에 대한 최대 공약수를 구해야 합니다.
3. 구한 최대 공약수의 **약수**들을 구하면, 그 약수들이 바로 가능한 `M`이 됩니다. 즉, `M`은 구한 최대 공약수를 나눌 수 있는 값들로 구성됩니다.
4. 마지막으로, 구한 약수들을 오름차순으로 정렬하여 출력하면 됩니다.

이 과정을 통해, 주어진 수들에 대해 동일한 나머지를 가지는 `M`을 효율적으로 구할 수 있습니다.

## 풀이 과정

1. **입력 처리**:
   먼저, 입력으로 주어진 자연수 `N`과 `N`개의 수를 받습니다. 이때, 입력받은 수들을 오름차순으로 정렬합니다. 정렬된 상태에서 두 수 간의 차이를 구하기가 더 용이하기 때문입니다.

2. **차이 계산**:
   첫 번째 단계로, 주어진 수들 간의 차이를 구합니다. 가장 첫 번째로 두 수의 차이를 구하여 이 값을 `g`로 설정합니다. 이후 나머지 수들에 대해서도 순차적으로 두 수의 차이를 구하고, 그 차이와 `g`의 최대 공약수를 계산하여 갱신해 나갑니다. 즉, 모든 수들의 차이에 대한 최대 공약수를 구하는 것입니다.

3. **최대 공약수의 약수 구하기**:
   구한 최대 공약수 `g`는 동일한 나머지를 가지는 `M`의 후보 값들의 기준이 됩니다. 이제 이 `g`의 약수들을 찾아야 합니다. 이를 위해 `g`의 제곱근까지 반복하면서 약수를 구하고, `g`를 나눌 수 있는 모든 값을 리스트에 저장합니다. 이 과정에서 `g`의 제곱근이 아닌 약수도 고려해야 하므로, `g // i`도 함께 저장합니다.

4. **결과 출력**:
   약수들이 모두 구해지면, 그 약수들을 오름차순으로 정렬한 후 공백으로 구분하여 출력합니다. 이를 통해 가능한 `M` 값들을 출력할 수 있습니다.

이 과정은 시간 복잡도 측면에서도 효율적입니다. 수의 범위가 10억까지 크더라도, 최대 공약수와 약수 구하기 과정은 제곱근까지만 계산하면 되므로 빠르게 처리할 수 있습니다.

## 코드 구현

```python
import math  # 수학 관련 함수를 사용하기 위해 math 모듈을 불러옴

def gcd(a, b):  # 두 수의 최대 공약수를 구하는 함수
    while b:  # b가 0이 될 때까지 반복
        a, b = b, a % b  # a에 b를 대입하고 b에 a를 b로 나눈 나머지를 대입
    return a  # b가 0이 되면 a가 최대 공약수이므로 반환

def find_divisors(num):  # num의 약수를 찾는 함수
    divisors = []  # 약수를 저장할 리스트 생성
    for i in range(2, int(math.sqrt(num)) + 1):  # 2부터 num의 제곱근까지 반복
        if num % i == 0:  # i가 num의 약수인지 확인
            divisors.append(i)  # i를 약수 리스트에 추가
            if i != num // i:  # i가 num의 제곱근이 아닌 경우
                divisors.append(num // i)  # num을 i로 나눈 값도 약수 리스트에 추가
    divisors.append(num)  # num 자체도 약수이므로 리스트에 추가
    return sorted(divisors)  # 약수를 오름차순으로 정렬하여 반환

n = int(input())  # 숫자의 개수를 입력받음
numbers = [int(input()) for _ in range(n)]  # 입력된 숫자들을 리스트로 저장

numbers.sort()  # 숫자들을 오름차순으로 정렬

g = numbers[1] - numbers[0]  # 첫 번째와 두 번째 숫자의 차이를 g로 설정
for i in range(2, n):  # 나머지 숫자들에 대해 반복
    g = gcd(g, numbers[i] - numbers[i - 1])  # 이전까지의 차이와 새로운 차이의 최대 공약수를 구함

result = find_divisors(g)  # g의 약수들을 구하여 result에 저장

print(" ".join(map(str, result)))  # 약수들을 공백으로 구분하여 출력
```
