# 강의실 배정 문제 풀이 및 설명

<https://www.acmicpc.net/problem/11000>

<https://mayquartet.com/python-파이썬-백준-11000-강의실-배정-문제-풀이-및-설명/>

## 문제 이해

이 문제는 여러 개의 수업이 주어졌을 때, 각 수업이 시작하는 시간과 끝나는 시간이 겹치지 않도록 최소한의 강의실을 할당하는 문제입니다. 핵심은 수업들의 시작 시간과 끝나는 시간이 서로 어떻게 겹치는지에 따라 강의실을 효율적으로 배치하는 것입니다. 수업이 끝난 후 바로 다음 수업이 시작된다면 같은 강의실에서 연속으로 사용할 수 있지만, 두 수업이 동시에 진행되어야 한다면 추가적인 강의실이 필요하게 됩니다.

즉, 주어진 여러 개의 수업에서 겹치는 시간대를 찾아내어 최대 몇 개의 수업이 동시에 열릴 수 있는지를 계산하는 것이 문제의 핵심입니다. 이때 가장 많이 겹치는 시간이 필요한 강의실의 최소 개수가 되며, 우리는 이 값을 구하는 것이 목표입니다.

## 입출력 조건

### 입력

- 첫 번째 줄에 수업의 개수 N이 주어집니다. (1 ≤ N ≤ 200,000)
- 그 다음 N개의 줄에는 각각 두 개의 정수 Si, Ti가 주어집니다. Si는 수업이 시작하는 시간, Ti는 수업이 끝나는 시간입니다. (0 ≤ Si < Ti ≤ 1,000,000,000)

### 출력

- 필요한 최소한의 강의실 수를 한 줄에 출력합니다.

## 접근 방식

이 문제를 해결하기 위해선 수업들이 서로 겹치는지 여부를 효율적으로 판단할 수 있어야 합니다. 주어진 문제를 풀기 위한 핵심 아이디어는 다음과 같습니다:

1. **정렬**:
   - 먼저 모든 수업을 시작 시간 기준으로 정렬합니다. 이렇게 하면 수업을 순차적으로 확인할 수 있어, 각 수업이 끝나는 시간과 다음 수업의 시작 시간을 비교할 수 있습니다.
2. **우선순위 큐(최소 힙)**:

   - 현재 진행 중인 수업들의 끝나는 시간을 추적하기 위해 최소 힙(우선순위 큐)을 사용합니다. 힙의 최상단에는 항상 가장 빨리 끝나는 수업의 종료 시간이 저장됩니다.
   - 새로 시작하는 수업이 현재 가장 빨리 끝나는 수업의 종료 시간보다 나중에 시작되면 그 강의실을 재사용할 수 있으므로, 해당 종료 시간을 제거하고 새로 시작하는 수업의 종료 시간을 힙에 추가합니다.
   - 반면, 새로 시작하는 수업이 현재 수업과 겹친다면 새로운 강의실이 필요하므로 종료 시간을 추가하기만 합니다.

3. **동시성 추적**:
   - 힙의 크기는 동시에 열리는 수업의 개수를 나타냅니다. 따라서 힙의 크기가 커질수록 더 많은 강의실이 필요하다는 의미입니다.
   - 모든 수업을 처리한 후 힙에 남아 있는 종료 시간의 개수가 곧 필요한 최소 강의실 수가 됩니다.

## 풀이 과정

1. **입력 처리**:
   - 우선, 주어진 입력에서 수업의 개수 N과 각 수업의 시작 시간과 종료 시간을 입력받습니다. N은 최대 200,000개이므로, 입력을 처리하는 방식도 효율적이어야 합니다.
2. **수업 시간 정렬**:
   - 수업의 시작 시간을 기준으로 모든 수업을 정렬합니다. 이렇게 하면 시간이 먼저인 수업부터 순차적으로 처리할 수 있습니다.
3. **최소 힙(우선순위 큐) 사용**:
   - 우선순위 큐(최소 힙)를 사용하여 각 강의실에서 진행 중인 수업의 종료 시간을 관리합니다.
   - 첫 번째 수업의 종료 시간을 힙에 넣습니다. 이 종료 시간은 현재 가장 빨리 끝나는 수업을 추적하는 데 사용됩니다.
4. **수업 비교 및 힙 관리**:
   - 두 번째 수업부터는 현재 수업의 시작 시간과 가장 빨리 끝나는 수업의 종료 시간을 비교합니다. 만약 새 수업의 시작 시간이 가장 빨리 끝나는 수업의 종료 시간 이후라면, 해당 강의실을 재사용할 수 있으므로 종료 시간을 힙에서 제거하고, 새로운 수업의 종료 시간을 추가합니다.
   - 만약 겹치는 경우에는 기존 강의실을 재사용할 수 없으므로 새로운 종료 시간을 힙에 추가하여 새로운 강의실을 할당합니다.
5. **최종 결과 출력**:
   - 모든 수업을 처리한 후, 힙에 남아 있는 종료 시간의 개수를 출력합니다. 이는 동시에 열리는 수업의 최대 개수이므로 필요한 최소 강의실 수와 동일합니다.

## 코드 구현

```python
import heapq
import sys

def solve():
    input = sys.stdin.read  # 입력을 한 번에 읽어옴
    data = input().splitlines()  # 입력 데이터를 줄 단위로 분리하여 리스트로 저장

    n = int(data[0])  # 첫 번째 줄에서 수업의 개수를 입력받아 정수로 변환

    classes = []  # 수업의 시작 시간과 종료 시간을 저장할 리스트
    for i in range(1, n + 1):  # 각 수업에 대해 반복
        start, end = map(int, data[i].split())  # 시작 시간과 종료 시간을 정수로 변환하여 각각 저장
        classes.append((start, end))  # (시작 시간, 종료 시간) 형태로 리스트에 추가

    classes.sort(key=lambda x: x[0])  # 수업들을 시작 시간 기준으로 오름차순 정렬

    heap = []  # 수업의 종료 시간을 저장할 최소 힙 리스트

    heapq.heappush(heap, classes[0][1])  # 첫 번째 수업의 종료 시간을 힙에 추가

    for i in range(1, n):  # 두 번째 수업부터 처리
        if heap[0] <= classes[i][0]:  # 현재 가장 빨리 끝나는 수업의 종료 시간과 새 수업의 시작 시간을 비교
            heapq.heappop(heap)  # 겹치지 않으면 기존 수업의 종료 시간을 힙에서 제거

        heapq.heappush(heap, classes[i][1])  # 새로운 수업의 종료 시간을 힙에 추가

    print(len(heap))  # 힙에 남아 있는 종료 시간의 개수가 필요한 최소 강의실 수

if __name__ == "__main__":
    solve()  # 프로그램의 시작점을 명시하고 solve 함수를 호출
```
