# 하노이 탑 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1914>

<https://mayquartet.com/python-백준-1914-하노이-탑/>

## 문제 이해

이 문제는 고전적인 **하노이 탑 문제**로, 세 개의 장대와 여러 개의 원판이 주어진 상황에서, 특정 규칙에 따라 원판을 옮겨야 하는 과제를 다룹니다. 첫 번째 장대에 크기가 서로 다른 원판들이 쌓여 있고, 이 원판들을 최소 횟수로 세 번째 장대로 옮겨야 합니다. 옮길 때 지켜야 할 규칙은 다음과 같습니다.

- 한 번에 한 개의 원판만 옮길 수 있습니다.
- 항상 위에 있는 원판이 아래에 있는 원판보다 크기가 작아야 합니다.

결국 이 문제는 `N`개의 원판을 규칙에 따라 한 장대에서 다른 장대로 옮기는 최적의 방법을 찾고, 이동 횟수를 최소화하는 과정을 출력하는 것입니다. 주어진 규칙에 따라 원판의 개수가 20 이하일 때는 각 이동 단계를 출력하고, 20보다 클 때는 이동 횟수만 출력하도록 제한되어 있습니다. 문제를 풀기 위해 재귀적인 사고가 요구되며, 하노이 탑 문제의 기본적인 특성을 이해해야 합니다.

## 입출력 조건

**입력**

- 첫째 줄에 원판의 개수 `N`이 주어지며, `N`의 범위는 `1 ≤ N ≤ 100`입니다.

**출력**

- 첫 번째 줄에 이동 횟수 `K`를 출력합니다. `K`는 최소 이동 횟수로, 하노이 탑의 일반적 특성에 따라 계산됩니다.
- `N`이 20 이하인 경우, 두 번째 줄부터는 각 이동 과정을 출력합니다. 이동 과정은 `K`개의 줄에 걸쳐 두 개의 정수 `A B` 형태로 출력되며, 이는 `A`번째 장대에서 `B`번째 장대로 원판을 옮기는 의미입니다.
- `N`이 20보다 큰 경우에는 이동 횟수 `K`만 출력하고, 이동 과정은 출력하지 않습니다.

## 접근 방식

이 문제는 하노이 탑 문제로, **재귀 알고리즘**을 통해 최적의 해답을 찾을 수 있습니다. 문제를 해결하기 위해 다음과 같은 기본 원리를 이해해야 합니다.

1. 하노이 탑에서 `N`개의 원판을 옮기기 위해서는 최소 `2^N - 1`번의 이동이 필요합니다.
2. `N`개의 원판을 한 장대에서 다른 장대로 옮기는 과정을 재귀적으로 다음과 같이 나눌 수 있습니다.
   - `N-1`개의 원판을 출발 장대에서 중간 장대로 옮깁니다.
   - 가장 큰 원판(즉, N번째 원판)을 출발 장대에서 목표 장대로 옮깁니다.
   - `N-1`개의 원판을 중간 장대에서 목표 장대로 옮깁니다.
3. 이 재귀적 과정에서 각 이동을 기록하여 출력하면 됩니다.
4. 재귀적으로 문제를 정의하면 자연스럽게 원판을 이동시키는 경로를 찾을 수 있으므로, 이를 `hanoi`라는 재귀 함수로 작성하여 각 이동 과정을 계산하고 저장할 수 있습니다.

재귀 호출의 깊이가 커질 수 있기 때문에, `N`의 범위가 커질 경우 이동 과정을 출력하지 않고 이동 횟수만 출력하도록 조건을 설정해야 합니다.

## 풀이 과정

1. **총 이동 횟수 계산**  
   주어진 원판의 개수 `N`에 대해 이동 횟수를 먼저 계산합니다. 하노이 탑의 이동 횟수는 `2^N - 1`로, `N`개의 원판을 옮길 때 필요한 최소 이동 횟수입니다. 이 값은 `solve_hanoi` 함수에서 `total_moves`라는 변수에 계산하여 저장합니다. 첫 번째 출력값으로 이 이동 횟수를 출력합니다.

2. **재귀적으로 이동 과정 계산**  
   `N`이 20 이하인 경우, 각 이동 과정을 계산하고 출력해야 합니다. 이를 위해 `hanoi`라는 재귀 함수를 정의하여 원판의 이동을 기록합니다. `hanoi` 함수의 매개변수는 다음과 같습니다.

   - `n`: 현재 옮겨야 할 원판의 수
   - `start`: 출발 장대 번호
   - `end`: 도착 장대 번호
   - `auxiliary`: 중간 장대 번호
   - `moves`: 이동 경로를 기록할 리스트
     이 함수는 다음과 같은 논리로 구현됩니다.
   - `n`이 1일 때, 즉 원판이 하나만 있을 때는 단순히 출발 장대에서 도착 장대로 이동합니다. 이 경우, `(start, end)`를 `moves` 리스트에 추가합니다.
   - `n`이 1보다 클 때, 먼저 `n-1`개의 원판을 출발 장대에서 중간 장대로 옮깁니다. 이는 재귀적으로 `hanoi(n - 1, start, auxiliary, end, moves)`를 호출하여 처리합니다.
   - 그 후 가장 큰 원판을 출발 장대에서 도착 장대로 이동하며 `(start, end)`를 `moves`에 추가합니다.
   - 마지막으로 중간 장대에 있는 `n-1`개의 원판을 도착 장대로 옮기기 위해 다시 재귀 호출 `hanoi(n - 1, auxiliary, end, start, moves)`을 사용합니다.

3. **이동 과정 출력**  
   `solve_hanoi` 함수에서는 `moves` 리스트에 모든 이동 경로가 저장되면 이를 차례대로 출력합니다. 각 이동 경로는 `A B` 형태로, 첫 번째 장대에서 두 번째 장대로 원판을 옮기는 것을 나타냅니다.

4. **메인 실행부**  
   메인 부분에서는 `input()`을 통해 사용자로부터 원판의 개수 `N`을 입력받고, 이를 정수로 변환하여 `solve_hanoi(n)` 함수를 호출합니다. `solve_hanoi` 함수는 위에서 설명한 로직에 따라 전체 이동 횟수를 계산하고, 조건에 따라 이동 과정을 출력하여 문제를 해결합니다.

## 코드 구현

```python
def hanoi(n, start, end, auxiliary, moves):
    # 원판이 1개일 때, 바로 시작 장대에서 끝 장대로 이동
    if n == 1:
        moves.append((start, end))  # 이동 기록을 moves 리스트에 추가
        return  # 재귀 호출 종료

    # n-1개의 원판을 시작 장대에서 보조 장대로 이동
    hanoi(n - 1, start, auxiliary, end, moves)

    # n번째 원판을 시작 장대에서 끝 장대로 이동
    moves.append((start, end))

    # n-1개의 원판을 보조 장대에서 끝 장대로 이동
    hanoi(n - 1, auxiliary, end, start, moves)

def solve_hanoi(n):
    # 총 이동 횟수를 계산 (2의 n승 - 1)
    total_moves = (2 ** n) - 1
    print(total_moves)  # 첫 번째 줄에 이동 횟수 출력

    # 원판의 개수가 20 이하일 때만 이동 과정을 출력
    if n <= 20:
        moves = []  # 이동 경로를 저장할 리스트 생성
        hanoi(n, 1, 3, 2, moves)  # 하노이 함수를 호출하여 이동 과정 저장

        # 이동 과정을 차례로 출력
        for move in moves:
            print(move[0], move[1])  # 각 이동을 시작 장대와 끝 장대로 출력

# 첫 번째 장대에 쌓인 원판의 개수를 입력받고 정수형으로 변환
n = int(input().strip())

# 하노이 탑 문제 해결 함수 호출
solve_hanoi(n)
```
