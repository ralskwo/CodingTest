# Separate String 문제 풀이 및 설명

https://www.acmicpc.net/problem/15525

## 문제 이해

이 문제는 주어진 문자열 \( t \)를 주어진 문자열 집합 \( S \)를 사용하여 가능한 모든 방법으로 분할하는 경우의 수를 계산하는 것입니다. 각 부분 문자열은 반드시 \( S \)에 포함되어 있어야 합니다. 문제는 최종 결과를 1,000,000,007로 나눈 나머지를 출력하라고 요구합니다.

## 입출력 조건

**입력 조건:**
1. 첫 번째 줄에는 정수 \( N \)이 주어집니다. (\( 1 \leq N \leq 100,000 \))
2. 다음 \( N \)개의 줄에는 집합 \( S \)에 포함되는 서로 다른 문자열들이 주어집니다. 각 문자열은 소문자로만 이루어져 있으며, 길이는 1 이상 100,000 이하입니다.
3. 마지막 줄에는 분할 대상 문자열 \( t \)가 주어집니다. \( t \)는 소문자로만 이루어져 있으며, 길이는 1 이상 100,000 이하입니다.
4. \( S \)의 문자열 길이의 총합은 최대 200,000입니다.

**출력 조건:**
- 문자열 \( t \)를 분할하는 방법의 수를 1,000,000,007로 나눈 나머지를 출력합니다.

## 접근 방식

이 문제를 풀기 위해 트라이(Trie) 자료구조와 동적 계획법(DP)를 함께 사용하는 것이 효과적입니다. 트라이는 문자열 검색을 빠르게 할 수 있는 자료구조로, 문자열 집합 \( S \)를 저장하는 데 사용합니다. 동적 계획법은 문자열 \( t \)를 분할하는 방법의 수를 계산하는 데 사용됩니다.

1. **Trie 자료구조 사용**:
   - 문자열 집합 \( S \)의 모든 문자열을 트라이에 저장합니다.
   - 트라이를 사용하여 문자열 \( t \)의 부분 문자열이 \( S \)에 포함되는지 빠르게 검사할 수 있습니다.

2. **동적 계획법(DP) 사용**:
   - DP 배열 `dp[i]`는 문자열 \( t \)의 처음부터 \( i \)번째 문자까지의 부분 문자열을 분할하는 방법의 수를 저장합니다.
   - `dp[0]`을 1로 초기화합니다. 이는 빈 문자열을 분할하는 방법이 한 가지임을 의미합니다.
   - 문자열 \( t \)의 각 위치에서 끝나는 부분 문자열을 찾고, 해당 부분 문자열이 \( S \)에 있는 경우 DP 배열을 갱신합니다.

## 풀이 과정

1. **입력 처리 및 초기화**:
   - 첫 번째 줄에서 \( N \)을 읽고, 다음 \( N \)개의 줄에서 문자열 집합 \( S \)를 읽습니다.
   - 마지막 줄에서 분할 대상 문자열 \( t \)를 읽습니다.

2. **트라이 구축**:
   - 트라이를 초기화하고, \( S \)의 모든 문자열을 트라이에 삽입합니다.

3. **동적 계획법(DP) 배열 초기화**:
   - DP 배열 `dp`를 길이 \( t \) + 1로 초기화합니다. `dp[0]`을 1로 설정합니다.

4. **DP 배열 갱신**:
   - 문자열 \( t \)의 각 위치 \( i \)에 대해, `dp[i]`가 0보다 큰 경우 현재 위치 \( i \)에서 시작하는 모든 부분 문자열을 찾습니다.
   - 트라이를 사용하여 부분 문자열이 \( S \)에 있는지 확인하고, 해당하는 부분 문자열의 끝 위치 \( j \)에 대해 `dp[j]`를 갱신합니다.
   - `dp[j] = (dp[j] + dp[i]) % MOD`의 형태로 갱신합니다.

5. **결과 출력**:
   - `dp[len(t)]` 값을 출력합니다. 이는 문자열 \( t \) 전체를 분할하는 방법의 수를 의미합니다.

## 코드 구현
```python
MOD = 1_000_000_007  # 문제에서 요구하는 모듈러 값 (나머지 연산에 사용)

class TrieNode:
    def __init__(self()):
        self.children = {}  # 자식 노드를 저장하는 딕셔너리
        self.is_end_of_word = False  # 단어의 끝을 표시하는 플래그

class Trie:
    def __init__(self()):
        self.root = TrieNode()  # 트라이의 루트 노드를 초기화
    
    def insert(self, word):
        node = self.root  # 루트 노드부터 시작
        for char in word:  # 단어의 각 문자를 순회
            if char not in node.children:  # 현재 문자에 해당하는 자식 노드가 없으면
                node.children[char] = TrieNode()  # 새로운 자식 노드를 생성
            node = node.children[char]  # 현재 노드를 자식 노드로 이동
        node.is_end_of_word = True  # 단어의 끝을 표시
    
    def search(self, s, start):
        node = self.root  # 루트 노드부터 시작
        results = []  # 부분 문자열의 끝 인덱스를 저장할 리스트
        for i in range(start, len(s)):  # 시작 위치부터 문자열의 끝까지 순회
            char = s[i]  # 현재 문자
            if char not in node.children:  # 현재 문자에 해당하는 자식 노드가 없으면
                break  # 검색 종료
            node = node.children[char]  # 현재 노드를 자식 노드로 이동
            if node.is_end_of_word:  # 단어의 끝이면
                results.append(i + 1)  # 끝 인덱스를 결과 리스트에 추가
        return results  # 부분 문자열의 끝 인덱스 리스트 반환

def count_ways(N, S, t):
    trie = Trie()  # 트라이 초기화
    for word in S:  # 집합 S의 모든 단어를 트라이에 삽입
        trie.insert(word)
    
    len_t = len(t)  # 문자열 t의 길이
    dp = [0] * (len_t + 1)  # DP 배열 초기화 (길이 len_t + 1)
    dp[0] = 1  # 빈 문자열을 분할하는 방법은 1가지
    
    for i in range(len_t):  # 문자열 t의 각 위치를 순회
        if dp[i] > 0:  # 현재 위치 i에서 분할 가능한 경우
            for j in trie.search(t, i):  # 트라이에서 i부터 시작하는 부분 문자열 검색
                dp[j] = (dp[j] + dp[i]) % MOD  # DP 배열 갱신 (모듈러 연산 적용)
    
    return dp[len_t]  # 문자열 t 전체를 분할하는 방법의 수 반환

import sys
input = sys.stdin.read  # 표준 입력에서 모든 데이터를 읽음
data = input().split()  # 읽은 데이터를 공백을 기준으로 분할

N = int(data[0])  # 첫 번째 값은 N (문자열 집합 S의 크기)
S = data[1:N+1]  # 다음 N개의 값은 집합 S에 속하는 문자열
t = data[N+1]  # 마지막 값은 분할 대상 문자열 t

result = count_ways(N, S, t)  # count_ways 함수 호출하여 결과 계산
print(result)  # 결과 출력
