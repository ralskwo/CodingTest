# 랜선 자르기 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1654>

<https://mayquartet.com/python-백준-1654-랜선-자르기/>

## 문제 이해

이 문제는 주어진 랜선을 잘라서 동일한 길이의 랜선 \(N\)개를 만들 수 있는지 판단하고, 만들 수 있는 랜선의 길이 중 가장 긴 길이를 찾는 문제입니다. 중요한 점은 \(N\)개의 랜선을 만들기 위해 각 랜선을 잘라내는 과정에서 **손실되는 길이는 무시**하며, 동일한 길이로 랜선을 잘라야 한다는 것입니다. 또한 \(N\)개 이상의 랜선을 만들 수 있다면 그것도 허용됩니다. 따라서, 우리는 특정 길이로 랜선을 잘랐을 때 \(N\)개 이상의 랜선을 만들 수 있는지 반복적으로 확인하면서 최적의 길이를 탐색해야 합니다.

## 입출력 조건

1. 입력 조건:

   - 첫 번째 줄에 두 정수 \(K\)와 \(N\)이 주어집니다.
     - \(K\)는 주어진 랜선의 개수이며, \(1 \leq K \leq 10,000\)입니다.
     - \(N\)은 만들어야 하는 랜선의 개수이며, \(1 \leq N \leq 1,000,000\)입니다.
     - 항상 \(K \leq N\)이 보장됩니다.
   - 다음 \(K\)줄에는 각 랜선의 길이가 자연수로 주어집니다.
     - 랜선의 길이는 \(1 \leq \text{길이} \leq 2^{31}-1\) 범위입니다.
   - 모든 랜선을 이용해 \(N\)개의 랜선을 만들 수 있음이 보장됩니다.

2. 출력 조건:
   - \(N\)개의 랜선을 만들기 위해 가능한 최대 랜선의 길이를 정수로 출력합니다.

## 접근 방식

이 문제는 **이분 탐색**을 이용하여 해결할 수 있습니다. 이유는 다음과 같습니다.

1. 랜선을 잘랐을 때 특정 길이로 \(N\)개 이상의 랜선을 만들 수 있는지 여부를 확인하는 작업은 **단조 증가/감소 관계**를 가집니다.
   - 예를 들어, 길이를 길게 설정하면 만들 수 있는 랜선의 개수는 줄어듭니다.
   - 길이를 짧게 설정하면 만들 수 있는 랜선의 개수는 늘어납니다.
2. 이처럼 특정 길이를 기준으로 가능 여부를 확인하는 작업이 단조적이라면, 이분 탐색을 통해 효율적으로 최대 길이를 탐색할 수 있습니다.
3. 탐색의 범위는 1부터 입력받은 랜선들 중 가장 긴 길이까지 설정합니다.
4. 특정 길이를 기준으로 랜선을 자르고, 만들 수 있는 개수를 계산하며 \(N\)개 이상인 경우 길이를 늘리고, 미만인 경우 줄이는 방식으로 탐색을 진행합니다.

<https://mayquartet.com/algorithm-binary-search/>

## 풀이 과정

1. **이분 탐색 초기화**:

   - 이분 탐색의 시작점 \(start\)를 1로 설정합니다.
   - 이분 탐색의 끝점 \(end\)를 입력받은 랜선의 최대 길이로 설정합니다.
   - 최적의 결과를 저장할 변수 \(result\)를 0으로 초기화합니다.

2. **이분 탐색 실행**:

   - \(start\)가 \(end\)보다 작거나 같은 동안 반복합니다.
   - 중간값 \(mid = (start + end) // 2\)를 계산합니다.
   - 현재 \(mid\) 길이로 각 랜선을 잘랐을 때 만들 수 있는 랜선의 개수를 계산합니다.
     - 각 랜선 길이를 \(mid\)로 나눈 몫을 모두 더합니다.
   - 계산된 랜선 개수가 \(N\) 이상이면:
     - \(result\)를 현재 \(mid\) 값으로 갱신합니다.
     - \(start\)를 \(mid + 1\)로 업데이트하여 더 긴 길이를 탐색합니다.
   - 계산된 랜선 개수가 \(N\) 미만이면:
     - \(end\)를 \(mid - 1\)로 업데이트하여 더 짧은 길이를 탐색합니다.

3. **결과 출력**:
   - 최종적으로 \(result\)에 저장된 값이 \(N\)개의 랜선을 만들기 위한 최대 길이가 됩니다.
   - 이 값을 출력합니다.

이 과정을 통해 입력받은 랜선의 길이와 \(N\)의 크기가 매우 커도 효율적으로 최적의 랜선 길이를 찾을 수 있습니다. 이분 탐색의 시간 복잡도는 \(O(\log(\text{최대 길이}) \times K)\)이며, 문제의 조건을 충분히 만족할 수 있습니다.

## 코드 구현

```python
def max_lan_length(k, n, lengths):
    # 이분 탐색의 시작점은 1, 최소 길이로 설정
    start = 1
    # 이분 탐색의 끝점은 랜선들 중 가장 긴 길이로 설정
    end = max(lengths)
    # 결과값을 저장할 변수, 초기값은 0
    result = 0

    # 이분 탐색 시작, start가 end보다 작거나 같을 때까지 반복
    while start <= end:
        # 중간값(mid)을 계산
        mid = (start + end) // 2
        # 현재 중간값으로 랜선을 잘랐을 때의 랜선 개수를 계산
        count = sum(l // mid for l in lengths)

        # 랜선 개수가 N개 이상이면
        if count >= n:
            # 결과값에 현재 중간값을 저장
            result = mid
            # 더 긴 길이를 탐색하기 위해 start를 증가
            start = mid + 1
        else:
            # 랜선 개수가 N개 미만이면 더 짧은 길이를 탐색
            end = mid - 1

    # 최종적으로 저장된 최대 길이를 반환
    return result

# 첫 줄에서 K(랜선 개수)와 N(필요한 랜선 개수)를 입력받음
k, n = map(int, input().split())
# K개의 랜선 길이를 입력받아 리스트로 저장
lengths = [int(input()) for _ in range(k)]
# 이분 탐색 결과로 계산된 최대 랜선 길이를 출력
print(max_lan_length(k, n, lengths))
```
