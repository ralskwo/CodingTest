# 문자 해독 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1593>

<https://mayquartet.com/python-백준-1593-문자-해독/>

## 문제 이해

이 문제는 특정 단어의 순열이 긴 문자열 내에서 몇 번 나타나는지를 찾는 문제입니다. 단어의 순열은 주어진 단어의 문자들을 조합하여 만들 수 있는 모든 문자열을 뜻합니다. 따라서 우리가 찾고자 하는 단어는 고정된 순서로 존재하는 것이 아니라, 문자들의 위치만 맞으면 됩니다. 문제를 푸는 핵심은 문자열의 특정 구간이 주어진 단어의 순열에 해당하는지 효율적으로 확인하는 것입니다. 입력으로 주어지는 문자열의 길이가 매우 크기 때문에, 비효율적인 방법으로는 문제를 해결할 수 없습니다. 효율적으로 문자열을 탐색하고, 필요한 조건을 만족하는 부분 문자열의 수를 찾아내는 것이 중요합니다.

## 입출력 조건

입력으로는 세 줄이 주어집니다. 첫 번째 줄에는 두 개의 정수 g와 |S|가 주어지며, 이는 찾고자 하는 단어 W의 길이 g와 문자열 S의 길이 |S|를 나타냅니다. 두 번째 줄에는 단어 W가 주어지고, 세 번째 줄에는 긴 문자열 S가 주어집니다.

출력으로는 문자열 S에서 W의 순열이 포함된 모든 부분 문자열의 개수를 출력해야 합니다.

입력 조건은 다음과 같습니다:

- 1 ≤ g ≤ 3000
- g ≤ |S| ≤ 3,000,000
- 문자열 W와 S는 알파벳으로만 구성되며, 대소문자를 구분합니다.

이러한 제약 조건으로 인해, 문제를 푸는 알고리즘은 반드시 O(|S|)에 가까운 효율성을 가져야 합니다.

## 접근 방식

이 문제를 해결하기 위해 슬라이딩 윈도우 기법과 해시를 조합하여 사용하는 방법을 선택해야 합니다. 슬라이딩 윈도우는 문자열에서 고정된 길이의 부분 문자열을 이동하며 처리하는 방법입니다. 이를 통해 각 윈도우가 주어진 조건을 만족하는지 빠르게 확인할 수 있습니다.

1. 먼저, 단어 W의 각 문자 빈도를 계산합니다. 이 빈도는 W의 모든 순열이 가져야 할 고유한 특징을 나타냅니다.
2. 그 다음, 문자열 S에서 길이가 g인 윈도우를 슬라이딩하면서 각 윈도우의 문자 빈도를 계산합니다.
3. 윈도우의 문자 빈도와 단어 W의 문자 빈도가 동일하면, 해당 윈도우는 W의 순열에 해당합니다.
4. 이 과정을 효율적으로 처리하기 위해 해시를 사용하여 빈도를 관리하고, 슬라이딩 윈도우를 이동할 때 추가되는 문자와 제거되는 문자의 빈도를 갱신합니다.

<https://mayquartet.com/algorithm-투-포인터two-pointer-알고리즘-이해하기/>

## 풀이 과정

1. **입력 처리 및 초기화**  
   먼저 단어 W와 문자열 S를 입력받습니다. 단어 W의 길이 g와 문자열 S의 길이 |S|도 입력받습니다. 이후, W의 문자 빈도를 계산하여 기준으로 설정합니다. 이를 위해 Python의 collections.Counter를 사용합니다. 문자열 S의 처음 g개의 문자 빈도도 계산하여 첫 번째 윈도우를 초기화합니다.

2. **초기 윈도우 검사**  
   첫 번째 윈도우의 문자 빈도가 단어 W의 문자 빈도와 동일한지 확인합니다. 동일하다면 이는 W의 순열과 일치하는 부분 문자열임을 의미하므로 카운트를 1 증가시킵니다.

3. **슬라이딩 윈도우 탐색**  
   두 번째 윈도우부터는 S에서 g번째 이후의 문자와 g번째 이전의 문자를 사용하여 윈도우를 갱신합니다. 새로 추가되는 문자의 빈도를 1 증가시키고, 제외되는 문자의 빈도를 1 감소시킵니다. 제외되는 문자의 빈도가 0이 되면 딕셔너리에서 삭제합니다. 갱신된 윈도우의 문자 빈도가 단어 W의 문자 빈도와 동일하다면 카운트를 증가시킵니다.

4. **결과 출력**  
   모든 윈도우를 탐색한 후, 조건을 만족하는 경우의 수를 출력합니다.

이 방식은 문자열 S를 한 번 순회하며 윈도우를 갱신하고, 윈도우의 빈도를 비교하므로 O(|S|)의 시간 복잡도로 문제를 해결할 수 있습니다. 따라서 입력 크기가 매우 큰 경우에도 효율적으로 처리할 수 있습니다.

## 코드 구현

```python
from collections import Counter

# Counter 모듈을 사용하여 문자열의 각 문자 빈도를 계산할 수 있도록 가져옴

g, s_len = map(int, input().split())
# 단어 W의 길이(g)와 문자열 S의 길이(s_len)를 입력받음

W = input().strip()
# 단어 W를 입력받고 양쪽 공백을 제거

S = input().strip()
# 문자열 S를 입력받고 양쪽 공백을 제거

w_count = Counter(W)
# 단어 W의 각 문자 빈도를 계산하여 w_count에 저장

window_count = Counter(S[:g])
# 문자열 S의 처음 g개의 문자에 대한 빈도를 계산하여 window_count에 저장

count = 0
# 조건을 만족하는 경우의 수를 저장할 변수 count 초기화

if w_count == window_count:
    count += 1
# 초기 윈도우(처음 g개의 문자)의 빈도와 W의 빈도가 같으면 count를 1 증가

for i in range(g, s_len):
    start_char = S[i - g]
    # 슬라이딩 윈도우의 시작 문자를 가져옴

    end_char = S[i]
    # 슬라이딩 윈도우의 끝 문자를 가져옴

    window_count[end_char] += 1
    # 새로 추가된 문자(end_char)의 빈도를 1 증가

    window_count[start_char] -= 1
    # 윈도우에서 제외된 문자(start_char)의 빈도를 1 감소

    if window_count[start_char] == 0:
        del window_count[start_char]
    # 제외된 문자의 빈도가 0이 되면 딕셔너리에서 삭제

    if window_count == w_count:
        count += 1
    # 현재 윈도우의 문자 빈도가 W의 문자 빈도와 같으면 count를 1 증가

print(count)
# 최종적으로 조건을 만족하는 경우의 수를 출력
```
