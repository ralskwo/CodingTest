# 수 묶기 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1744>

<https://mayquartet.com/python-백준-1744-수-묶기/>

## 문제 이해

이 문제는 주어진 수열에서 두 수를 묶어 곱하거나, 그대로 더해 최대의 합을 만드는 문제입니다.  
수열의 각 숫자는 위치와 상관없이 자유롭게 묶을 수 있으며, 한 번 묶은 숫자는 다시 묶을 수 없습니다.  
숫자끼리 곱했을 때 합이 더 커지는 경우가 존재하므로, 단순히 모든 숫자를 더하는 것보다 더 큰 합을 만들 수 있습니다.  
예를 들어, 수열이 2, 3, 4, 5로 이루어져 있다면 2와 3을 곱하고, 4와 5를 곱해 더하는 것이 모든 숫자를 단순히 더하는 것보다 더 큰 값을 만듭니다.

문제를 풀기 위해서는 양수, 음수, 0, 그리고 1을 어떻게 묶을지에 대한 전략을 세우는 것이 중요합니다.  
특히, 1을 곱하는 것은 합을 키우는 데 비효율적이며, 음수는 서로 곱해 양수로 만드는 것이 유리합니다.  
이와 같은 수의 특성을 파악하고 적절하게 묶는 방식이 핵심입니다.

## 입출력 조건

### 입력 조건

- 첫째 줄에 수열의 크기인 자연수 N이 주어집니다.
- N은 50보다 작은 자연수로, 최대 49까지 가능합니다.
- 둘째 줄부터 N개의 줄에 걸쳐 수열의 각 수가 하나씩 주어집니다.
- 수열을 구성하는 수는 -1000부터 1000 사이의 정수입니다.

### 출력 조건

- 주어진 수열을 적절히 묶었을 때, 합이 최대가 되는 값을 출력합니다.
- 정답은 항상 2의 31승보다 작습니다.

## 접근 방식

이 문제를 해결하기 위해서는 그리디 알고리즘을 사용해야 합니다.  
그리디 알고리즘은 매 순간 최선의 선택을 하여 전체 최적해를 구하는 방식입니다.  
이 문제에서는 양수와 음수를 구분하고, 서로 묶는 방식을 결정하는 것이 그리디 접근 방식의 핵심입니다.

1. 1보다 큰 양수는 큰 수끼리 묶어 곱하는 것이 유리합니다. 예를 들어, 5와 4를 묶어 20을 만들면 단순히 더하는 것보다 값이 큽니다.
2. 1은 곱하지 않고 더하는 것이 유리합니다. 1은 곱해도 값이 변하지 않으며, 곱하기보다는 더하는 것이 결과적으로 큰 합을 만듭니다.
3. 음수는 작은 수끼리 묶는 것이 유리합니다. 음수 두 개를 묶으면 양수가 되기 때문입니다. 예를 들어, -3과 -2를 묶으면 6이 됩니다.
4. 0은 음수와 묶어 음수를 상쇄시키는 데 사용됩니다. 예를 들어, -5와 0을 묶으면 0이 되어 음수를 제거할 수 있습니다.
5. 음수가 홀수 개라서 하나가 남는 경우, 0이 있다면 음수와 묶고, 0이 없다면 그대로 더해야 합니다.

<https://mayquartet.com/algorithm-알고리즘-greedy-그리디-알고리즘탐욕법-이해하기/>

## 풀이 과정

1. 주어진 수열을 순회하며 양수, 음수, 1을 분류합니다.

   - 1보다 큰 양수는 따로 리스트에 저장합니다.
   - 1은 바로 더합니다.
   - 0과 음수는 따로 리스트에 저장합니다.

2. 양수는 내림차순으로 정렬합니다.

   - 큰 수부터 두 개씩 묶어 곱하는 것이 유리하기 때문입니다.
   - 예를 들어, 5, 4, 3이 있으면 5와 4를 곱하고 3을 더합니다.

3. 음수는 오름차순으로 정렬합니다.

   - 작은 수끼리 묶어야 더 큰 양수를 만들 수 있기 때문입니다.
   - 예를 들어, -3, -2, -1이 있으면 -3과 -2를 곱하고, -1은 0이 있으면 묶고 없으면 그대로 더합니다.

4. 양수 리스트에서 두 개씩 묶어 곱합니다.

   - 묶을 수 있는 만큼 묶고, 하나 남는 경우는 그대로 더합니다.

5. 음수 리스트에서 두 개씩 묶어 곱합니다.

   - 음수도 두 개씩 묶고, 하나 남는 경우는 0과 묶거나 그대로 더합니다.

6. 최종적으로 계산된 결과를 출력합니다.

이 방식은 정렬 과정에서 O(N log N)의 시간 복잡도를 가지며, 이후 리스트를 순회하며 곱하는 과정은 O(N)입니다.  
따라서 전체 시간 복잡도는 O(N log N)으로, N이 최대 49이므로 충분히 빠르게 동작합니다.

## 코드 구현

```python
def max_sequence_sum(nums):
    positive = []
    negative = []
    result = 0

    for num in nums:
        if num > 1:
            positive.append(num)
        elif num == 1:
            result += 1
        else:
            negative.append(num)

    positive.sort(reverse=True)
    negative.sort()

    i = 0
    while i < len(positive) - 1:
        result += positive[i] * positive[i+1]
        i += 2
    if i < len(positive):
        result += positive[i]

    i = 0
    while i < len(negative) - 1:
        result += negative[i] * negative[i+1]
        i += 2
    if i < len(negative):
        if 0 in nums:
            result += 0
        else:
            result += negative[i]

    return result

n = int(input())
nums = [int(input()) for _ in range(n)]
print(max_sequence_sum(nums))
```
