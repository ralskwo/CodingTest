# 도둑 문제 풀이 및 설명

<https://www.acmicpc.net/problem/13422>

<https://mayquartet.com/python-백준-13422-도둑/>

## 문제 이해

이 문제는 원형 구조로 연결된 마을의 집에서 연속된 특정 개수의 집에서 돈을 훔치는 상황을 다룹니다. 도둑이 `M`개의 연속된 집에서 돈을 훔칠 때, 총 금액이 방범장치가 작동하는 조건 `K`보다 작아야만 도둑이 붙잡히지 않고 도망칠 수 있습니다. 집들은 원형으로 연결되어 있어 마지막 집과 첫 번째 집도 서로 이웃한 상태입니다. 도둑이 붙잡히지 않을 수 있는 연속된 집의 경우의 수를 구하는 것이 목표입니다.

문제의 핵심은 연속된 `M`개의 집에서 돈의 합을 빠르게 계산하고, 이 합이 `K`보다 작은 경우를 효율적으로 찾는 것입니다. 단순히 모든 구간의 합을 하나씩 계산하면 비효율적이므로, 슬라이딩 윈도우(Sliding Window)와 같은 효율적인 방법을 사용해야 합니다.

## 입출력 조건

### 입력 조건

1. 입력의 첫 번째 줄에는 테스트 케이스의 개수 `T`가 주어집니다.
2. 이후 각 테스트 케이스마다 두 줄로 입력이 구성됩니다:
   - 첫 번째 줄: 마을에 있는 집의 수 `N`, 연속된 집의 개수 `M`, 방범장치가 작동하는 최소 금액 `K`가 공백으로 구분되어 주어집니다.
     - `1 ≤ N ≤ 100,000`
     - `1 ≤ M ≤ N`
     - `1 ≤ K ≤ 1,000,000,000`
   - 두 번째 줄: 각 집에서 보관 중인 돈의 금액이 공백으로 구분되어 주어집니다.
     - 각 집의 돈의 금액은 `1 ≤ 금액 ≤ 10,000`입니다.
3. 각 테스트 케이스의 집 정보는 원형 구조를 가지므로, 배열의 마지막과 처음이 연결된 것으로 간주합니다.

### 출력 조건

1. 각 테스트 케이스에 대해, 도둑이 붙잡히지 않고 돈을 훔칠 수 있는 연속된 집의 경우의 수를 한 줄에 하나씩 출력합니다.

## 접근 방식

이 문제를 해결하려면 효율적인 연속 부분합 계산이 필요합니다. 단순히 모든 경우를 계산하면 `O(N * M)`의 시간이 걸리므로 비효율적입니다. 이 문제를 `O(N)` 시간 복잡도로 해결하기 위해 다음 방법을 사용할 수 있습니다:

1. **슬라이딩 윈도우(Sliding Window)**:

   - 슬라이딩 윈도우는 고정된 크기의 연속 구간 합을 빠르게 갱신할 수 있는 방법입니다.
   - 처음 `M`개의 합을 계산한 후, 윈도우의 좌우 끝을 움직이며 다음 구간 합을 갱신합니다.
   - 원형 배열의 특성을 고려하여 끝부분을 넘어가면 배열의 시작 부분을 참조하도록 만듭니다.

2. **원형 배열 처리**:

   - 배열이 원형으로 연결되어 있으므로, 슬라이딩 윈도우를 `N`번 반복하며 윈도우 끝이 `N`을 초과할 때 시작 부분으로 돌아오도록 처리합니다.
   - 이를 위해 윈도우의 끝 인덱스를 `(i + M) % N` 형태로 계산합니다.

3. **특수 케이스 처리**:

   - `M`과 `N`이 같다면, 전체 집의 합을 한 번만 계산하여 `K`와 비교하면 됩니다.

4. **효율성**:
   - 각 테스트 케이스에서 슬라이딩 윈도우로 `O(N)`의 시간 안에 결과를 도출할 수 있습니다.
   - 따라서 전체 시간 복잡도는 `O(T * N)`입니다.

<https://mayquartet.com/algorithm-투-포인터two-pointer-알고리즘-이해하기/>

## 풀이 과정

1. **입력 데이터 처리**:

   - 테스트 케이스의 수 `T`를 읽습니다.
   - 각 테스트 케이스에 대해 `N`, `M`, `K`와 각 집의 돈 정보를 읽습니다.

2. **특수 케이스 처리**:

   - `M`과 `N`이 같은 경우, 전체 집의 돈의 합을 계산하고 `K`와 비교합니다. `K`보다 작다면 결과에 1을 추가하고, 그렇지 않다면 0을 추가합니다.

3. **슬라이딩 윈도우 초기화**:

   - 처음 `M`개의 집에 대한 합계를 계산하여 `current_sum`에 저장합니다.
   - 조건을 만족하는 경우의 수를 세기 위해 `count`를 0으로 초기화합니다.

4. **슬라이딩 윈도우 실행**:

   - `N`번 반복하며 슬라이딩 윈도우를 갱신합니다.
   - 현재 `current_sum`이 `K`보다 작다면 `count`를 증가시킵니다.
   - 윈도우의 시작 값을 `current_sum`에서 빼고, 윈도우에 새로 추가되는 값을 `current_sum`에 더합니다.
   - 원형 배열의 특성을 고려하여 새로 추가되는 값의 인덱스를 `(i + M) % N`으로 계산합니다.

5. **결과 저장 및 출력**:
   - 각 테스트 케이스의 결과를 리스트에 저장합니다.
   - 모든 테스트 케이스를 처리한 후, 결과를 순서대로 출력합니다. 각 결과는 한 줄에 하나씩 출력합니다.

## 코드 구현

```python
def count_ways_to_steal():
    import sys  # 표준 입력을 사용하기 위해 sys 모듈을 가져옵니다.
    input = sys.stdin.read  # 표준 입력을 읽기 위한 함수 참조를 가져옵니다.
    data = input().splitlines()  # 입력 데이터를 줄 단위로 분리하여 리스트로 저장합니다.

    T = int(data[0])  # 첫 번째 줄에 주어진 테스트 케이스의 개수를 정수로 변환합니다.
    results = []  # 각 테스트 케이스의 결과를 저장할 리스트를 초기화합니다.

    index = 1  # 입력 데이터를 순회할 때 사용할 인덱스를 초기화합니다.
    for _ in range(T):  # 각 테스트 케이스에 대해 반복합니다.
        # 현재 테스트 케이스의 정보(N, M, K)를 정수로 변환하여 읽어옵니다.
        N, M, K = map(int, data[index].split())
        index += 1  # 다음 줄로 인덱스를 이동합니다.

        # 현재 테스트 케이스에서 각 집의 돈의 양을 리스트로 읽어옵니다.
        money = list(map(int, data[index].split()))
        index += 1  # 다음 줄로 인덱스를 이동합니다.

        # 특수 케이스: 연속된 집의 수 M이 전체 집의 수 N과 같은 경우
        if M == N:
            # 전체 집의 돈의 합이 K보다 작으면 1을 결과에 추가, 아니면 0을 추가합니다.
            if sum(money) < K:
                results.append(1)
            else:
                results.append(0)
            continue  # 다음 테스트 케이스로 넘어갑니다.

        # 초기 슬라이딩 윈도우 합을 계산합니다. 처음 M개의 집의 돈의 합입니다.
        current_sum = sum(money[:M])
        count = 0  # 현재 조건을 만족하는 방법의 수를 초기화합니다.

        # 슬라이딩 윈도우를 이용해 원형 구조에서 모든 연속된 M개의 집을 검사합니다.
        for i in range(N):
            # 현재 슬라이딩 윈도우의 합이 K보다 작으면 방법 수를 증가시킵니다.
            if current_sum < K:
                count += 1

            # 슬라이딩 윈도우를 업데이트합니다.
            # 윈도우에서 빠져나가는 집의 돈을 뺍니다.
            current_sum -= money[i]
            # 윈도우에 새로 추가되는 집의 돈을 더합니다. 원형 구조를 고려하여 % N을 사용합니다.
            current_sum += money[(i + M) % N]

        # 현재 테스트 케이스에서 가능한 방법 수를 결과 리스트에 추가합니다.
        results.append(count)

    # 모든 테스트 케이스의 결과를 출력합니다.
    for result in results:
        print(result)

# 이 코드는 실행 시점에서 실행되며, 메인 프로그램의 시작점을 정의합니다.
if __name__ == "__main__":
    count_ways_to_steal()
```
