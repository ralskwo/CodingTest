# 소수 경로 문제 풀이 및 설명

https://www.acmicpc.net/problem/1963

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-1963-%ec%86%8c%ec%88%98-%ea%b2%bd%eb%a1%9c-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 두 개의 네 자리 소수 A와 B를 주고, A를 B로 변환하는 데 필요한 최소 단계를 찾는 문제입니다. 단, 숫자를 변환할 때는 한 자리 숫자만 바꿀 수 있으며, 그 과정에서 만들어지는 중간 숫자들도 항상 소수여야 합니다. 예를 들어, A를 1033, B를 8179로 설정하고, 1033에서 8179로 변환하는 과정에서 거치는 중간 숫자들도 모두 소수여야 하며, 한 번에 한 자리만 변경할 수 있습니다.

이 문제에서 중요한 점은 숫자의 각 자리(천의 자리, 백의 자리, 십의 자리, 일의 자리) 중 한 자리씩만 변경할 수 있다는 제한입니다. 또한, 변경 후의 숫자는 항상 1000 이상의 네 자리 소수여야 하므로 1000 미만의 숫자나 소수가 아닌 숫자는 유효한 변환으로 인정되지 않습니다.

목표는 주어진 두 소수 사이의 변환에 필요한 최소한의 변환 횟수를 찾는 것입니다. 만약 변환이 불가능할 경우, 그 결과로 "Impossible"을 출력해야 합니다.

## 입출력 조건

### 입력

1. 첫 번째 줄에는 테스트 케이스의 수 T가 주어집니다.
2. 그다음 T개의 줄에 걸쳐, 각 줄에 네 자리 소수 A와 B가 주어집니다. 이 두 소수는 변환을 시작하는 수 A와 목표 수 B를 의미합니다.
3. 입력으로 주어지는 모든 숫자는 네 자리 소수입니다(1000 이상 9999 이하).

### 출력

1. 각 테스트 케이스에 대해, A를 B로 변환하는 데 필요한 최소 단계 수를 출력합니다.
2. 만약 A에서 B로 변환할 수 없는 경우에는 "Impossible"을 출력합니다.

## 접근 방식

이 문제는 그래프 탐색 문제로 볼 수 있습니다. 각 소수를 그래프의 노드로 보고, 한 자리만 바꿔서 얻을 수 있는 소수를 그 노드의 이웃으로 생각하면 됩니다. 따라서 한 자리씩 바꿔가며 목표 소수에 도달할 수 있는지를 탐색하는 것이 목표입니다.

이때 한 자리만 바꾼 숫자가 네 자리 소수여야 하므로, 미리 1000부터 9999까지의 소수를 구해두는 것이 중요합니다. 이를 위해서는 효율적인 소수 구하는 방법인 에라토스테네스의 체를 사용할 수 있습니다.

탐색 알고리즘으로는 너비 우선 탐색(BFS)이 적합합니다. BFS는 그래프에서 최단 경로를 찾는 알고리즘으로, 시작점에서부터 인접한 노드를 순차적으로 탐색하며 목표 지점까지의 최단 경로를 찾을 수 있습니다. 이 문제에서 한 번의 변환은 한 자리 숫자를 바꾸는 것이므로, BFS를 통해 A에서 B까지 가는 최단 경로를 찾아낼 수 있습니다.

## 풀이 과정

1. **소수 구하기**:
   먼저, 에라토스테네스의 체를 사용하여 1000부터 9999까지의 네 자리 소수를 미리 구합니다. 이 소수들은 탐색 과정에서 유효한 중간 단계가 될 수 있습니다. 소수 판별을 위한 배열을 만들어, 각 숫자가 소수인지 여부를 빠르게 확인할 수 있도록 합니다.

2. **이웃 소수 찾기**:
   주어진 소수에서 한 자리 숫자만 바꿨을 때 나올 수 있는 네 자리 수 중에서, 소수인 경우에만 유효한 이웃으로 간주합니다. 각 자리에 대해 0부터 9까지의 숫자를 시도해보고, 소수 여부를 검사하여 해당 숫자가 소수라면 이웃 소수 리스트에 추가합니다. 첫 번째 자리 수는 0이 될 수 없으므로, 1000 이상의 숫자만 허용합니다.

3. **BFS를 이용한 탐색**:
   시작 소수 A에서 목표 소수 B로의 최소 변환 횟수를 찾기 위해 BFS를 사용합니다. BFS는 큐(Queue)를 사용하여 현재 탐색 중인 소수와 그 소수까지 도달하는 데 걸린 변환 횟수를 저장합니다. 큐에서 하나씩 꺼내며, 이웃 소수를 찾아 큐에 추가하고, 목표 소수 B에 도달하면 그때의 변환 횟수를 반환합니다. 이 과정에서 이미 방문한 소수는 다시 탐색하지 않도록 방문 배열을 사용합니다.

4. **결과 출력**:
   BFS 탐색을 통해 두 소수 사이에 경로가 존재하는 경우, 변환 횟수를 출력합니다. 경로가 존재하지 않으면 "Impossible"을 출력합니다.

## 코드 구현

```python
from collections import deque  # deque를 사용하여 BFS(너비 우선 탐색)를 구현하기 위해 collections 모듈에서 deque를 가져옴

def sieve_of_eratosthenes():  # 에라토스테네스의 체 알고리즘을 사용하여 1000부터 9999까지의 소수를 미리 구하는 함수
    is_prime = [True] * 10000  # 숫자 0부터 9999까지 소수 여부를 저장하는 배열, 처음엔 모두 소수라고 가정
    is_prime[0] = is_prime[1] = False  # 0과 1은 소수가 아니므로 False로 설정

    for i in range(2, int(10000**0.5) + 1):  # 2부터 10000의 제곱근까지 반복, 소수 여부를 판단
        if is_prime[i]:  # i가 소수인 경우
            for j in range(i * i, 10000, i):  # i의 배수들을 소수가 아니라고 표시
                is_prime[j] = False  # i의 배수들은 소수가 아니므로 False로 설정

    primes = [i for i in range(1000, 10000) if is_prime[i]]  # 1000 이상 9999 이하의 소수 리스트 생성
    return is_prime  # 소수 여부를 나타내는 배열 반환

def get_neighbors(num, is_prime):  # 주어진 숫자에서 한 자리만 바꿔서 나오는 네 자리 소수를 찾는 함수
    neighbors = []  # 이웃 소수를 저장할 리스트
    num_str = str(num)  # 숫자를 문자열로 변환하여 각 자리 수에 접근

    for i in range(4):  # 네 자리 수의 각 자리마다 반복
        for d in '0123456789':  # 각 자리 숫자를 0부터 9까지 대입
            if num_str[i] != d:  # 현재 자리 숫자와 다른 숫자로만 변경
                new_num = int(num_str[:i] + d + num_str[i+1:])  # 해당 자리를 새로운 숫자로 변경한 새로운 숫자 생성
                if new_num >= 1000 and is_prime[new_num]:  # 1000 이상이며 소수인 경우
                    neighbors.append(new_num)  # 이웃 소수 리스트에 추가

    return neighbors  # 가능한 이웃 소수 리스트 반환

def bfs(start, end, is_prime):  # BFS를 사용해 최소 변환 횟수를 찾는 함수
    if start == end:  # 시작 소수와 끝 소수가 같으면 0 반환
        return 0

    queue = deque([(start, 0)])  # 큐에 시작 소수와 변환 횟수 0을 넣음
    visited = [False] * 10000  # 각 숫자가 방문되었는지 여부를 저장할 배열
    visited[start] = True  # 시작 소수는 방문했으므로 True로 설정

    while queue:  # 큐가 빌 때까지 반복
        current, steps = queue.popleft()  # 큐에서 현재 소수와 변환 횟수를 꺼냄

        for neighbor in get_neighbors(current, is_prime):  # 현재 소수에서 한 자리만 바꾼 소수들을 반복
            if not visited[neighbor]:  # 아직 방문하지 않은 소수에 대해
                if neighbor == end:  # 이웃 소수가 목표 소수와 같으면
                    return steps + 1  # 변환 횟수를 반환
                visited[neighbor] = True  # 방문 처리
                queue.append((neighbor, steps + 1))  # 이웃 소수와 변환 횟수를 큐에 추가

    return "Impossible"  # 목표 소수에 도달하지 못하면 "Impossible" 반환

def main():  # 메인 함수
    T = int(input())  # 테스트 케이스의 수 입력
    is_prime = sieve_of_eratosthenes()  # 미리 1000부터 9999까지의 소수를 구함

    for _ in range(T):  # 각 테스트 케이스에 대해
        start, end = map(int, input().split())  # 시작 소수와 목표 소수 입력
        result = bfs(start, end, is_prime)  # BFS로 최소 변환 횟수를 계산
        print(result)  # 결과 출력

if __name__ == "__main__":  # 프로그램의 시작점
    main()  # 메인 함수 호출
```
