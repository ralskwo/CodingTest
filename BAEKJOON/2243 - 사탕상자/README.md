# 사탕상자 문제 풀이 및 설명

https://www.acmicpc.net/problem/2243

## 문제 이해

이 문제는 특정 맛의 사탕을 관리하는 상황을 효율적으로 처리하는 것이 핵심입니다. 사탕상자에는 다양한 맛의 사탕이 들어 있으며, 이 사탕의 맛은 1부터 1,000,000까지의 정수로 표현됩니다. 수정이는 동생이 말을 잘 들었을 때 그에 따라 사탕을 꺼내주는데, 이때 동생이 얼마나 말을 잘 들었느냐에 따라 사탕상자에서 몇 번째로 맛있는 사탕을 꺼내 주어야 합니다. 즉, 사탕상자에 있는 사탕들 중 특정 순위에 해당하는 사탕을 빠르게 찾아서 꺼내는 것이 중요합니다. 또한, 사탕을 추가하거나 제거하는 작업도 수행해야 합니다. 문제에서 요구하는 것은 이러한 작업을 효율적으로 수행하는 프로그램을 작성하는 것입니다.

## 입출력 조건

- **입력**:
  1. 첫 번째 줄에는 수정이가 사탕상자에 손을 댄 횟수 `n`(1 ≤ n ≤ 100,000)이 주어집니다.
  2. 그다음 n개의 줄에는 각각 두 가지 유형의 명령이 주어집니다:
     - A가 1인 경우: 사탕상자에서 사탕을 꺼내는 경우. 이때 B는 꺼낼 사탕의 순위를 나타냅니다.
     - A가 2인 경우: 사탕을 상자에 넣거나 빼는 경우. B는 사탕의 맛을, C는 사탕의 개수를 나타냅니다.
- **출력**:
  - A가 1인 모든 경우에 대해서 꺼낸 사탕의 맛 번호를 출력합니다.

## 접근 방식

이 문제는 자료 구조를 적절히 선택하여 효율적으로 해결할 수 있습니다. 주어진 조건을 충족하기 위해 세그먼트 트리(Segment Tree)를 사용하는 것이 적합합니다. 세그먼트 트리는 구간 합 또는 구간의 특정 값을 빠르게 계산할 수 있는 자료 구조입니다. 이 문제에서는 특정 순위의 사탕을 찾고 제거하는 작업을 빠르게 수행하기 위해 세그먼트 트리를 사용할 수 있습니다. 또한, 이분 탐색을 통해 세그먼트 트리에서 원하는 순위의 사탕을 효율적으로 찾을 수 있습니다. 세그먼트 트리와 이분 탐색을 결합하면 O(log n) 시간 복잡도로 문제를 해결할 수 있습니다.

## 풀이 과정

1. **세그먼트 트리 초기화**:

   - 사탕의 맛 번호 범위는 1부터 1,000,000까지입니다. 이 범위를 커버할 수 있도록 크기가 충분한 세그먼트 트리를 초기화합니다. 트리의 각 노드는 특정 맛 번호에 해당하는 사탕의 개수를 나타냅니다.

2. **사탕 추가/제거**:

   - 명령어에서 A가 2인 경우, 주어진 맛 번호에 대해 사탕을 추가하거나 제거합니다. 이를 위해 트리의 해당 노드를 업데이트합니다. `add` 메서드를 통해 사탕의 개수를 트리에 반영합니다. 예를 들어, 맛 번호 B의 사탕을 C개 추가하는 경우, 트리에서 해당 노드와 그 부모 노드까지 값을 업데이트합니다.

3. **특정 순위의 사탕 찾기**:

   - 명령어에서 A가 1인 경우, 특정 순위에 해당하는 사탕을 꺼내야 합니다. 이때 `find_kth` 메서드를 사용하여 세그먼트 트리에서 k번째로 맛있는 사탕을 찾습니다. 트리의 루트부터 시작하여 왼쪽 자식과 오른쪽 자식을 탐색하면서 k번째 사탕의 위치를 찾습니다.

4. **사탕 제거**:

   - 찾은 사탕의 맛 번호를 결과 리스트에 저장한 후, 트리에서 해당 사탕을 제거합니다. 이는 `add` 메서드를 호출하여 해당 맛 번호의 사탕 개수를 1만큼 줄이는 방식으로 이루어집니다.

5. **결과 출력**:
   - 모든 명령어 처리가 끝나면 결과 리스트를 출력합니다. 각 사탕의 맛 번호는 순서대로 출력됩니다.

이 접근 방식은 문제에서 요구하는 대로 특정 순위의 사탕을 빠르게 찾고 제거할 수 있으며, 사탕의 추가 및 제거 작업도 효율적으로 처리할 수 있습니다. 이를 통해 시간 복잡도와 메모리 사용량을 최적화하면서 문제를 해결할 수 있습니다.

## 코드 구현

```python
class SegmentTree:
    def __init__(self, n):  # 세그먼트 트리 초기화 메서드
        self.n = n  # 트리에서 관리할 맛의 범위 크기 (예: 1부터 n까지)
        self.tree = [0] * (4 * n)  # 트리 배열 초기화 (4*n 크기)

    def update(self, idx, diff, node, node_left, node_right):  # 트리 업데이트 메서드
        if idx < node_left or node_right < idx:  # 업데이트하려는 인덱스가 현재 노드의 범위 밖이면 종료
            return
        self.tree[node] += diff  # 현재 노드에 diff를 더함 (사탕의 수 변화 반영)
        if node_left != node_right:  # 리프 노드가 아닌 경우
            mid = (node_left + node_right) // 2  # 현재 구간을 반으로 나눔
            # 좌측 자식 노드에 업데이트 전파
            self.update(idx, diff, node * 2, node_left, mid)
            # 우측 자식 노드에 업데이트 전파
            self.update(idx, diff, node * 2 + 1, mid + 1, node_right)

    def query(self, k, node, node_left, node_right):  # k번째 사탕 찾기 위한 쿼리 메서드
        if node_left == node_right:  # 리프 노드에 도달한 경우
            return node_left  # 해당 리프 노드의 인덱스를 반환 (사탕의 맛 번호)
        mid = (node_left + node_right) // 2  # 현재 구간을 반으로 나눔
        if k <= self.tree[node * 2]:  # k번째 사탕이 왼쪽 구간에 있는 경우
            return self.query(k, node * 2, node_left, mid)  # 왼쪽 자식 노드로 이동하여 계속 탐색
        else:  # k번째 사탕이 오른쪽 구간에 있는 경우
            # 오른쪽 자식 노드로 이동하며, 왼쪽 노드의 사탕 수를 k에서 뺌
            return self.query(k - self.tree[node * 2], node * 2 + 1, mid + 1, node_right)

    def add(self, idx, diff):  # 사탕의 수를 추가하거나 제거하는 메서드
        self.update(idx, diff, 1, 1, self.n)  # 인덱스 idx에 해당하는 사탕의 변화를 트리에 반영

    def find_kth(self, k):  # k번째 맛의 사탕을 찾는 메서드
        return self.query(k, 1, 1, self.n)  # k번째 사탕의 맛 번호를 반환

import sys
input = sys.stdin.read  # 입력을 빠르게 처리하기 위해 sys.stdin.read 사용
data = input().splitlines()  # 여러 줄 입력을 받아 줄 단위로 나눔

n = int(data[0])  # 첫 번째 줄: 수정이가 사탕상자에 손을 댄 횟수
commands = [list(map(int, line.split())) for line in data[1:]]  # 나머지 줄: 명령어 리스트로 변환

MAX_TASTE = 1000000  # 사탕의 맛 번호의 최대값 (1부터 1000000까지)
seg_tree = SegmentTree(MAX_TASTE)  # 사탕 맛 범위를 기반으로 세그먼트 트리 생성

result = []  # 출력 결과를 저장할 리스트

for command in commands:  # 각 명령어를 순차적으로 처리
    if command[0] == 1:  # A가 1인 경우 (사탕을 꺼내는 경우)
        k = command[1]  # B: 꺼낼 사탕의 순위
        taste = seg_tree.find_kth(k)  # k번째 사탕의 맛 번호 찾기
        result.append(taste)  # 결과 리스트에 추가
        seg_tree.add(taste, -1)  # 해당 맛의 사탕을 1개 제거
    elif command[0] == 2:  # A가 2인 경우 (사탕을 넣거나 제거하는 경우)
        taste = command[1]  # B: 넣을 사탕의 맛 번호
        count = command[2]  # C: 넣을 사탕의 개수 (음수면 제거)
        seg_tree.add(taste, count)  # 해당 맛의 사탕을 count만큼 추가 또는 제거

sys.stdout.write('\n'.join(map(str, result)) + '\n')  # 모든 출력 결과를 한 번에 출력
```
