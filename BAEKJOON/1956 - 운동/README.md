# 운동 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1956>

<https://mayquartet.com/python-파이썬-백준-1956-운동/>

## 문제 이해

이 문제는 방향 그래프에서 사이클을 찾는 문제입니다. 구체적으로, 운동을 위해 마을들 사이의 도로를 따라 이동할 때, 출발한 마을로 다시 돌아오는 경로 중에서 그 길이의 합이 최소가 되는 사이클을 찾는 것이 목표입니다. 주어진 도로들은 일방통행이기 때문에, 마을 간의 이동이 한 방향으로만 가능합니다. 이 문제에서는 최소 사이클을 찾기 위해 각 도로의 거리가 주어지고, 이를 바탕으로 가능한 모든 사이클 중에서 길이가 가장 짧은 것을 찾아야 합니다. 최소 사이클이란 사이클을 이루는 도로들의 길이의 합이 가장 작은 경로를 말합니다. 문제를 푸는 과정에서 주의할 점은, 단순히 특정 마을에서 시작해서 다시 돌아오는 왕복 형태의 경로도 사이클로 취급해야 한다는 점입니다.

## 입출력 조건

- **입력 조건**:
  - 첫 번째 줄에는 정점(마을)의 개수 `V`와 간선(도로)의 개수 `E`가 공백으로 구분되어 주어집니다. (`2 ≤ V ≤ 400`, `0 ≤ E ≤ V(V-1)`)
  - 다음 `E`개의 줄에는 각각 세 개의 정수 `a`, `b`, `c`가 주어집니다. 이는 `a`번 마을에서 `b`번 마을로 가는 거리가 `c`임을 의미합니다. `c`는 10,000 이하의 자연수이며, `(a, b)` 쌍이 같은 도로가 여러 번 주어지지 않습니다.
  - 마을의 번호는 1번부터 `V`번까지 매겨져 있습니다.
- **출력 조건**:
  - 첫째 줄에 최소 사이클의 도로 길이의 합을 출력합니다. 사이클을 찾을 수 없는 경우에는 `-1`을 출력합니다.

## 접근 방식

이 문제를 해결하기 위해서는 **플로이드-워셜 알고리즘**을 사용해야 합니다. 이 알고리즘은 그래프에서 모든 정점 간의 최단 경로를 계산하는 알고리즘으로, 시간 복잡도가 `O(V^3)`입니다. 플로이드-워셜 알고리즘을 사용하면, 각 정점 간의 최단 거리를 계산할 수 있고, 이 정보를 이용해 최소 사이클을 찾을 수 있습니다.

- **사이클을 찾는 방법**:
  - 플로이드-워셜 알고리즘을 통해 각 정점에서 자신으로 돌아오는 최단 경로를 찾을 수 있습니다. 이는 `dist[i][i]`의 값을 통해 구할 수 있으며, 이는 정점 `i`에서 출발하여 다른 정점을 거쳐 다시 `i`로 돌아오는 경로의 최단 거리입니다.
  - 이 값을 최소화하는 것이 곧 문제에서 요구하는 최소 사이클을 찾는 것입니다.
- **그래프 초기화와 갱신**:
  - 무한대 값을 사용하여 초기에는 경로가 없음을 나타냅니다.
  - 각 간선을 입력받을 때 `dist[a][b]` 값을 갱신하여, 초기 상태에서의 거리를 반영합니다.
  - 플로이드-워셜 알고리즘으로 `dist[i][j]`를 경유하는 경로와 직접 연결된 경로를 비교하여 최단 거리로 갱신합니다.

이 접근 방식을 사용하면, 각 정점에서 자신으로 돌아오는 경로 중 가장 짧은 경로를 찾아낼 수 있고, 이 값이 문제에서 요구하는 최소 사이클의 길이입니다.

## 풀이 과정

1. **입력 처리 및 초기화**:

   - `V`와 `E`를 입력받아 정점과 간선의 수를 정의합니다.
   - 모든 정점 간의 최단 거리를 나타낼 `dist` 배열을 생성하고, 모든 값을 무한대(`inf`)로 초기화합니다. 이는 초기에는 모든 정점 간에 연결된 경로가 없음을 나타내기 위함입니다.
   - 자기 자신에서 자기 자신으로 가는 거리는 0으로 설정합니다. 이는 `dist[i][i] = 0`으로 처리합니다.

2. **간선 정보 입력 및 초기 거리 설정**:

   - `E`개의 간선 정보를 입력받아 `dist` 배열을 갱신합니다.
   - 각 간선 `(a, b, c)`에 대해, `dist[a-1][b-1] = c`로 설정합니다. 이는 `a`번 정점에서 `b`번 정점으로 가는 거리가 `c`임을 나타냅니다.
   - 입력되는 정점 번호는 1부터 시작하지만, 배열에서는 0부터 인덱스를 사용하기 때문에, 인덱스를 맞추기 위해 `a-1`과 `b-1`로 조정합니다.

3. **플로이드-워셜 알고리즘 적용**:

   - 세 개의 중첩된 반복문을 사용하여, 모든 정점 쌍 간의 최단 거리를 계산합니다.
   - `k`는 경유할 수 있는 중간 정점을 의미합니다. `i`는 출발 정점, `j`는 도착 정점을 의미합니다.
   - `dist[i][j]`와 `dist[i][k] + dist[k][j]`를 비교하여 더 작은 값을 선택합니다. 즉, 정점 `k`를 경유하는 경로가 더 짧으면 이를 `dist[i][j]`에 반영합니다.
   - 이 과정이 완료되면, `dist[i][j]`에는 모든 정점 간의 최단 거리가 저장됩니다.

4. **최소 사이클 찾기**:

   - `dist` 배열에서 각 정점 `i`에 대해 `dist[i][i]` 값을 확인합니다. 이 값은 정점 `i`에서 시작해 다른 정점을 거쳐 다시 `i`로 돌아오는 최단 경로의 길이를 의미합니다.
   - `dist[i][i]` 값 중에서 가장 작은 값을 `min_cycle`로 갱신합니다.
   - 초기값인 무한대(`inf`)와 비교하여 더 작은 값이 발견될 때마다 이를 `min_cycle`로 저장합니다.

5. **결과 반환**:
   - 가능한 최소 사이클이 존재하지 않으면, 즉 `min_cycle`이 여전히 무한대(`inf`)라면 이는 사이클이 없다는 의미이므로 `-1`을 반환합니다.
   - 사이클이 존재할 경우 `min_cycle`의 값을 반환하여 최소 사이클의 길이를 출력합니다.

이 과정을 통해, 문제에서 요구하는 출발점으로 돌아오는 최소 거리의 사이클을 찾을 수 있습니다. 이 문제는 플로이드-워셜 알고리즘의 특징을 잘 이해하고, 이를 적절하게 활용하여 모든 정점 간의 최단 경로를 계산하는 것이 핵심입니다.

## 코드 구현

```python
import sys  # 표준 입력을 사용하기 위해 sys 모듈을 임포트

def floyd_warshall_min_cycle(V, edges):
    inf = float('inf')  # 무한대를 나타내기 위해 inf 변수에 float('inf') 할당
    dist = [[inf] * V for _ in range(V)]  # V x V 크기의 2차원 리스트를 생성하고 모든 값을 inf로 초기화

    # 간선 정보를 바탕으로 dist 배열 초기화
    for a, b, c in edges:
        dist[a - 1][b - 1] = min(dist[a - 1][b - 1], c)  # a에서 b로 가는 거리를 c로 설정 (1-based index를 0-based로 변환)

    # 플로이드-워셜 알고리즘 수행
    for k in range(V):  # 중간에 거쳐가는 정점 k에 대해 반복
        for i in range(V):  # 출발 정점 i에 대해 반복
            for j in range(V):  # 도착 정점 j에 대해 반복
                # dist[i][j]를 경유하는 경우와 비교하여 더 짧은 거리로 갱신
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]

    min_cycle = inf  # 최소 사이클의 길이를 저장할 변수 초기화
    for i in range(V):  # 각 정점 i에 대해 반복
        if dist[i][i] < min_cycle:  # 정점 i에서 다시 i로 돌아오는 경로의 길이가 최소값보다 작으면 갱신
            min_cycle = dist[i][i]

    # 가능한 최소 사이클이 존재하지 않으면 -1 반환, 그렇지 않으면 최소 사이클의 길이를 반환
    return min_cycle if min_cycle != inf else -1

# 입력 처리: 정점의 수 V와 간선의 수 E를 입력받음
V, E = map(int, sys.stdin.readline().split())
# 간선 정보를 E개의 줄에 걸쳐 입력받아 리스트로 저장
edges = [list(map(int, sys.stdin.readline().split())) for _ in range(E)]

# 최소 사이클 길이를 계산하고 결과 출력
result = floyd_warshall_min_cycle(V, edges)
print(result)
```
