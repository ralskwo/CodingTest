# 미로 탐색 문제 풀이 과정

https://www.acmicpc.net/problem/2178

## 문제 이해

주어진 문제는 N x M 크기의 미로에서 출발점 (1, 1)에서 도착점 (N, M)까지 이동하는 최소 칸 수를 찾는 것입니다. 미로는 0과 1로 이루어져 있으며, 1은 이동할 수 있는 칸을, 0은 이동할 수 없는 칸을 나타냅니다. 이동은 상하좌우로만 가능합니다.

## 접근 방식

이 문제는 그래프 탐색 문제로, BFS(너비 우선 탐색)를 사용하여 해결할 수 있습니다. BFS는 최단 경로를 찾는 데 효과적이기 때문에, 출발점에서 도착점까지의 최단 경로를 찾는 데 적합합니다.

## 풀이 과정

### 1. 입력 받기

N과 M을 입력받고, 미로를 2차원 리스트로 입력받습니다.

### 2. BFS 초기화

BFS를 위한 큐를 초기화하고, 시작점을 큐에 넣습니다. 또한 방문 여부를 체크하기 위한 리스트를 초기화합니다.

### 3. BFS 수행

큐에서 노드를 꺼내 4방향(상, 하, 좌, 우)으로 이동 가능한지 체크합니다. 이동할 수 있는 경우, 해당 노드를 큐에 넣고, 거리를 업데이트하며 방문 처리를 합니다.

### 4. 도착점 도달

도착점에 도달하면 그때까지의 거리를 반환합니다.

## 상세 풀이

### 1. 입력 데이터 처리

- 첫 줄에 N과 M을 입력받습니다.
- N개의 줄에 걸쳐 미로를 입력받아 2차원 리스트로 저장합니다.

### 2. BFS 구현

- 이동 방향(상, 하, 좌, 우)을 나타내는 리스트를 정의합니다.
- 큐를 초기화하고 시작점 (0, 0)과 거리를 큐에 넣습니다.
- 방문 여부를 체크하기 위한 2차원 리스트를 초기화하고, 시작점을 방문 처리합니다.

### 3. 탐색 과정

- 큐에서 현재 위치와 거리를 꺼내 4방향으로 이동 가능한지 체크합니다.
- 이동 가능한 경우, 큐에 새로운 위치와 업데이트된 거리를 넣고 방문 처리를 합니다.
- 도착점에 도달하면 현재까지의 거리를 반환합니다.

## 코드 설명

```python
from collections import deque

def bfs_maze(maze, n, m):
    # 이동 방향: 상, 하, 좌, 우
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    # BFS를 위한 큐 초기화
    queue = deque([(0, 0, 1)])  # (x, y, 거리)
    visited = [[False] * m for _ in range(n)]
    visited[0][0] = True
    
    while queue:
        x, y, dist = queue.popleft()
        
        # 도착 지점에 도달했을 때
        if x == n - 1 and y == m - 1:
            return dist
        
        # 4방향 탐색
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and maze[nx][ny] == 1:
                visited[nx][ny] = True
                queue.append((nx, ny, dist + 1))
    
    # 도착 지점에 도달할 수 없는 경우
    return -1

# 입력 받기
n, m = map(int, input().split())
maze = [list(map(int, input().strip())) for _ in range(n)]

# 결과 출력
print(bfs_maze(maze, n, m))
```