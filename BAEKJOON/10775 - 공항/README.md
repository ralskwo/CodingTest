# 공항 문제 풀이 및 설명

<https://www.acmicpc.net/problem/10775>

<https://mayquartet.com/python-파이썬-백준-10775-공항/>

## 문제 이해

이 문제는 **유니온 파인드(Union-Find)** 알고리즘을 이용하여 해결할 수 있는 공항 도킹 문제입니다. 문제의 핵심은 각 비행기가 도킹할 수 있는 게이트를 찾아 도킹하는 과정에서, 가능한 한 많은 비행기를 도킹시켜야 한다는 것입니다. 비행기는 자신이 도킹할 수 있는 게이트의 범위 내에서 가장 높은 번호의 게이트에 도킹하려고 하며, 만약 도킹할 수 있는 게이트가 없으면 이후의 모든 비행기는 도킹할 수 없습니다. 이를 통해 최대한 많은 비행기를 도킹시키는 것이 목표입니다.

## 입출력 조건

- **입력**:
  - 첫 번째 줄에 공항의 게이트 수 `G`가 주어집니다. (`1 ≤ G ≤ 100,000`)
  - 두 번째 줄에 도착할 비행기의 수 `P`가 주어집니다. (`1 ≤ P ≤ 100,000`)
  - 이후 `P`개의 줄에는 각 비행기가 도킹할 수 있는 게이트의 최대 번호 `gi`가 주어집니다. 각 `gi`는 `1 ≤ gi ≤ G`를 만족합니다.
- **출력**:
  - 도킹할 수 있는 최대의 비행기 수를 한 줄에 출력합니다.
  - 비행기가 도킹할 수 있는 게이트가 없으면 공항이 폐쇄되며, 이후의 비행기는 도킹할 수 없습니다.

## 접근 방식

이 문제는 비행기가 도킹할 수 있는 게이트의 범위 내에서 **가장 큰 번호의 게이트**를 찾아야 하므로, **유니온 파인드(Union-Find)** 알고리즘을 사용하는 것이 효과적입니다. 이 알고리즘은 게이트 간의 관계를 관리하고, 비행기가 도킹할 수 있는 게이트를 찾은 후, 그 게이트가 사용되었을 때 그보다 작은 번호의 게이트를 새로운 대상으로 지정합니다. 이러한 방식으로, 각 비행기가 도킹할 수 있는 가장 높은 번호의 게이트를 빠르게 찾아가며 도킹을 진행할 수 있습니다.

- **유니온 파인드 알고리즘의 주요 개념**:
  - **Find**: 특정 노드가 속한 집합의 루트를 찾는 과정입니다. 여기서 비행기가 도킹 가능한 가장 높은 번호의 게이트를 찾는 데 사용됩니다.
  - **Union**: 두 노드의 루트를 하나로 합치는 과정입니다. 도킹된 게이트와 그보다 작은 번호의 게이트를 연결하여, 이후 비행기가 도킹할 수 있는 게이트 범위를 줄여줍니다.
  - **경로 압축(Path Compression)**: `find` 과정에서 부모 노드를 재귀적으로 찾아가며, 경로 상의 모든 노드가 루트를 직접 가리키도록 하여 효율성을 높이는 기법입니다.

<https://mayquartet.com/algorithm-union-find-dsudisjoint-set-union-알고리즘-이해하기/>

## 풀이 과정

1. **parent 리스트 초기화**:

   - 각 게이트는 자기 자신을 부모로 가지도록 `parent` 리스트를 초기화합니다. 예를 들어, `parent[i] = i`는 `i`번 게이트가 현재 사용 가능함을 나타냅니다.
   - `parent` 리스트는 유니온 파인드 알고리즘의 기본 구조로, 각 게이트가 속한 집합의 루트를 추적하는 데 사용됩니다.

2. **`find` 함수 정의**:

   - `find` 함수는 주어진 게이트 번호 `x`의 루트를 찾는 역할을 합니다. 이는 비행기가 도킹할 수 있는 가장 높은 번호의 게이트를 찾는 데 사용됩니다.
   - `parent[x]`가 자기 자신이 아닐 경우, 재귀적으로 `find(parent[x])`를 호출하여 루트를 찾고, 경로 압축을 통해 `parent[x]`를 직접 루트로 설정합니다.
   - 이를 통해 트리의 깊이가 줄어들고, `find` 함수의 효율성이 크게 향상됩니다.

3. **`union` 함수 정의**:

   - `union` 함수는 두 게이트를 연결하는 역할을 합니다. 도킹이 이루어진 게이트를 그보다 작은 번호의 게이트와 연결하여, 이후 비행기가 사용할 수 있는 게이트를 조정합니다.
   - 예를 들어, 비행기가 `3`번 게이트에 도킹한 경우, `3`번 게이트와 `2`번 게이트를 `union`하여 다음 비행기가 도킹할 때는 `2`번 게이트를 사용할 수 있도록 합니다.

4. **비행기 도킹 과정 처리**:

   - 각 비행기의 도킹 가능 최대 게이트 번호 `gi`에 대해, `find(gi)`를 호출하여 도킹 가능한 가장 높은 번호의 게이트를 찾습니다.
   - 만약 `find` 결과가 `0`이라면, 더 이상 도킹할 수 있는 게이트가 없음을 의미하므로 반복을 종료합니다.
   - 도킹할 수 있는 게이트가 존재하면, `union` 함수를 사용하여 해당 게이트와 그보다 작은 게이트를 연결합니다.
   - 도킹이 성공할 때마다 `docked_planes` 변수를 1씩 증가시켜 도킹된 비행기의 수를 누적합니다.

5. **최종 결과 반환 및 출력**:
   - 반복이 종료되면, `docked_planes` 변수에 저장된 도킹된 비행기의 수를 반환합니다.
   - 이 값을 출력하여 최대 도킹 가능한 비행기의 수를 사용자에게 제공합니다.

이와 같은 과정을 통해, 각 비행기가 최대한 많은 게이트에 도킹할 수 있도록 하며, 공항이 폐쇄되는 경우를 최소화할 수 있습니다. 유니온 파인드를 사용한 이 방법은 문제에서 요구하는 시간 제한과 입력 크기 내에서 효율적으로 문제를 해결할 수 있도록 도와줍니다.

## 코드 구현

```python
import sys

def max_planes_docked(G, P, gi_list):
    # parent 리스트를 초기화하여 각 게이트가 자기 자신을 부모로 가지게 함
    parent = list(range(G + 1))

    # find 함수는 주어진 게이트 번호 x의 루트를 찾음
    # 경로 압축을 통해 트리의 깊이를 줄여 효율성을 높임
    def find(x):
        # 현재 게이트의 부모가 자기 자신이 아니면 재귀적으로 루트를 찾음
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    # union 함수는 x 게이트와 y 게이트를 연결함
    # 여기서, y는 x보다 1 작은 게이트를 의미하여 게이트 연결을 관리함
    def union(x, y):
        parent[find(x)] = find(y)

    # 도킹된 비행기의 수를 저장하는 변수
    docked_planes = 0

    # gi_list에 있는 각 비행기에 대해 도킹 가능한 게이트를 찾음
    for gi in gi_list:
        # 현재 비행기가 도킹 가능한 가장 높은 번호의 게이트를 찾음
        available_gate = find(gi)
        # 만약 가능한 게이트가 0이면, 더 이상 도킹할 수 없으므로 반복 종료
        if available_gate == 0:
            break
        # 도킹 후, 현재 게이트와 그보다 작은 게이트를 union하여 연결
        union(available_gate, available_gate - 1)
        # 도킹된 비행기 수를 1 증가시킴
        docked_planes += 1

    # 도킹할 수 있는 최대 비행기 수를 반환
    return docked_planes

def main():
    # 표준 입력을 받아오는 함수
    input = sys.stdin.readline
    # 게이트 수 G를 입력받음
    G = int(input().strip())
    # 비행기 수 P를 입력받음
    P = int(input().strip())
    # 각 비행기의 도킹 가능 게이트 정보를 리스트로 저장
    gi_list = [int(input().strip()) for _ in range(P)]

    # 최대 도킹 가능한 비행기 수를 계산하고 출력
    result = max_planes_docked(G, P, gi_list)
    print(result)

# 프로그램의 시작점으로, main 함수를 호출
if __name__ == "__main__":
    main()
```
