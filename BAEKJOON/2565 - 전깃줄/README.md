# 전깃줄 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2565>

<https://mayquartet.com/python-백준-2565-전깃줄/>

## 문제 이해

이 문제는 전깃줄이 교차하지 않도록 하기 위해 제거해야 하는 최소 전깃줄의 개수를 구하는 문제입니다. 교차하지 않는 전깃줄은, 두 전봇대 A와 B에서 각각의 연결된 번호가 항상 증가하거나 감소하는 순서를 유지해야 합니다. 예를 들어, A 전봇대에서 1, 3, 4번에 연결된 전깃줄이 B 전봇대에서 2, 5, 6번에 연결된 경우, 이 전깃줄들은 서로 교차하지 않습니다.

문제를 해결하려면 교차하지 않는 전깃줄의 최대 개수를 먼저 구하고, 이를 전체 전깃줄 수에서 뺀 값을 계산해야 합니다. 교차하지 않는 전깃줄의 최대 개수를 구하는 것은 `Longest Increasing Subsequence (LIS)` 문제와 동일한 접근 방식으로 해결할 수 있습니다.

## 입출력 조건

### 입력 조건

1. 첫째 줄에는 전깃줄의 개수 `n`이 주어집니다. `n`은 100 이하의 자연수입니다.
2. 둘째 줄부터 `n`개의 줄에는 각각 두 개의 정수 `A`와 `B`가 주어지며, 이는 각각 A 전봇대와 B 전봇대에서 전깃줄이 연결된 위치를 나타냅니다.
3. 위치 번호는 1 이상 500 이하의 자연수이며, 같은 위치에 두 개 이상의 전깃줄이 연결되지 않습니다.

### 출력 조건

- 첫째 줄에 교차하지 않는 전깃줄을 만들기 위해 제거해야 하는 최소 전깃줄의 개수를 출력합니다.

## 접근 방식

이 문제는 교차하지 않는 전깃줄의 최대 개수를 구하는 것을 목표로 합니다. 이 문제를 해결하기 위해 다음과 같은 접근 방식을 사용합니다.

1. **전봇대 A를 기준으로 정렬**:

   - 먼저 전깃줄의 연결 정보를 A 전봇대의 위치를 기준으로 정렬합니다. 이렇게 하면 A 전봇대의 순서를 고정할 수 있으며, B 전봇대에서 교차 여부만 판단하면 됩니다.

2. **Longest Increasing Subsequence (LIS) 구하기**:

   - 정렬된 데이터에서 B 전봇대의 연결 위치를 기준으로 LIS를 찾습니다. LIS는 교차하지 않는 전깃줄의 최대 개수를 나타냅니다.
   - 이를 위해 다이나믹 프로그래밍이나 이분 탐색 기반 LIS 알고리즘을 사용할 수 있습니다.

3. **결과 계산**:
   - 전체 전깃줄의 개수 `n`에서 LIS의 길이를 빼면 제거해야 하는 전깃줄의 최소 개수를 구할 수 있습니다.

이 방식은 문제의 제약 조건을 만족하며, 효율적으로 풀이할 수 있는 최적의 방법입니다.

## 풀이 과정

### 1. 입력 데이터 정렬

- 입력받은 전깃줄 정보를 A 전봇대의 위치를 기준으로 오름차순으로 정렬합니다.
- 이 과정을 통해 A 전봇대의 순서가 고정되므로 B 전봇대의 연결 순서만 고려하면 됩니다.
- 예를 들어, 정렬된 데이터가 `[(1, 8), (2, 2), (3, 9), (4, 1)]`과 같이 주어졌다면, 이제 B 전봇대에서 `8, 2, 9, 1`을 LIS로 처리합니다.

### 2. Longest Increasing Subsequence 계산

- LIS를 찾기 위해 다이나믹 프로그래밍 배열 `dp`를 생성합니다.
- B 전봇대의 연결 정보를 순회하면서 각 값을 `dp`에 추가하거나 갱신합니다.
  - 이분 탐색을 사용하여 LIS 배열에 값이 들어갈 위치를 빠르게 찾습니다.
  - 값이 들어갈 위치가 `dp` 배열의 끝이면 값을 추가하고, 그렇지 않으면 해당 위치를 갱신합니다.

### 3. LIS의 길이 계산

- `dp` 배열의 길이는 B 전봇대에서 교차하지 않는 전깃줄의 최대 개수를 나타냅니다.

### 4. 제거해야 하는 전깃줄의 최소 개수 계산

- 전체 전깃줄 개수 `n`에서 LIS의 길이를 뺀 값이 제거해야 하는 전깃줄의 최소 개수입니다.

### 5. 결과 출력

- 최종적으로 계산된 값을 출력합니다.

## 코드 구현

```python
def min_remove_wires(n, connections):
    # 전깃줄을 A 전봇대의 위치를 기준으로 정렬
    connections.sort()

    # LIS를 저장하기 위한 dp 배열 초기화
    dp = []
    for _, b in connections:
        # 현재 B 전봇대 위치를 LIS 배열에서 이분 탐색
        idx = binary_search(dp, b)
        # LIS 배열의 끝에 추가할 경우
        if idx == len(dp):
            dp.append(b)
        # LIS 배열의 기존 위치를 갱신할 경우
        else:
            dp[idx] = b

    # 전체 전깃줄에서 LIS의 길이를 빼서 제거해야 하는 전깃줄의 최소 개수 반환
    return n - len(dp)

def binary_search(dp, target):
    # 이분 탐색을 위한 시작과 끝 인덱스 초기화
    low, high = 0, len(dp)
    while low < high:
        # 중간 인덱스 계산
        mid = (low + high) // 2
        # 중간 값이 목표 값보다 작은 경우 오른쪽으로 탐색
        if dp[mid] < target:
            low = mid + 1
        # 중간 값이 목표 값 이상인 경우 왼쪽으로 탐색
        else:
            high = mid
    # 목표 값이 들어갈 위치 반환
    return low

# 전깃줄의 개수를 입력받음
n = int(input())

# 전깃줄의 연결 정보를 입력받아 리스트로 저장
connections = [tuple(map(int, input().split())) for _ in range(n)]

# 제거해야 하는 전깃줄의 최소 개수를 계산하고 출력
print(min_remove_wires(n, connections))
```
