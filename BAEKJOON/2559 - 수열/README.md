# 수열 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2559>

<https://mayquartet.com/python-백준-2559-수열/>

## 문제 이해

이 문제는 **연속적인 날짜의 합이 최대가 되는 경우를 찾는 문제**입니다. 주어진 날짜의 온도는 정수 배열로 제공되며, 이 배열에서 `K`개의 연속된 날짜의 합 중 가장 큰 값을 계산해야 합니다. 문제의 핵심은 효율적인 방식으로 연속된 날짜의 합을 계산하여 최대값을 찾는 것입니다. 단순히 모든 연속적인 `K`개의 부분 배열을 검사한다면 비효율적이므로, 시간 복잡도를 줄이기 위한 방법을 고려해야 합니다.

이 문제를 푸는 관점은 다음과 같습니다:

1. **연속된 부분 배열의 합 계산**: 모든 `K`개의 구간을 하나씩 계산하는 대신, 이전 구간의 합을 기반으로 다음 구간의 합을 효율적으로 구할 수 있어야 합니다.
2. **최대값 비교 및 갱신**: 계산한 합을 매번 비교하여 최대값을 갱신하는 과정을 포함해야 합니다.
3. **효율성 고려**: `N`이 최대 100,000까지 가능하므로, 시간 복잡도가 `O(N)`을 넘지 않도록 설계해야 합니다.

## 입출력 조건

### 입력 조건

1. 첫 번째 줄에는 두 개의 정수 `N`과 `K`가 공백으로 구분되어 주어집니다.
   - `N`: 온도를 측정한 전체 날짜의 수. \(2 \leq N \leq 100,000\).
   - `K`: 연속적인 날짜의 수. \(1 \leq K \leq N\).
2. 두 번째 줄에는 `N`개의 정수가 공백으로 구분되어 주어지며, 각 정수는 해당 날짜의 온도를 나타냅니다.
   - 각 온도는 \(-100 \leq 온도 \leq 100\)의 범위를 가집니다.

### 출력 조건

- 입력된 온도의 수열에서 연속적인 `K`일의 온도의 합 중 가장 큰 값을 정수로 출력합니다.

## 접근 방식

이 문제를 해결하기 위해 **슬라이딩 윈도우(Sliding Window)** 알고리즘을 사용합니다. 슬라이딩 윈도우는 연속적인 부분 구간의 합이나 계산을 효율적으로 수행할 수 있는 알고리즘입니다. 이 문제에 적합한 이유는 다음과 같습니다:

1. **첫 구간의 합 계산**: 처음 `K`일의 합을 구합니다. 이 합은 초기 기준점으로 사용됩니다.
2. **윈도우 이동**: 이후부터는 윈도우를 한 칸씩 오른쪽으로 이동하면서 새 구간의 합을 계산합니다.
   - 새 합은 기존 합에서 윈도우의 맨 왼쪽 값을 빼고, 새로 포함된 값을 더하여 계산합니다.
   - 이렇게 하면 새 구간의 합을 반복적으로 계산할 필요 없이 효율적으로 갱신할 수 있습니다.
3. **최대값 갱신**: 매번 새로운 합이 기존의 최대값보다 크다면 최대값을 갱신합니다.
4. **효율성**: 모든 날짜를 단 한 번 순회하면서 문제를 해결할 수 있으므로, 시간 복잡도가 \(O(N)\)로 제한됩니다.

<https://mayquartet.com/algorithm-투-포인터two-pointer-알고리즘-이해하기/>

## 풀이 과정

1. 입력값을 처리합니다.

   - 첫 번째 줄에서 `N`과 `K`를 읽어옵니다.
   - 두 번째 줄에서 `N`개의 온도 데이터를 리스트로 읽어옵니다.

2. 초기 `K`일 동안의 합을 계산하여 `current_sum`에 저장합니다.

   - `current_sum`은 슬라이딩 윈도우의 기준이 되는 첫 번째 구간의 합입니다.
   - 동시에, 이 값을 `max_sum`에 저장하여 최대값으로 초기화합니다.

3. 슬라이딩 윈도우를 적용합니다.

   - `K`일 이후부터 `N`일까지 반복문을 돌면서 윈도우를 오른쪽으로 이동합니다.
   - 새로운 구간의 합을 계산하는 방법:
     - `current_sum`에서 맨 왼쪽 값을 제거합니다. 이는 구간에서 빠지는 값입니다.
     - 새로 포함된 값을 더합니다. 이는 구간에 추가되는 값입니다.
   - 계산된 `current_sum`이 기존 `max_sum`보다 크다면 `max_sum`을 갱신합니다.

4. 반복이 끝난 후, `max_sum`을 출력합니다.

   - 이는 연속된 `K`일 동안의 온도 합 중 최대값입니다.

5. 최종 출력 결과로 최대값을 반환합니다.

이 과정은 입력 크기 `N`에 대해 단일 반복만 수행하므로, 효율적으로 문제를 해결할 수 있습니다.

## 코드 구현

```python
# 첫 번째 줄에서 입력값 N과 K를 읽어온다.
# N은 전체 날짜의 수, K는 연속된 날짜의 수이다.
N, K = map(int, input().split())

# 두 번째 줄에서 온도를 나타내는 N개의 정수를 리스트로 읽어온다.
temperatures = list(map(int, input().split()))

# 처음 K일 동안의 온도의 합을 계산하여 current_sum 변수에 저장한다.
current_sum = sum(temperatures[:K])

# 초기 상태에서 current_sum 값을 최대 합으로 설정한다.
max_sum = current_sum

# K일 이후부터 N일까지 슬라이딩 윈도우 방식으로 최대 합을 계산한다.
for i in range(K, N):
    # 윈도우를 한 칸 오른쪽으로 이동시키며 새로운 합을 계산한다.
    # 이전 합에서 윈도우의 첫 번째 값을 빼고 새로운 값을 더한다.
    current_sum = current_sum - temperatures[i - K] + temperatures[i]

    # 계산된 합이 현재까지의 최대 합보다 크면 max_sum을 갱신한다.
    max_sum = max(max_sum, current_sum)

# 최종적으로 연속된 K일 동안의 최대 합을 출력한다.
print(max_sum)
```
