# 성곽 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2234>

<https://mayquartet.com/python-파이썬-백준-2234-성곽/>

## 문제 이해

이 문제는 성곽의 구조와 벽의 배치에 대한 정보를 바탕으로 방의 개수와 각 방의 크기를 계산하고, 벽을 하나 제거했을 때 가장 넓은 방의 크기를 찾는 문제입니다. 성곽은 `M x N` 크기의 격자로 이루어져 있으며, 각 칸에는 벽이 특정 방향으로 존재할 수 있습니다. 각 방은 인접한 칸들이 서로 연결되어 형성되며, 벽이 없는 방향으로만 이동할 수 있습니다. 성곽을 방으로 나누고 각 방의 크기를 파악하는 것은 `그래프 탐색`을 통해 해결할 수 있습니다. 또한, 각 방의 크기를 파악한 뒤 벽을 하나 제거하여 인접한 방을 연결했을 때, 가장 큰 방의 크기를 계산하는 추가 작업이 필요합니다. 이 문제에서는 각 칸에 대한 벽 정보를 비트마스킹을 통해 제공하며, 이를 기반으로 이동 가능한 방향을 파악할 수 있습니다.

요약하자면, 이 문제는 다음과 같은 세 가지 결과를 요구합니다:

1. 성곽에 있는 방의 개수
2. 가장 넓은 방의 넓이
3. 벽을 하나 제거하여 얻을 수 있는 가장 넓은 방의 크기

이를 위해 우리는 성곽의 각 칸을 탐색하고 방을 구분하며, 벽을 제거하여 얻을 수 있는 최대 방 크기를 계산해야 합니다.

## 입출력 조건

- **입력 조건**:

  - 첫 줄에 성곽의 가로 길이 `N`과 세로 길이 `M`이 주어집니다. (`1 ≤ N, M ≤ 50`)
  - 그 다음 `M`개의 줄에 걸쳐 성곽의 각 칸에 대한 벽 정보가 `N`개의 정수로 제공됩니다. 각 정수는 0부터 15 사이의 값을 가지며, 이 값은 비트마스킹을 통해 벽이 있는 방향을 나타냅니다.
    - 예를 들어, 값이 `11`일 경우, 이진수로 `1011`이므로 서쪽, 북쪽, 동쪽에 벽이 있고 남쪽에는 벽이 없습니다.
  - 입력을 통해 제공되는 성곽 정보는 벽이 있는 방향을 비트로 나타내기 때문에, 이를 파악하여 이동 가능한 방향을 결정할 수 있습니다.

- **출력 조건**:
  - 첫 줄에 성곽의 방 개수를 출력합니다.
  - 둘째 줄에 가장 넓은 방의 넓이를 출력합니다.
  - 셋째 줄에 벽을 하나 제거하여 만들 수 있는 가장 넓은 방의 크기를 출력합니다.

## 접근 방식

이 문제는 그래프 탐색과 비트마스킹을 이용하여 해결할 수 있습니다. 전체적인 접근 방식은 다음과 같습니다.

1. **그래프 탐색을 통한 방 구분**:
   - 성곽의 각 칸을 그래프의 노드로 간주하고, 인접한 칸이 같은 방에 속하는지를 판별하기 위해 BFS 또는 DFS를 사용할 수 있습니다.
   - 각 칸에 있는 벽 정보를 통해 이동 가능한 방향을 확인하고, 같은 방에 속하는 칸들을 하나의 영역으로 탐색하여 방의 크기를 계산합니다.
   - 탐색 과정에서 방문한 칸은 다시 방문하지 않도록 `visited` 배열을 이용하여 방문 여부를 기록하고, 방 ID를 부여합니다.
2. **벽을 제거하여 최대 방 크기 계산**:

   - 모든 칸을 순회하며 인접한 칸이 서로 다른 방에 속할 경우, 그 사이에 있는 벽을 제거하면 두 방을 합칠 수 있습니다.
   - 합친 방의 크기를 계산하고, 기존의 최대 방 크기와 비교하여 최대값을 갱신합니다.

3. **비트마스킹을 통한 벽 정보 해석**:
   - 각 칸의 벽 정보는 비트마스킹을 통해 주어지므로, 이를 해석하여 이동 가능한 방향을 파악합니다.
   - 예를 들어, 서쪽에 벽이 있을 경우 1이 더해지므로, 칸의 값에서 `& 1` 연산을 통해 서쪽에 벽이 있는지 확인할 수 있습니다.

<https://mayquartet.com/algorithm-bfs-너비-우선-탐색-알고리즘/>

<https://mayquartet.com/algorithm-알고리즘-dfs-깊이-우선-탐색-알고리즘-이해하기/>

## 풀이 과정

1. **성곽의 크기와 벽 정보 입력 받기**:

   - `N`과 `M`을 입력받아 성곽의 크기를 설정하고, 각 칸의 벽 정보를 입력받아 2차원 리스트 `castle`에 저장합니다.
   - 각 칸의 벽 정보는 비트마스킹 형태로 주어지므로, 이 값을 통해 각 방향에 벽이 있는지 확인할 수 있습니다.

2. **그래프 탐색을 통해 방의 개수와 각 방의 크기 계산**:

   - `visited` 리스트를 생성하여, 각 칸이 방문되었는지와 방 ID를 저장합니다.
   - 성곽의 각 칸을 순회하며, 아직 방문하지 않은 칸을 발견할 때마다 BFS 또는 DFS를 통해 새로운 방을 탐색합니다.
   - 탐색을 시작한 위치에서 이어진 칸들을 방문하고, 이동 가능한 방향을 확인하여 방의 크기를 계산합니다.
   - 방의 개수를 증가시키고, 각 방의 크기를 `room_sizes` 리스트에 추가하여 저장합니다.

3. **가장 넓은 방의 크기 계산**:

   - 방의 개수와 각 방의 크기를 구한 후, `room_sizes` 리스트에서 가장 큰 값을 찾아 가장 넓은 방의 크기를 구합니다.
   - `max` 함수를 사용하여 `room_sizes` 리스트에서 최대값을 찾습니다.

4. **벽을 하나 제거하여 얻을 수 있는 최대 방 크기 계산**:

   - 성곽의 각 칸을 순회하며 인접한 칸이 다른 방에 속할 때, 그 사이의 벽을 제거하고 두 방을 합쳐봅니다.
   - 예를 들어, 현재 칸의 방 크기와 인접한 칸의 방 크기를 더하여 두 방을 합친 크기를 계산할 수 있습니다.
   - 이렇게 합친 방의 크기를 기존의 최대 방 크기와 비교하여 더 큰 값을 `max_combined_room_size` 변수에 저장합니다.
   - 모든 칸에 대해 이 과정을 반복하여 벽을 제거했을 때 얻을 수 있는 가장 넓은 방의 크기를 구합니다.

5. **결과 출력**:
   - 최종적으로 방의 개수, 가장 넓은 방의 크기, 벽을 제거하여 얻을 수 있는 가장 넓은 방의 크기를 순서대로 출력합니다.

## 코드 구현

```python
import sys
from collections import deque

# 방향 벡터 설정 (서쪽, 북쪽, 동쪽, 남쪽 순서)
dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]

# 각 방향에 대한 벽 비트마스크 값 (서쪽: 1, 북쪽: 2, 동쪽: 4, 남쪽: 8)
DIRECTION_WALL = [1, 2, 4, 8]

# BFS를 통해 방을 탐색하고 방의 크기를 반환하는 함수
def bfs(start_x, start_y, room_id):
    # 시작 위치를 큐에 추가하고, 해당 위치를 현재 방 ID로 방문 표시
    queue = deque([(start_x, start_y)])
    visited[start_x][start_y] = room_id
    room_size = 1  # 현재 방의 크기 (칸 수)

    # 큐가 빌 때까지 반복하여 BFS 탐색 수행
    while queue:
        x, y = queue.popleft()  # 큐에서 현재 위치를 꺼냄

        # 4방향(서, 북, 동, 남)을 순회하며 이동할 수 있는지 확인
        for direction in range(4):
            nx, ny = x + dx[direction], y + dy[direction]  # 이동할 좌표 계산

            # 성곽 크기 내에 있고, 아직 방문하지 않은 위치인지 확인
            if 0 <= nx < M and 0 <= ny < N and visited[nx][ny] == 0:
                # 현재 위치에서 해당 방향에 벽이 없을 때만 이동
                if not (castle[x][y] & DIRECTION_WALL[direction]):
                    visited[nx][ny] = room_id  # 이동할 위치를 현재 방 ID로 표시
                    queue.append((nx, ny))  # 큐에 이동할 위치 추가
                    room_size += 1  # 방 크기 증가

    return room_size  # 최종 방 크기 반환

# 성곽의 크기 입력 받기 (N은 너비, M은 높이)
N, M = map(int, input().split())

# 성곽의 벽 정보 입력 받기
castle = [list(map(int, input().split())) for _ in range(M)]

# 방문 여부와 방 ID를 저장할 리스트 초기화
visited = [[0] * N for _ in range(M)]

# 각 방의 크기를 저장할 리스트와 방의 개수를 저장할 변수 초기화
room_sizes = []
room_count = 0

# 성곽의 각 칸을 순회하며 방 탐색 수행
for i in range(M):
    for j in range(N):
        # 아직 방문하지 않은 칸이면 새로운 방으로 간주하고 탐색
        if visited[i][j] == 0:
            room_count += 1  # 방의 개수 증가
            room_size = bfs(i, j, room_count)  # BFS로 방 크기 계산
            room_sizes.append(room_size)  # 방 크기 리스트에 추가

# 가장 큰 방의 크기 계산
max_room_size = max(room_sizes)

# 벽을 하나 제거하여 얻을 수 있는 최대 방 크기 계산 변수 초기화
max_combined_room_size = 0

# 성곽의 각 칸을 순회하며 벽 제거 시도를 통해 방 크기 계산
for i in range(M):
    for j in range(N):
        current_room_id = visited[i][j]  # 현재 칸의 방 ID 저장

        # 4방향을 확인하여 인접 방과의 연결 시도
        for direction in range(4):
            ni, nj = i + dx[direction], j + dy[direction]  # 이동할 좌표 계산
            if 0 <= ni < M and 0 <= nj < N:
                neighbor_room_id = visited[ni][nj]  # 인접 방의 ID 저장

                # 인접 방이 다른 방일 경우에만 벽을 제거하고 방을 합친 크기 계산
                if current_room_id != neighbor_room_id:
                    combined_size = room_sizes[current_room_id - 1] + room_sizes[neighbor_room_id - 1]
                    max_combined_room_size = max(max_combined_room_size, combined_size)  # 최대 크기 갱신

# 최종 결과 출력: 방의 개수, 가장 큰 방의 크기, 벽을 제거하여 얻을 수 있는 최대 방 크기
print(room_count)
print(max_room_size)
print(max_combined_room_size)
```
