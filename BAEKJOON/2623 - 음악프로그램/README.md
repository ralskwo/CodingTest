# 음악프로그램 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2623>

<https://mayquartet.com/python-백준-2623-음악프로그램/>

## 문제 이해

이 문제는 방향성 있는 그래프(Directed Graph)로 해석할 수 있으며, 각 가수는 그래프의 노드, 보조 PD가 정한 순서는 노드 간의 간선으로 표현됩니다. 남일이가 정해야 하는 가수 출연 순서는 보조 PD가 제시한 순서 제약 조건을 모두 만족해야 합니다.  
즉, 보조 PD들이 입력한 순서를 모두 따르면서도 전체 가수들의 출연 순서를 정의할 수 있어야 합니다. 예를 들어, `1 4 3`이라는 입력이 주어지면, 가수 `1`이 `4`보다 먼저, 가수 `4`가 `3`보다 먼저 출연해야 함을 의미합니다.

이 문제를 해결하기 위해서는 모든 보조 PD가 제시한 조건을 만족하는 순서를 하나 찾거나, 순서를 정의할 수 없는 경우(사이클이 발생하는 경우) 이를 감지해야 합니다.

## 입출력 조건

### 입력

1. 첫 번째 줄에 가수의 수 `N`(1 ≤ `N` ≤ 1,000)과 보조 PD의 수 `M`(1 ≤ `M` ≤ 100)이 공백으로 구분되어 주어집니다.
2. 두 번째 줄부터 `M`개의 줄에 보조 PD가 정한 순서 정보가 주어집니다.
   - 각 줄의 첫 번째 값은 보조 PD가 담당한 가수의 수이며, 그 뒤에는 해당 가수들의 순서가 나열됩니다.
   - 각 줄의 순서는 2개 이상의 숫자로 구성됩니다.

### 출력

1. 전체 가수의 출연 순서를 한 줄에 하나씩 출력합니다. 답이 여러 개일 경우, 그중 하나를 출력합니다.
2. 보조 PD의 조건을 만족하는 순서를 정할 수 없으면 첫 줄에 `0`을 출력합니다.

## 접근 방식

이 문제는 **위상 정렬(Topological Sorting)** 알고리즘을 사용하여 해결할 수 있습니다. 위상 정렬은 방향성 있는 비순환 그래프(Directed Acyclic Graph, DAG)에서 노드들을 선형적으로 정렬하는 알고리즘입니다. 문제 해결 접근 방식은 다음과 같습니다.

1. **그래프 모델링**: 각 가수를 노드로, 보조 PD가 정한 순서를 간선으로 변환합니다. 예를 들어, 보조 PD가 `1 4 3`을 제시했다면 그래프에 간선 `1 → 4`, `4 → 3`을 추가합니다.
2. **진입 차수 계산**: 모든 노드의 진입 차수를 계산합니다. 진입 차수는 해당 노드로 들어오는 간선의 수를 의미하며, 이는 위상 정렬의 초기 조건을 설정하는 데 필요합니다.
3. **위상 정렬 알고리즘 적용**:
   - 진입 차수가 0인 노드를 큐에 넣습니다.
   - 큐에서 노드를 하나씩 꺼내며 순서를 결정하고, 해당 노드와 연결된 노드들의 진입 차수를 감소시킵니다.
   - 진입 차수가 0이 된 노드를 큐에 추가하여 과정을 반복합니다.
4. **사이클 감지**: 모든 노드를 정렬하지 못했다면 사이클이 존재함을 의미합니다. 이 경우, 순서를 정할 수 없으므로 `0`을 출력합니다.

## 풀이 과정

1. **그래프와 진입 차수 초기화**:

   - `graph`를 딕셔너리로 생성하여 각 노드의 연결 관계를 저장합니다.
   - `indegree`를 딕셔너리로 생성하여 각 노드의 진입 차수를 0으로 초기화합니다.

2. **그래프 구성**:

   - 보조 PD가 제시한 순서를 입력받아 그래프에 간선을 추가합니다.  
     예를 들어, `3 1 4 3`을 입력받으면, 간선 `1 → 4`, `4 → 3`을 추가합니다.
   - 간선이 추가될 때마다 도착 노드의 진입 차수를 1 증가시킵니다.

3. **위상 정렬 수행**:

   - 진입 차수가 0인 노드들을 초기 큐에 추가합니다.
   - 큐에서 노드를 하나씩 꺼내며 다음을 수행합니다.
     - 꺼낸 노드를 결과 리스트에 추가합니다.
     - 현재 노드에서 연결된 모든 노드의 진입 차수를 1씩 감소시킵니다.
     - 진입 차수가 0이 된 노드들은 큐에 추가합니다.

4. **사이클 검증**:

   - 정렬된 노드 개수가 전체 노드 수와 다르면 사이클이 존재합니다.
   - 사이클이 존재하는 경우 `0`을 출력하고 프로그램을 종료합니다.

5. **결과 출력**:
   - 위상 정렬이 성공적으로 완료되면 결과 리스트를 한 줄씩 출력합니다.
   - 가능한 여러 답 중 하나를 출력하면 됩니다.

## 코드 구현

```python
from collections import deque  # deque를 사용하기 위해 collections 모듈을 불러옴

# 가수의 수 N과 보조 PD의 수 M 입력
n, m = map(int, input().split())

# 그래프와 진입 차수를 초기화
graph = {i: [] for i in range(1, n + 1)}  # 각 가수를 키로, 빈 리스트를 값으로 가지는 그래프 생성
indegree = {i: 0 for i in range(1, n + 1)}  # 각 가수의 진입 차수를 0으로 초기화

# 보조 PD가 정한 가수의 순서를 입력받아 그래프와 진입 차수를 설정
for _ in range(m):
    data = list(map(int, input().split()))  # 보조 PD가 입력한 순서를 리스트로 변환
    for i in range(2, len(data)):  # 각 순서의 가수를 그래프에 간선으로 추가
        graph[data[i - 1]].append(data[i])  # 이전 가수에서 현재 가수로 향하는 간선 추가
        indegree[data[i]] += 1  # 현재 가수의 진입 차수를 1 증가

# 위상 정렬 알고리즘 정의
def topological_sort():
    queue = deque()  # 진입 차수가 0인 노드를 처리하기 위한 큐 생성
    result = []  # 최종 결과를 저장할 리스트

    # 모든 노드 중 진입 차수가 0인 노드를 큐에 추가
    for i in range(1, n + 1):
        if indegree[i] == 0:
            queue.append(i)

    # 큐를 이용하여 위상 정렬 수행
    while queue:
        current = queue.popleft()  # 큐에서 하나의 노드를 꺼냄
        result.append(current)  # 꺼낸 노드를 결과 리스트에 추가

        # 현재 노드와 연결된 모든 노드에 대해 진입 차수를 감소
        for neighbor in graph[current]:
            indegree[neighbor] -= 1  # 진입 차수 감소
            if indegree[neighbor] == 0:  # 진입 차수가 0이 된 노드를 큐에 추가
                queue.append(neighbor)

    # 정렬된 노드 개수가 전체 노드 수와 다르면 사이클이 존재하므로 불가능
    if len(result) != n:
        return [0]  # 순서가 불가능하므로 0을 반환
    return result  # 정렬된 결과를 반환

# 위상 정렬 결과를 실행하고 출력
result = topological_sort()
for r in result:
    print(r)  # 결과를 한 줄씩 출력
```
