# 회전 초밥 문제 풀이 및 설명

<https://www.acmicpc.net/problem/15961>

<https://mayquartet.com/python-파이썬-백준-15961-회전-초밥/>

## 문제 이해

이 문제는 `회전 초밥` 벨트 위에 놓인 다양한 초밥을 연속해서 먹었을 때, 가능한 최대 종류의 초밥을 찾는 문제입니다. 회전 초밥의 벨트는 원형 구조로 되어 있으며, 손님은 벨트의 임의의 위치에서 시작하여 연속된 `k`개의 초밥을 먹을 수 있습니다. 문제는 손님이 가능한 한 많은 종류의 초밥을 먹고자 한다는 조건을 만족해야 하며, 이때 주어진 `쿠폰 번호`에 해당하는 초밥을 한 접시 무료로 추가 제공받을 수 있습니다. 따라서 손님이 먹을 수 있는 최대 종류의 초밥을 계산해야 합니다.

이 문제의 핵심은 연속된 `k`개의 초밥을 먹을 때 가능한 서로 다른 초밥의 종류 수를 찾는 것입니다. 또한, 벨트가 원형으로 연결되어 있기 때문에 벨트의 끝에서 시작 지점으로 다시 돌아올 수 있다는 점을 고려해야 합니다. 즉, 슬라이딩 윈도우가 끝에 도달하면, 다시 처음으로 돌아가 연속된 `k`개의 초밥을 이어서 확인해야 합니다. 이러한 특성 때문에 윈도우가 리스트의 범위를 초과하는 경우에도 인덱스가 자연스럽게 순환될 수 있도록 구현해야 합니다.

## 입출력 조건

1. **입력 조건**:

   - 첫 번째 줄에는 네 개의 정수가 공백으로 구분되어 주어집니다:
     - `N`: 회전 초밥 벨트에 놓인 접시의 수 (2 ≤ `N` ≤ 3,000,000)
     - `d`: 초밥의 종류 수 (2 ≤ `d` ≤ 3,000)
     - `k`: 연속해서 먹는 접시의 수 (2 ≤ `k` ≤ 3,000, `k` ≤ `N`)
     - `c`: 쿠폰 번호 (1 ≤ `c` ≤ `d`)
   - 두 번째 줄부터 `N`개의 줄에 걸쳐 벨트 위에 놓인 초밥의 종류가 정수로 주어집니다.
   - 각 줄의 정수는 1 이상 `d` 이하의 값을 가지며, 이는 각 접시의 초밥 종류를 나타냅니다.

2. **출력 조건**:
   - 손님이 연속된 `k`개의 접시를 먹었을 때, 가능한 서로 다른 초밥 종류의 최대 개수를 출력합니다.

## 접근 방식

이 문제는 `슬라이딩 윈도우` 알고리즘을 사용하여 효율적으로 풀 수 있습니다. 슬라이딩 윈도우는 연속된 부분 배열(구간)의 최대값 또는 최소값을 구할 때 자주 사용하는 알고리즘입니다. 이번 문제에서는 `슬라이딩 윈도우`를 이용하여 연속된 `k`개의 초밥을 빠르게 탐색하고, 윈도우가 한 칸씩 이동할 때마다 새로 들어오는 초밥과 나가는 초밥을 관리하여 서로 다른 초밥의 종류 수를 계산합니다.

특히 이 문제에서 고려해야 할 주요 사항은 다음과 같습니다:

1. **윈도우의 이동**:

   - 처음 `k`개의 초밥을 윈도우에 포함시키고, 이후 윈도우를 한 칸씩 이동합니다.
   - 각 이동 시 윈도우에서 빠지는 초밥과 새로 들어오는 초밥을 관리합니다.

2. **원형 배열의 특성**:

   - 벨트가 원형으로 연결되어 있으므로, 윈도우가 벨트의 끝을 넘어서면 다시 처음으로 돌아가는 구조를 고려해야 합니다. 따라서 `인덱스`가 초과될 경우 `(i + k) % N`를 사용하여 인덱스를 조정합니다.

3. **쿠폰 초밥 포함 여부**:
   - 쿠폰에 적힌 초밥이 현재 윈도우에 포함되어 있지 않으면, 해당 초밥을 추가로 고려하여 최대 종류 수를 계산합니다. 이를 위해 쿠폰 초밥을 기본적으로 윈도우에 포함시키고 시작하여 이후 계산 시 매번 비교합니다.

<https://mayquartet.com/algorithm-투-포인터two-pointer-알고리즘-이해하기/>

## 풀이 과정

1. **모듈 및 입력 초기화**:

   - `sys` 모듈과 `collections`의 `defaultdict`를 불러와 빠른 입력 처리를 준비합니다.
   - 첫 번째 줄에서 `N`, `d`, `k`, `c`의 값을 입력받아 변수에 저장합니다.
   - 이후 `N`개의 줄에 걸쳐 벨트에 놓인 초밥의 종류를 리스트(`sushi`)에 저장합니다.

2. **초기 슬라이딩 윈도우 설정**:

   - `defaultdict(int)`로 현재 윈도우에 있는 초밥 종류별 개수를 저장하는 `eaten` 딕셔너리를 생성합니다.
   - 처음 `k`개의 초밥을 `eaten`에 추가하여 초기 윈도우를 설정합니다.
   - 쿠폰 초밥 번호(`c`)를 기본적으로 윈도우에 추가하여, 쿠폰 초밥이 포함된 상태로 시작합니다.

3. **초기 최대 종류 수 설정**:

   - 현재 윈도우에 포함된 초밥의 서로 다른 종류 수를 `max_variety` 변수에 저장합니다.
   - `len(eaten)`을 사용하여 윈도우에 있는 초밥의 종류 수를 계산하고, 이를 초기 최대값으로 설정합니다.

4. **슬라이딩 윈도우 이동 및 종류 수 계산**:

   - `for` 반복문을 통해 벨트의 모든 위치에서 슬라이딩 윈도우를 한 칸씩 이동합니다.
   - 현재 윈도우에서 빠지는 초밥의 개수를 1 감소시키고, 만약 해당 초밥의 개수가 0이 되면 딕셔너리에서 제거합니다.
   - 새로운 위치의 초밥을 윈도우에 추가하여 개수를 증가시킵니다.
   - 이때, `(i + k) % N`를 사용하여 벨트의 끝을 넘어서면 다시 처음으로 돌아가도록 인덱스를 조정합니다.
   - `max_variety`를 매번 `len(eaten)`과 비교하여 최대값을 갱신합니다.

5. **결과 출력**:
   - 최종적으로 계산된 `max_variety` 값을 출력하여 손님이 먹을 수 있는 최대 초밥 종류 수를 결과로 반환합니다.

## 코드 구현

```python
import sys
from collections import defaultdict

# 첫 번째 줄의 입력을 받아 회전 초밥의 접시 수(N), 초밥의 종류 수(d), 연속해서 먹는 접시 수(k), 쿠폰 번호(c)를 변수에 저장
N, d, k, c = map(int, sys.stdin.readline().split())

# 회전 초밥 벨트에 놓인 각 초밥의 종류를 입력받아 리스트로 저장
sushi = [int(sys.stdin.readline()) for _ in range(N)]

# 현재 윈도우(슬라이딩 윈도우 내에 존재하는 초밥)의 초밥 종류와 그 개수를 저장할 딕셔너리를 생성
eaten = defaultdict(int)

# 초기 슬라이딩 윈도우 설정: 처음부터 연속된 k개의 초밥을 윈도우에 추가
for i in range(k):
    eaten[sushi[i]] += 1  # 해당 초밥 종류의 개수를 1 증가

# 쿠폰 초밥을 윈도우에 추가하여 쿠폰 초밥이 포함된 상태에서 시작
eaten[c] += 1

# 초기 상태에서 윈도우에 포함된 서로 다른 초밥의 종류 수를 최대 종류 수로 설정
max_variety = len(eaten)

# 슬라이딩 윈도우를 사용하여 전체 초밥 벨트를 한 바퀴(모든 접시 위치) 순회
for i in range(N):
    # 슬라이딩 윈도우의 가장 첫 번째 초밥을 윈도우에서 제거
    eaten[sushi[i]] -= 1  # 해당 초밥의 개수를 1 감소
    if eaten[sushi[i]] == 0:  # 만약 해당 초밥의 개수가 0이 되면 딕셔너리에서 제거 (종류 수가 감소)
        del eaten[sushi[i]]

    # 슬라이딩 윈도우의 끝에 새로운 초밥을 추가 (회전 초밥 특성을 고려해 인덱스가 초과되면 다시 처음으로 돌아감)
    eaten[sushi[(i + k) % N]] += 1  # 새로 추가되는 초밥의 개수를 1 증가

    # 현재 윈도우에 포함된 초밥의 종류 수가 더 크면 최대 종류 수를 갱신
    max_variety = max(max_variety, len(eaten))

# 최종적으로 계산된 서로 다른 초밥의 최대 종류 수를 출력
print(max_variety)
```
