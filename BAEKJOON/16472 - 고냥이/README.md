# 고냥이 문제 풀이 및 설명

<https://www.acmicpc.net/problem/16472>

<https://mayquartet.com/python-백준-16472-고냥이/>

## 문제 이해

이 문제는 제한된 개수의 고유한 문자만을 포함하는 연속된 문자열의 최대 길이를 찾는 문제입니다. 예를 들어, 문자열 내에서 최대 두 가지 종류의 문자만 포함하도록 제한된 경우, 해당 조건을 만족하는 가장 긴 연속된 부분 문자열을 찾는 것이 목표입니다. 문제의 핵심은 문자열 내에서 **연속적인 부분 문자열**을 추출하되, **주어진 문자 종류 제한을 초과하지 않는 최대 길이의 문자열**을 찾는 것입니다.

이를 위해 다음과 같은 요소를 고려해야 합니다:

- **문자 종류 제한**이 주어지며, 이 제한을 초과해서는 안 됩니다.
- **최대한 긴 길이의 문자열**을 찾아야 하므로, 가능한 한 최대 길이의 부분 문자열을 선택하는 것이 중요합니다.
- **슬라이딩 윈도우** 또는 **투 포인터**를 사용하여 문자열을 효율적으로 탐색하며 조건을 만족시키는 최적의 부분 문자열을 찾아야 합니다.

## 입출력 조건

**입력 조건**

1. 첫 번째 줄에 인식할 수 있는 **최대 알파벳 종류의 개수** `N`이 주어집니다. (`1 < N ≤ 26`)
2. 두 번째 줄에는 소문자 알파벳으로만 구성된 **문자열 `s`**가 주어집니다. (`1 ≤ 문자열 길이 ≤ 100,000`)

**출력 조건**

1. 번역기가 인식할 수 있는 알파벳 종류의 제한을 지키면서, 가능한 연속된 부분 문자열의 **최대 길이**를 정수로 출력합니다.

## 접근 방식

이 문제는 효율적인 탐색을 위해 **슬라이딩 윈도우**와 **투 포인터** 기법을 사용해 풀 수 있습니다. 슬라이딩 윈도우 기법을 활용하면 문자열의 시작과 끝 포인터를 설정하여 윈도우 내에 포함된 문자들을 유지하면서 윈도우의 크기를 조정할 수 있습니다.

1. **슬라이딩 윈도우**: 두 개의 포인터(`left`와 `right`)를 사용하여 윈도우의 범위를 정의합니다. `right` 포인터가 문자열의 오른쪽 끝으로 이동하며 각 문자들을 윈도우에 추가하고, `left` 포인터는 조건을 만족하지 않을 때 윈도우의 시작 지점을 이동시킵니다.
2. **문자 개수 관리**: 윈도우 내에 포함된 문자와 그 개수를 저장하여 고유 문자 개수를 관리합니다. 딕셔너리를 사용해 각 문자의 개수를 기록하여 윈도우 내에서 고유 문자 수가 `N`을 초과하는지 여부를 빠르게 확인할 수 있습니다.

3. **최대 길이 갱신**: 고유 문자 개수가 `N` 이하로 유지될 때마다 현재 윈도우의 길이를 기록하여 가장 긴 길이를 갱신합니다.

이 방식을 사용하면 문자열의 길이에 비례하는 시간 복잡도로 문제를 해결할 수 있습니다. 특히, 문자열의 길이가 최대 100,000이므로, 시간 복잡도가 `O(N)`인 방법을 통해 효율적으로 풀어야 합니다.

<https://mayquartet.com/algorithm-투-포인터two-pointer-알고리즘-이해하기/>

## 풀이 과정

1. `left`와 `right`라는 두 포인터를 사용하여 문자열의 현재 부분 문자열을 나타내는 윈도우를 정의합니다. 초기에는 `left`와 `right`를 0으로 설정합니다.
2. `char_count`라는 딕셔너리를 사용하여 윈도우 내에 포함된 각 문자의 개수를 저장합니다. `right` 포인터가 오른쪽으로 이동할 때마다 해당 문자의 개수를 증가시키고, 새로운 문자가 추가될 경우 고유 문자 수가 하나 증가합니다.

3. `right` 포인터를 문자열 끝까지 이동시키며, 윈도우 내 고유 문자 개수가 `N`을 초과하지 않는 최대 길이의 부분 문자열을 찾습니다.
4. 만약 윈도우 내 고유 문자 개수가 `N`을 초과하는 경우, `left` 포인터를 오른쪽으로 이동하여 윈도우를 축소하고, 고유 문자 개수를 `N` 이하로 조정합니다.

   - `left`가 이동할 때마다 `char_count`에서 해당 문자의 개수를 1 감소시키고, 만약 개수가 0이 된다면 딕셔너리에서 해당 문자를 삭제하여 고유 문자 개수를 줄입니다.

5. 매번 윈도우 내 고유 문자 개수가 `N` 이하일 때마다 `right - left + 1`로 현재 윈도우의 길이를 계산하고, 이 값이 `max_len`보다 크다면 `max_len`을 갱신하여 가장 긴 부분 문자열의 길이를 기록합니다.

6. 문자열의 끝까지 탐색이 완료되면 `max_len`에 저장된 값을 반환하여 답을 출력합니다.

이 과정을 통해 최적의 시간 복잡도인 `O(N)`으로 문제를 해결할 수 있으며, 슬라이딩 윈도우 기법을 사용하여 조건을 만족하는 가장 긴 부분 문자열의 길이를 찾을 수 있습니다.

## 코드 구현

```python
def max_substring_length(n, s):
    # 왼쪽 포인터를 초기화 (윈도우의 시작점)
    left = 0

    # 각 문자의 개수를 저장할 딕셔너리 초기화
    char_count = {}

    # 최대 길이를 저장할 변수 초기화
    max_len = 0

    # 오른쪽 포인터를 이동하며 문자열을 순회
    for right in range(len(s)):
        # 오른쪽 포인터가 가리키는 문자를 딕셔너리에 추가하거나, 기존 값에 1을 더함
        char_count[s[right]] = char_count.get(s[right], 0) + 1

        # 고유 문자 개수가 n을 초과하는 경우
        while len(char_count) > n:
            # 왼쪽 포인터가 가리키는 문자의 개수를 1 감소
            char_count[s[left]] -= 1

            # 해당 문자의 개수가 0이 되면 딕셔너리에서 삭제하여 고유 문자 개수를 줄임
            if char_count[s[left]] == 0:
                del char_count[s[left]]

            # 왼쪽 포인터를 오른쪽으로 한 칸 이동하여 윈도우를 축소
            left += 1

        # 현재 윈도우의 길이를 계산하고 최대 길이를 갱신
        max_len = max(max_len, right - left + 1)

    # 최대 길이를 반환
    return max_len

if __name__ == "__main__":
    # 첫 줄에서 인식할 수 있는 최대 알파벳 종류 수를 입력받음
    n = int(input().strip())

    # 두 번째 줄에서 문자열을 입력받음
    s = input().strip()

    # 최대 길이를 계산하는 함수를 호출하여 결과를 변수에 저장
    result = max_substring_length(n, s)

    # 결과를 출력
    print(result)
```
