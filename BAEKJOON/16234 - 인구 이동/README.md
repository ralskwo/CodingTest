# 인구 이동 문제 풀이 및 설명

<https://www.acmicpc.net/problem/16234>

<https://mayquartet.com/python-파이썬-백준-16234-인구-이동-문제-풀이-및-설명/>

## 문제 이해

이 문제는 **N x N 크기의 땅**이 있고, 각 칸에는 **하나의 나라**가 존재하는 설정입니다. 각 나라는 1x1 크기이므로, 모든 나라는 정사각형 모양의 땅을 차지합니다. 각 나라에는 인구 수가 주어지고, 인접한 나라 사이에는 **국경선**이 존재합니다.

문제에서 요구하는 것은 다음과 같습니다:

1. **인구 이동**이 조건에 맞으면 발생하고, 인구 이동이 발생한 **총 일수**를 계산해야 합니다.
2. 인구 이동은 다음과 같은 조건에 따라 진행됩니다:
   - 인접한 나라 사이의 인구 차이가 `L` 이상 `R` 이하일 때, 두 나라가 **국경선을 열고** 인구 이동이 가능합니다.
   - 인구 이동이 가능한 모든 나라들은 **하나의 연합**으로 묶이고, 연합에 속한 나라들의 인구는 `(연합의 총 인구) / (연합을 이루는 나라의 수)`로 **평균화**됩니다.
   - 연합이 해체된 후, 다음 날부터 새로운 인구 이동이 가능하도록 **모든 국경선은 닫힙니다**.

이 문제는 **언제까지 인구 이동이 지속되는지**, 즉 인구 이동이 더 이상 발생하지 않을 때까지의 **총 일수**를 구하는 문제입니다.

따라서 문제를 해결하려면, **연합**을 어떻게 찾고 **인구 이동을 어떻게 수행**할 것인지가 중요합니다. 이 문제는 인구 이동이 매일 발생할 수 있으므로, 각 나라의 인구 변동을 반복적으로 체크하여 더 이상 이동이 발생하지 않을 때까지 **반복적으로 확인**해야 합니다.

## 입출력 조건

### 입력 조건

1. 첫째 줄에 `N`, `L`, `R`이 주어집니다.
   - `N`은 땅의 크기를 나타내며, `1 ≤ N ≤ 50`입니다.
   - `L`과 `R`은 각각 두 나라 사이의 인구 차이의 **하한선**과 **상한선**을 의미하며, `1 ≤ L ≤ R ≤ 100`입니다.
2. 둘째 줄부터 `N`개의 줄에 걸쳐 각 나라의 인구 수가 주어집니다.
   - `A[r][c]` 형태로 주어지며, `0 ≤ A[r][c] ≤ 100`입니다.

### 출력 조건

- 인구 이동이 발생하는 **총 일수**를 출력해야 합니다.
- 인구 이동이 발생하지 않으면 `0`을 출력합니다.

## 접근 방식

이 문제는 **BFS**(너비 우선 탐색) 또는 **DFS**(깊이 우선 탐색) 알고리즘을 사용하여 해결할 수 있습니다. 두 나라 사이의 국경선이 열리는 조건을 체크하고, 조건을 만족하는 나라들끼리 **연합**을 형성하여 인구를 재분배합니다. 이후, 인구 이동이 더 이상 발생하지 않을 때까지 이 과정을 **반복적으로 수행**해야 합니다.

구체적인 접근 방식은 다음과 같습니다:

1. **BFS/DFS 탐색을 이용해 연합 찾기**:

   - 각 나라를 순차적으로 탐색하여 아직 방문하지 않은 나라에 대해 BFS 또는 DFS를 통해 인접한 나라들을 탐색합니다.
   - 탐색 중 인구 차이가 `L` 이상 `R` 이하인 인접 나라들끼리 연합을 형성합니다.

2. **연합 내 인구 재분배**:

   - 연합이 형성되면, 연합에 속한 나라들의 인구를 `연합의 총 인구 / 연합을 이루는 나라의 수`로 갱신합니다.

3. **반복 조건 설정**:

   - 연합이 형성된 후 인구 재분배가 이루어지면 `하루가 경과`한 것으로 간주하고, 인구 이동이 발생하지 않을 때까지 이 과정을 반복합니다.
   - 만약 하루 동안 인구 이동이 발생하지 않는다면, 더 이상 연합이 생기지 않으므로 반복을 종료합니다.

4. **최종 결과 도출**:
   - 반복이 종료되었을 때, 인구 이동이 발생한 총 일수를 출력합니다.

## 풀이 과정

1. **초기 설정**:

   - 문제의 입력값을 받아 `N x N` 크기의 인구 수 배열을 생성하고, 인접한 네 방향(상, 하, 좌, 우)을 나타내는 `directions` 배열을 설정합니다.

2. **BFS/DFS 탐색을 이용한 연합 형성**:

   - 방문 여부를 체크하기 위해 `visited`라는 2차원 배열을 생성합니다.
   - 방문하지 않은 각 나라에 대해 BFS를 수행하여 연합을 형성합니다.
   - BFS를 통해 탐색을 시작한 나라와 인구 차이가 조건에 맞는 모든 나라를 탐색하고 연합에 추가합니다.
   - 연합이 형성되면, 연합에 속한 나라들의 인구를 재분배합니다.

3. **연합 내 인구 재분배**:

   - 연합의 모든 나라의 인구를 `연합의 총 인구 / 연합을 이루는 나라의 수`로 갱신합니다. 이 과정에서 소수점은 버림 처리합니다.

4. **반복 수행**:

   - 매일 반복적으로 연합 형성과 인구 이동 과정을 수행합니다.
   - 더 이상 연합이 형성되지 않고, 인구 이동이 발생하지 않는다면 반복을 종료합니다.

5. **최종 결과 출력**:
   - 인구 이동이 발생한 총 일수를 출력합니다.
   - 모든 탐색이 종료되었을 때, 더 이상 이동이 발생하지 않는다면 `0`을 출력하고, 이동이 발생한 총 일수를 결과로 도출합니다.

## 코드 구현

```python
from collections import deque  # deque를 사용하기 위해 collections 모듈에서 가져옴

N, L, R = map(int, input().split())  # N: 땅의 크기, L: 인구 차이 하한선, R: 인구 차이 상한선
population = [list(map(int, input().split())) for _ in range(N)]  # 각 나라의 인구수를 2차원 리스트로 입력 받음
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 상, 하, 좌, 우 방향을 나타내는 벡터

def bfs(start_row, start_col, visited):  # BFS를 통해 연합을 찾고, 인구 이동을 수행하는 함수
    queue = deque()  # BFS를 위한 큐 생성
    queue.append((start_row, start_col))  # 시작점을 큐에 추가
    visited[start_row][start_col] = True  # 시작점 방문 처리
    union = [(start_row, start_col)]  # 연합에 포함된 나라를 저장할 리스트

    total_population = population[start_row][start_col]  # 연합의 총 인구수를 현재 나라의 인구수로 초기화
    country_count = 1  # 연합에 속한 나라의 개수를 1로 초기화

    while queue:  # 큐가 빌 때까지 반복
        row, col = queue.popleft()  # 큐에서 하나의 나라를 꺼냄

        for dr, dc in directions:  # 상, 하, 좌, 우 네 방향에 대해 반복
            new_row, new_col = row + dr, col + dc  # 새로운 나라의 좌표 계산

            # 새로운 좌표가 배열의 범위를 벗어나지 않고, 아직 방문하지 않은 경우
            if 0 <= new_row < N and 0 <= new_col < N and not visited[new_row][new_col]:
                # 두 나라의 인구 차이가 L 이상 R 이하인 경우
                if L <= abs(population[row][col] - population[new_row][new_col]) <= R:
                    visited[new_row][new_col] = True  # 새로운 나라를 방문 처리
                    queue.append((new_row, new_col))  # 새로운 나라를 큐에 추가
                    union.append((new_row, new_col))  # 새로운 나라를 연합에 추가
                    total_population += population[new_row][new_col]  # 연합의 총 인구수에 새로운 나라의 인구수 추가
                    country_count += 1  # 연합의 나라 수 1 증가

    new_population = total_population // country_count  # 연합에 속한 나라들의 새로운 인구수 계산 (소수점 버림)
    for row, col in union:  # 연합에 속한 모든 나라에 대해
        population[row][col] = new_population  # 연합의 모든 나라의 인구수를 새로운 인구수로 갱신

    return len(union) > 1  # 연합의 크기가 1보다 크면 인구 이동이 발생한 것으로 간주

days = 0  # 인구 이동이 발생한 일수를 0으로 초기화

while True:  # 무한 반복
    visited = [[False] * N for _ in range(N)]  # 방문 여부를 나타내는 2차원 리스트 초기화
    movement_occurred = False  # 인구 이동이 발생했는지 여부를 나타내는 변수 초기화

    for r in range(N):  # 모든 나라에 대해 행을 기준으로 반복
        for c in range(N):  # 모든 나라에 대해 열을 기준으로 반복
            if not visited[r][c]:  # 방문하지 않은 나라에 대해
                if bfs(r, c, visited):  # 해당 나라를 시작으로 BFS를 수행
                    movement_occurred = True  # 인구 이동이 발생했음을 표시

    if not movement_occurred:  # 인구 이동이 발생하지 않았으면
        break  # 반복 종료

    days += 1  # 인구 이동이 발생한 날 수 1 증가

print(days)  # 최종적으로 인구 이동이 발생한 일수를 출력
```
