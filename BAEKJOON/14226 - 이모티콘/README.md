# 이모티콘 문제 풀이 및 설명

<https://www.acmicpc.net/problem/14226>

<https://mayquartet.com/python-백준-14226-이모티콘/>

## 문제 이해

이 문제는 영선이가 화면에 스마일 이모티콘을 원하는 개수 `S`개 만들기 위해 필요한 최소 시간을 계산하는 문제입니다.  
영선이는 이모티콘을 만들기 위해 세 가지 연산만 사용할 수 있습니다.

1. 화면에 있는 모든 이모티콘을 **복사**해서 클립보드에 저장한다.
2. 클립보드에 있는 이모티콘을 **붙여넣기** 해서 화면에 추가한다.
3. 화면에 있는 이모티콘 중 하나를 **삭제**한다.

모든 연산은 **1초가 걸리며**, 클립보드는 덮어쓰기가 됩니다.  
이때, 일부 이모티콘만 복사하거나 삭제하는 것은 불가능하고, 클립보드가 비어있을 때 붙여넣기는 실행할 수 없습니다.  
목표는 이 세 가지 연산을 이용해 화면에 정확히 `S`개의 이모티콘을 만드는 데 걸리는 시간을 **최소화**하는 것입니다.

## 입출력 조건

**입력**

- 첫째 줄에 `S`가 주어집니다.
- `S`는 이모티콘의 목표 개수를 나타내며, `2 ≤ S ≤ 1000`의 범위를 가집니다.

**출력**

- 첫째 줄에 화면에 정확히 `S`개의 이모티콘을 만드는 데 필요한 **최소 시간**을 출력합니다.

## 접근 방식

이 문제는 상태를 정의하고 각 상태에서 가능한 연산을 통해 다른 상태로 이동하는 **그래프 탐색 문제**입니다.

- 각 상태는 `(화면 이모티콘 개수, 클립보드 이모티콘 개수)`로 나타낼 수 있습니다.
- 주어진 연산(복사, 붙여넣기, 삭제)을 통해 상태를 이동하며, 목표 상태인 `(S, 아무 클립보드 상태)`에 도달하는 최소 시간을 찾습니다.
- 이 문제에서 **너비 우선 탐색(BFS)** 알고리즘을 사용하면 됩니다.

너비 우선 탐색은 시작 상태에서 가까운 상태부터 탐색하므로, 각 상태에 도달하는 최소 시간을 보장합니다.

<https://mayquartet.com/algorithm-bfs-너비-우선-탐색-알고리즘/>

## 풀이 과정

1. **상태 정의와 초기 설정**

   - BFS 탐색을 위해 큐를 사용합니다.
   - 각 상태는 **(화면 이모티콘 수, 클립보드 이모티콘 수, 경과 시간)**으로 정의됩니다.
   - 초기 상태는 `(1, 0, 0)`입니다. 화면에는 이모티콘이 1개 있고, 클립보드는 비어있으며, 시간은 0초입니다.
   - 방문 여부를 확인하기 위해 2차원 리스트 `visited`를 사용합니다.

2. **연산 정의**  
   BFS 탐색 중 각 상태에서 세 가지 연산을 수행합니다.

   - **복사**: 화면에 있는 이모티콘을 클립보드에 복사합니다.

     - 다음 상태는 `(화면 이모티콘 개수, 화면 이모티콘 개수, 시간 + 1)`입니다.
     - 이 상태가 방문하지 않은 상태라면 큐에 추가하고 방문 처리합니다.

   - **붙여넣기**: 클립보드에 있는 이모티콘을 화면에 붙여넣습니다.

     - 다음 상태는 `(화면 이모티콘 개수 + 클립보드 개수, 클립보드 개수, 시간 + 1)`입니다.
     - 이 상태가 방문하지 않았고, 화면 이모티콘 개수가 `S`를 초과하지 않아야 합니다.
     - 조건을 만족하면 상태를 큐에 추가합니다.

   - **삭제**: 화면에 있는 이모티콘 중 하나를 삭제합니다.
     - 다음 상태는 `(화면 이모티콘 개수 - 1, 클립보드 개수, 시간 + 1)`입니다.
     - 이 상태가 방문하지 않았고, 화면 이모티콘 개수가 1 이상이라면 큐에 추가합니다.

3. **BFS 탐색**

   - BFS를 시작하고 큐에서 상태를 하나씩 꺼냅니다.
   - 현재 상태의 화면 이모티콘 수가 `S`와 같다면, 경과 시간을 반환합니다.
   - 각 상태에서 가능한 연산(복사, 붙여넣기, 삭제)을 순차적으로 수행합니다.
   - 각 연산 결과로 이동한 상태를 큐에 추가하고 방문 처리를 수행합니다.

4. **결과 반환**
   - BFS 탐색 도중 화면 이모티콘 개수가 `S`에 도달하면 탐색을 종료하고, 그때의 경과 시간을 출력합니다.
   - BFS는 최단 경로를 보장하므로, 출력된 시간이 최소 시간입니다.

## 코드 구현

```python
from collections import deque  # deque를 사용하기 위해 collections 모듈에서 deque를 가져옴

def bfs(S):  # 이모티콘 S개를 화면에 만드는데 걸리는 최소 시간을 구하는 BFS 함수
    queue = deque([(1, 0, 0)])  # 초기 상태: 화면에 이모티콘 1개, 클립보드에 0개, 시간은 0초
    visited = [[False] * (S + 1) for _ in range(S + 1)]  # 방문 여부를 저장하는 2차원 리스트
    visited[1][0] = True  # 시작 상태인 (화면에 1개, 클립보드에 0개)를 방문 처리

    while queue:  # 큐가 비어있지 않는 동안 반복
        screen, clipboard, time = queue.popleft()  # 현재 상태를 큐에서 꺼냄 (화면 이모티콘 수, 클립보드 이모티콘 수, 시간)

        if screen == S:  # 화면에 있는 이모티콘 개수가 S에 도달하면 현재까지의 시간 반환
            return time

        # 연산 1: 화면에 있는 이모티콘을 복사해서 클립보드에 저장
        if not visited[screen][screen]:  # 복사한 상태를 방문하지 않았다면
            visited[screen][screen] = True  # 방문 처리
            queue.append((screen, screen, time + 1))  # 새로운 상태를 큐에 추가 (화면 그대로, 클립보드에 screen 저장, 시간 1초 추가)

        # 연산 2: 클립보드에 있는 이모티콘을 화면에 붙여넣기
        if clipboard > 0 and screen + clipboard <= S and not visited[screen + clipboard][clipboard]:
            # 클립보드에 이모티콘이 있고, 화면에 붙여넣은 결과가 S를 넘지 않으며, 방문하지 않았다면
            visited[screen + clipboard][clipboard] = True  # 방문 처리
            queue.append((screen + clipboard, clipboard, time + 1))  # 새로운 상태를 큐에 추가 (화면에 붙여넣기 결과, 클립보드 그대로, 시간 1초 추가)

        # 연산 3: 화면에 있는 이모티콘 중 하나 삭제
        if screen > 0 and not visited[screen - 1][clipboard]:  # 화면에 이모티콘이 있고, 삭제한 상태를 방문하지 않았다면
            visited[screen - 1][clipboard] = True  # 방문 처리
            queue.append((screen - 1, clipboard, time + 1))  # 새로운 상태를 큐에 추가 (화면에서 1개 삭제, 클립보드 그대로, 시간 1초 추가)

S = int(input())  # 목표 이모티콘 개수 S를 입력받음
print(bfs(S))  # 최소 시간을 출력
```
