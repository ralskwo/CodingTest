# 여행 가자 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1976>

<https://mayquartet.com/python-파이썬-백준-1976-여행-가자-문제-풀이-및-설명/>

## 문제 이해

이 문제는 주어진 도시 간의 연결 정보와 여행 계획을 이용해, 주어진 경로가 가능한지를 판단하는 문제입니다. 한국의 여러 도시들 중 몇 개의 도시를 방문하려고 할 때, 해당 경로가 모든 도시를 정상적으로 방문할 수 있는지를 확인해야 합니다. 단, 여행 경로에서 도시들 간의 직접적인 연결뿐만 아니라, 다른 도시를 거쳐서도 이동할 수 있어야 합니다.

예를 들어, 만약 도시 `A`와 `B`가 연결되어 있고, `B`와 `C`가 연결되어 있다면, `A`에서 `C`로 바로 이동할 수 없어도 `B`를 거쳐서 이동할 수 있습니다. 이런 경로가 가능한지를 확인하기 위해 주어진 입력으로 각 도시의 연결 관계를 나타내는 인접 행렬이 주어집니다.

즉, 이 문제는 주어진 도시들의 연결 정보를 기반으로 여행 계획에 있는 도시들이 모두 서로 연결되어 있는지 확인해야 하는 문제로, 특정 도시에서 다른 도시로 갈 수 있는지에 대한 경로의 존재 여부를 확인하는 문제입니다.

## 입출력 조건

- **입력 조건**

  1. 첫 줄에는 도시의 수 `N`이 주어집니다. (`N`은 최대 200 이하의 자연수)
  2. 두 번째 줄에는 여행 계획에 포함된 도시의 수 `M`이 주어집니다. (`M`은 최대 1000 이하의 자연수)
  3. 다음 `N`개의 줄에는 각 도시 간의 연결 정보를 나타내는 `N x N` 크기의 인접 행렬이 주어집니다. 각 행의 `i`번째 줄의 `j`번째 값은 `i`번 도시와 `j`번 도시의 연결 여부를 나타냅니다. 값이 `1`이면 두 도시가 연결되어 있음을, `0`이면 연결되지 않았음을 의미합니다.
  4. 마지막 줄에는 여행 계획에 포함된 도시들이 주어집니다. 도시는 `1`부터 `N`까지의 번호로 표현됩니다.

- **출력 조건**
  - 여행 계획에 포함된 모든 도시가 서로 연결되어 있어 주어진 경로를 따라서 여행할 수 있다면 "YES"를 출력합니다.
  - 여행 계획에 포함된 도시들이 서로 연결되어 있지 않으면 "NO"를 출력합니다.

## 접근 방식

이 문제는 그래프 탐색과 관련이 있으며, 도시 간의 연결 상태를 확인하고, 주어진 여행 계획이 유효한지를 판단해야 합니다. 문제를 해결하기 위해 **유니온 파인드(Union-Find)** 또는 **플로이드-워셜(Floyd-Warshall)** 알고리즘을 사용할 수 있습니다.

1. **유니온 파인드(Union-Find) 사용**

   - 유니온 파인드 알고리즘을 사용하여 각 도시가 어느 그룹에 속해 있는지를 확인합니다.
   - 인접 행렬에서 `1`로 표시된 두 도시가 연결되어 있다면, 두 도시를 같은 그룹으로 합칩니다.
   - 이후 여행 계획에 포함된 모든 도시가 동일한 그룹에 속하는지 확인합니다.
   - 만약 모든 도시가 동일한 그룹에 속하면 여행 계획이 가능하므로 "YES"를 출력하고, 그렇지 않으면 "NO"를 출력합니다.

2. **플로이드-워셜(Floyd-Warshall) 사용**
   - 플로이드-워셜 알고리즘을 이용해 모든 도시 간의 최단 경로를 구할 수 있습니다.
   - 이 알고리즘을 통해 모든 도시 간의 경로를 확인한 후, 여행 계획에 포함된 모든 도시가 서로 도달 가능한지 확인할 수 있습니다.
   - 플로이드-워셜 알고리즘은 `N`의 값이 크지 않을 때 사용할 수 있으며, 시간 복잡도는 `O(N^3)`입니다.
   - 이후 여행 계획에 포함된 모든 도시들이 서로 도달할 수 있으면 "YES", 그렇지 않으면 "NO"를 출력합니다.

위 문제에서는 두 방법 중 유니온 파인드 알고리즘을 사용하는 것이 더 효율적이며, 시간 복잡도가 더 낮습니다.

## 풀이 과정

1. **입력 처리 및 초기화**

   - 먼저 입력값으로 주어진 도시의 수 `N`과 여행 계획의 도시 수 `M`을 입력받습니다.
   - 각 도시가 자신을 부모로 가지는 `parent` 배열을 초기화합니다. 이 배열은 유니온 파인드 알고리즘에서 각 도시가 속한 그룹의 최상위 부모를 나타냅니다.

2. **인접 행렬을 이용해 연결된 도시들을 하나의 그룹으로 합침**

   - 입력받은 `N x N` 인접 행렬을 순회하며, 연결된 도시 (`1`로 표시된 경우)를 확인합니다.
   - `union` 함수를 사용하여 두 도시를 같은 그룹으로 합칩니다.
   - `union` 함수는 `find` 함수를 통해 두 도시의 최상위 부모 노드를 찾아, 이 두 노드의 부모를 동일하게 설정하여 그룹을 합칩니다.

3. **여행 계획의 첫 번째 도시의 최상위 부모를 기준으로 설정**

   - 여행 계획에서 첫 번째 도시의 최상위 부모를 찾고, 이를 기준으로 다른 모든 도시들이 같은 그룹에 속하는지 확인합니다.
   - `find` 함수를 사용하여 여행 계획에 속한 각 도시의 부모를 확인하고, 만약 첫 번째 도시의 부모와 다른 도시의 부모가 다르면, 여행 경로가 불가능하므로 `NO`를 출력합니다.

4. **모든 도시가 같은 그룹에 속하면 "YES", 그렇지 않으면 "NO" 출력**
   - 여행 계획에 포함된 모든 도시들이 같은 그룹에 속한다면 "YES"를 출력합니다.
   - 그렇지 않으면 "NO"를 출력합니다.

## 코드 구현

```python
def find(parent, x):
    # x의 부모 노드를 찾는 함수 (경로 압축 기법을 이용하여 최적화)
    if parent[x] != x:  # 현재 노드가 자기 자신이 아니라면
        parent[x] = find(parent, parent[x])  # 부모 노드를 재귀적으로 찾아서 최상위 부모로 업데이트
    return parent[x]  # 최상위 부모 노드 반환

def union(parent, a, b):
    # 두 노드 a와 b를 같은 그룹으로 합치는 함수
    rootA = find(parent, a)  # a의 최상위 부모 노드 찾기
    rootB = find(parent, b)  # b의 최상위 부모 노드 찾기
    if rootA != rootB:  # a와 b의 부모가 다르다면 (다른 그룹에 속해 있다면)
        parent[rootB] = rootA  # b의 부모를 a의 부모로 설정하여 그룹을 합침

N = int(input())  # 도시의 수 입력 받기
M = int(input())  # 여행 계획에 속한 도시의 수 입력 받기

parent = [i for i in range(N+1)]  # 부모 노드 배열 초기화 (1부터 N까지 각 도시의 부모를 자기 자신으로 설정)

for i in range(1, N+1):
    # 각 도시의 연결 정보를 입력 받아서 인접 행렬을 순회
    row = list(map(int, input().split()))  # i번째 도시의 j번째 연결 정보를 입력 받기
    for j in range(1, N+1):
        if row[j-1] == 1:  # i번째 도시와 j번째 도시가 연결되어 있다면
            union(parent, i, j)  # 두 도시를 같은 그룹으로 합침

plan = list(map(int, input().split()))  # 여행 계획에 포함된 도시들을 입력 받기

root = find(parent, plan[0])  # 여행 계획의 첫 번째 도시의 최상위 부모 노드를 찾기
possible = True  # 여행 계획이 가능한지 여부를 저장할 변수 (초기값은 True로 설정)
for city in plan:
    # 여행 계획에 포함된 각 도시가 같은 그룹에 속하는지 확인
    if find(parent, city) != root:  # 현재 도시의 부모 노드가 첫 번째 도시의 부모와 다르다면
        possible = False  # 여행 계획이 불가능하므로 possible을 False로 설정
        break  # 더 이상 확인할 필요 없으므로 반복문 종료

print("YES" if possible else "NO")  # 여행 계획이 가능하면 YES, 불가능하면 NO 출력
```
