# 고층 및딩 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1328>

<https://mayquartet.com/python-백준-1328-고층-빌딩/>

# 문제 이해

이 문제는 동적 계획법(Dynamic Programming)을 이용하여 해결할 수 있는 조합론적 문제입니다. 상근이는 한 줄로 세워진 빌딩을 특정 위치에서 바라볼 때 보이는 빌딩의 수를 관찰합니다. 빌딩의 배치는 고유하며, 각 빌딩의 높이는 1부터 `N`까지 모두 다릅니다.

특정 조건이 주어졌을 때, 조건을 만족하는 빌딩 배치의 가능한 수를 구해야 합니다. 조건은 다음과 같습니다:

- `L`: 왼쪽에서 관찰했을 때 보이는 빌딩의 수.
- `R`: 오른쪽에서 관찰했을 때 보이는 빌딩의 수.
- 빌딩의 총 개수 `N`.

여기서 "보이는 빌딩의 수"는 특정 방향에서 더 높은 빌딩이 가려지지 않고 직접 보이는 빌딩을 의미합니다. 예를 들어, 왼쪽에서 관찰했을 때 이전 빌딩보다 더 높은 빌딩이 보이게 됩니다. 이 문제는 이를 만족하는 배치의 수를 계산하는 것입니다.

# 입출력 조건

## 입력 조건

- 첫 번째 줄에 세 개의 정수 `N`, `L`, `R`이 주어집니다.
  - `N`: 빌딩의 총 개수 (`1 ≤ N ≤ 100`)
  - `L`: 왼쪽에서 보이는 빌딩의 수 (`1 ≤ L ≤ N`)
  - `R`: 오른쪽에서 보이는 빌딩의 수 (`1 ≤ R ≤ N`)
- 입력값은 공백으로 구분됩니다.

## 출력 조건

- 조건을 만족하는 빌딩 배치의 가능한 수를 `1000000007`로 나눈 나머지를 출력합니다.
- 결과가 `0`이 될 수도 있으며, 이는 주어진 조건을 만족하는 빌딩 배치가 없다는 것을 의미합니다.

# 접근 방식

1. **문제를 분할하여 해결 가능한 형태로 정의합니다**:

   - 빌딩의 배치를 만들면서, 왼쪽과 오른쪽에서 보이는 빌딩의 수를 계산하는 동적 계획법을 사용합니다.
   - 동적 계획법의 상태를 정의하고, 각 상태를 이전 상태로부터 계산할 수 있도록 점화식을 설계합니다.

2. **동적 계획법의 상태 정의**:

   - `dp[n][l][r]`를 빌딩이 `n`개일 때 왼쪽에서 `l`개, 오른쪽에서 `r`개의 빌딩이 보이는 경우의 수로 정의합니다.

3. **초기 조건과 불가능한 경우 처리**:

   - 빌딩이 1개일 경우, 왼쪽과 오른쪽에서 보이는 빌딩의 수는 모두 1개입니다. 즉, `dp[1][1][1] = 1`입니다.
   - `l + r - 1 > n`인 경우는 불가능한 상태로 처리합니다.

4. **점화식 도출**:

   - 새로운 빌딩이 가장 왼쪽에 추가되는 경우:
     - `dp[n-1][l-1][r]`
   - 새로운 빌딩이 가장 오른쪽에 추가되는 경우:
     - `dp[n-1][l][r-1]`
   - 새로운 빌딩이 중간에 추가되어 보이는 빌딩의 수에 영향을 주지 않는 경우:
     - `(n-2) * dp[n-1][l][r]`
   - 위 세 가지를 더해 `dp[n][l][r]`를 계산합니다.

5. **최종 출력**:
   - `dp[N][L][R]` 값을 계산하여 출력합니다.

# 풀이 과정

1. `dp` 테이블을 초기화합니다. `dp[n][l][r]`는 빌딩의 개수, 왼쪽에서 보이는 빌딩의 수, 오른쪽에서 보이는 빌딩의 수를 기준으로 정의됩니다.

   - 초기 조건으로, `dp[1][1][1] = 1`을 설정합니다. 이는 빌딩이 하나일 때 왼쪽과 오른쪽에서 보이는 빌딩이 하나씩이라는 것을 의미합니다.

2. 빌딩의 개수 `n`을 2부터 `N`까지 증가시키며 각 상태를 계산합니다.

   - `l`은 1부터 `L`까지, `r`은 1부터 `R`까지 순회하며 가능한 모든 조합을 계산합니다.

3. 점화식을 이용하여 상태를 갱신합니다.

   - 왼쪽에서 보이는 빌딩이 하나 추가된 경우:
     - `left_visible = dp[n-1][l-1][r]`
   - 오른쪽에서 보이는 빌딩이 하나 추가된 경우:
     - `right_visible = dp[n-1][l][r-1]`
   - 중간에 새로운 빌딩이 추가되어 보이는 빌딩 수에 영향을 주지 않는 경우:
     - `middle_visible = (n-2) * dp[n-1][l][r]`
   - 세 가지를 모두 더하고 결과를 모듈러 연산합니다:
     - `dp[n][l][r] = (left_visible + right_visible + middle_visible) % MOD`

4. 최종적으로 `dp[N][L][R]` 값을 출력합니다.

   - 이는 입력값으로 주어진 `N`, `L`, `R`에 대해 조건을 만족하는 모든 빌딩 배치의 경우의 수를 나타냅니다.

5. 시간 복잡도는 `O(N × L × R)`로, 제한 조건 안에서 효율적으로 동작할 수 있습니다.

## 코드 구현

```python
MOD = 1000000007  # 결과 값을 나눌 모듈러 값 설정

def count_building_arrangements(N, L, R):
    # DP 테이블 초기화: dp[n][l][r]는 빌딩 n개일 때 왼쪽에서 l개, 오른쪽에서 r개 보이는 경우의 수
    dp = [[[0] * (R + 1) for _ in range(L + 1)] for _ in range(N + 1)]

    # 초기 조건: 빌딩이 하나일 때 왼쪽과 오른쪽에서 각각 하나씩 보이는 경우는 1가지
    dp[1][1][1] = 1

    # 동적 계획법을 이용해 dp 테이블 채우기
    for n in range(2, N + 1):  # 빌딩 개수를 2부터 N까지 순회
        for l in range(1, L + 1):  # 왼쪽에서 보이는 빌딩 개수를 1부터 L까지 순회
            for r in range(1, R + 1):  # 오른쪽에서 보이는 빌딩 개수를 1부터 R까지 순회
                # 새로운 빌딩이 가장 왼쪽에 추가되어 왼쪽에서 보이는 빌딩 개수가 늘어나는 경우
                left_visible = dp[n-1][l-1][r]
                # 새로운 빌딩이 가장 오른쪽에 추가되어 오른쪽에서 보이는 빌딩 개수가 늘어나는 경우
                right_visible = dp[n-1][l][r-1]
                # 새로운 빌딩이 중간에 위치하여 보이는 빌딩 개수가 변화하지 않는 경우
                middle_visible = (n-2) * dp[n-1][l][r]
                # 위 세 가지 경우를 더하여 현재 상태의 경우의 수 계산
                dp[n][l][r] = (left_visible + right_visible + middle_visible) % MOD

    # 계산된 경우의 수 반환
    return dp[N][L][R]

# 입력값 읽기
N, L, R = map(int, input().split())

# 결과 출력
print(count_building_arrangements(N, L, R))
```
