# 빵집 문제 풀이 및 설명

https://www.acmicpc.net/problem/3109

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-3109-%eb%b9%b5%ec%a7%91-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 격자 형태로 이루어진 빵집과 가스관을 연결하는 파이프를 설치하는 문제입니다. 빵집이 위치한 격자의 첫 번째 열은 가스관이 있는 곳이고, 마지막 열은 원웅이의 빵집이 있는 곳입니다. 원웅이는 첫 번째 열에서 시작해 마지막 열까지 파이프를 설치해야 하는데, 파이프는 오른쪽, 오른쪽 위 대각선, 오른쪽 아래 대각선으로만 이동할 수 있습니다.

또한, 중간에 건물(`x`)이 있는 칸은 피해야 하며, 파이프가 지나갈 수 있는 빈 칸(`.`)을 따라 이동해야 합니다. 파이프는 여러 개 설치할 수 있지만, 각 파이프는 서로 겹치거나 접할 수 없습니다. 이 문제는 가능한 한 많은 파이프를 설치하는 것이 목표이며, 격자에서 경로를 찾는 문제입니다.

## 입출력 조건

**입력 조건**은 다음과 같습니다:

- 첫 번째 줄에 격자의 행(`R`)과 열(`C`)의 개수가 주어집니다. 여기서 `R`은 1 이상 10,000 이하이고, `C`는 5 이상 500 이하의 값을 가집니다.
- 그 다음 `R`개의 줄에 걸쳐 각 줄에 `C`개의 문자가 주어지며, `.`는 빈 칸을 의미하고, `x`는 건물이 있는 칸을 의미합니다.
- 격자의 첫 번째 열과 마지막 열에는 항상 빈 칸(`.`)만 있습니다.

**출력 조건**은 다음과 같습니다:

- 원웅이가 설치할 수 있는 최대 파이프라인의 개수를 첫 번째 줄에 출력해야 합니다.

## 접근 방식

이 문제는 **그래프 탐색** 문제로 접근할 수 있습니다. 그래프의 각 노드는 격자의 칸을 의미하며, 노드 사이를 이동할 수 있는 방향은 오른쪽, 오른쪽 위 대각선, 오른쪽 아래 대각선 세 가지입니다. 파이프는 서로 겹칠 수 없으므로, 하나의 파이프 경로가 결정되면 다른 파이프는 그 경로와 겹치거나 접할 수 없습니다.

주어진 조건을 만족하는 경로를 찾는 데 가장 적합한 알고리즘은 **깊이 우선 탐색(DFS)**입니다. 각 행에서 첫 번째 열부터 시작하여 가능한 경로를 찾아 마지막 열에 도달하면 파이프 설치를 성공한 것으로 보고, 다른 경로를 탐색합니다.

탐색 시 **그리디 알고리즘**을 활용하여 가능한 경로 중에서 우선순위로 오른쪽 위 대각선, 오른쪽, 오른쪽 아래 대각선 순으로 탐색합니다. 이러한 방식으로 위쪽에서부터 먼저 경로를 확보함으로써, 경로 간 충돌을 최소화할 수 있습니다. 한 번 탐색한 경로는 다른 파이프가 침범하지 않도록 처리합니다.

## 풀이 과정

1. **입력 처리**:

   - `R`과 `C`를 입력받은 후, 각 행의 격자 상태를 리스트로 저장합니다. 여기서 `.`는 빈 칸을, `x`는 건물이 있는 칸을 의미합니다.

2. **탐색 방향 정의**:

   - 각 칸에서 이동할 수 있는 세 가지 방향을 정의합니다. 오른쪽 위 대각선, 오른쪽, 오른쪽 아래 대각선 순서로 경로를 탐색합니다. 이 순서는 가능한 한 위쪽에 있는 경로를 우선적으로 확보하기 위한 전략입니다.

3. **DFS 함수 작성**:

   - 각 행의 첫 번째 열에서 DFS를 시작합니다. 첫 번째 열에서 출발한 후, 오른쪽으로 이동하며, 이동 가능한 빈 칸을 찾습니다.
   - 각 칸에서 세 방향으로 이동할 수 있으며, 이미 방문한 칸이나 건물이 있는 칸은 이동할 수 없습니다.
   - DFS를 통해 마지막 열까지 도달한 경우, 파이프 설치에 성공한 것이므로 탐색을 종료하고 `True`를 반환합니다.
   - 도중에 막히면 해당 경로는 포기하고 다른 경로를 탐색합니다.

4. **첫 번째 열에서 모든 행 탐색**:

   - 첫 번째 열의 모든 행에서 파이프 설치를 시도합니다. 각 행에서 가능한 경로를 찾으면 그 경로를 `visited`로 표시해 다른 경로가 겹치지 않도록 합니다.
   - 첫 번째 열에 빈 칸이 있을 경우에만 DFS를 수행하며, 파이프를 성공적으로 설치할 때마다 카운트를 증가시킵니다.

5. **결과 출력**:
   - 모든 경로 탐색이 끝난 후, 최종적으로 설치된 파이프의 개수를 출력합니다.

## 코드 구현

```python
import sys
sys.setrecursionlimit(100000)  # 파이썬의 재귀 호출 제한을 늘려줌. 기본 재귀 한도를 100,000으로 설정

R, C = map(int, input().split())  # 격자의 행(R)과 열(C)을 입력받음
grid = [list(input().strip()) for _ in range(R)]  # 각 행을 입력받아 2차원 리스트 형태로 저장

# 이동할 수 있는 방향을 정의 (오른쪽 위 대각선, 오른쪽, 오른쪽 아래 대각선)
dx = [-1, 0, 1]
dy = [1, 1, 1]

# 방문 여부를 기록할 리스트를 생성 (초기값은 모두 False)
visited = [[False] * C for _ in range(R)]
pipeline_count = 0  # 설치된 파이프라인의 개수를 저장할 변수

# 깊이 우선 탐색(DFS)을 수행하는 함수 정의
def dfs(x, y):
    if y == C - 1:  # 마지막 열에 도착하면 True를 반환 (파이프 설치 성공)
        return True

    # 세 방향 (오른쪽 위 대각선, 오른쪽, 오른쪽 아래 대각선)으로 이동 시도
    for i in range(3):
        nx, ny = x + dx[i], y + dy[i]  # 새로운 좌표 계산
        # 새로운 좌표가 유효한 범위 내에 있고, 빈 칸이며, 아직 방문하지 않았다면
        if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == '.' and not visited[nx][ny]:
            visited[nx][ny] = True  # 해당 좌표를 방문 처리
            if dfs(nx, ny):  # 다음 칸으로 재귀적으로 탐색
                return True  # 성공적으로 마지막 열에 도달한 경우 True 반환
    return False  # 모든 방향에서 실패한 경우 False 반환

# 첫 번째 열의 모든 행에서 파이프 설치 시도
for i in range(R):
    if grid[i][0] == '.':  # 첫 번째 열의 빈 칸에서만 파이프 설치를 시도
        if dfs(i, 0):  # 해당 행에서 파이프가 설치 가능하면
            pipeline_count += 1  # 파이프 설치 개수를 증가

print(pipeline_count)  # 설치된 파이프라인의 최대 개수를 출력
```
