# 욕심쟁이 판다 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1937>

<https://mayquartet.com/python-백준-1937-욕심쟁이-판다/>

## 문제 이해

이 문제는 주어진 n x n 크기의 대나무 숲에서 판다가 최대한 많은 칸을 이동할 수 있는 경우를 찾는 문제입니다. 판다는 현재 위치의 대나무를 모두 먹은 후, 상하좌우 중 하나의 인접한 칸으로 이동합니다. 단, 이동 조건은 다음 위치의 대나무 양이 현재 위치의 대나무 양보다 많아야 한다는 것입니다. 판다가 이동 가능한 칸 수의 최댓값을 계산하기 위해, 특정 시작 위치와 이동 경로를 탐색해야 합니다.

판다가 이동하면서 방문 가능한 칸의 최댓값을 구하기 위해 문제를 풀 때, 탐색 중복을 방지하거나 효율적인 탐색 방법을 고려해야 합니다. 이를 위해 다이나믹 프로그래밍과 DFS를 결합하여 풀이합니다.

---

## 입출력 조건

### 입력 조건

1. 첫 번째 줄에는 대나무 숲의 크기 n이 주어집니다. 여기서 n은 1 이상 500 이하의 정수입니다.
2. 두 번째 줄부터 n개의 줄에는 대나무 숲의 정보가 주어지며, 각 줄에는 n개의 정수 값이 공백으로 구분됩니다.
3. 각 값은 해당 칸의 대나무 양을 나타내며, 1 이상 1,000,000 이하의 자연수입니다.

### 출력 조건

1. 판다가 이동할 수 있는 칸의 수의 최댓값을 한 줄로 출력합니다.

---

## 접근 방식

이 문제를 효율적으로 풀기 위해 다이나믹 프로그래밍과 DFS를 결합하여 풀이합니다. 다음과 같은 접근 방식을 사용합니다.

1. 판다가 대나무를 먹으면서 이동 가능한 모든 경로를 탐색해야 하므로, DFS(깊이 우선 탐색)를 사용하여 모든 가능한 이동 경로를 탐색합니다.
2. 각 위치에서 이동 가능한 최댓값을 저장하기 위해 DP(다이나믹 프로그래밍) 배열을 활용합니다. DP 배열을 사용하면 이미 계산된 위치의 결과를 재사용할 수 있어 중복 계산을 방지합니다.
3. 판다의 이동 조건(다음 위치의 대나무 양이 현재보다 많아야 함)을 고려하여 이동 가능한 방향(상, 하, 좌, 우)을 탐색합니다.
4. 모든 칸에서 탐색을 시작하고, 최종적으로 방문 가능한 칸의 최대 수를 찾습니다.

<https://mayquartet.com/algorithm-알고리즘-dfs-깊이-우선-탐색-알고리즘-이해하기/>

---

## 풀이 과정

1. 먼저 입력받은 대나무 숲의 정보를 2차원 리스트로 저장합니다. DP 배열은 모두 -1로 초기화하여 아직 탐색되지 않은 상태를 나타냅니다.

2. DFS를 사용하여 각 칸에서 판다가 이동할 수 있는 칸의 최대 개수를 탐색합니다. DFS 함수는 다음과 같이 동작합니다:

   - 현재 위치에서 이동 가능한 네 방향(상, 하, 좌, 우)을 탐색합니다.
   - 이동 조건을 만족하는 경우(다음 위치의 대나무 양이 더 많은 경우), 해당 위치로 이동하여 탐색을 이어갑니다.
   - 이동 결과를 바탕으로 현재 위치의 DP 값을 갱신합니다. 이미 계산된 DP 값이 존재하면 이를 그대로 반환하여 중복 계산을 방지합니다.

3. 모든 칸을 탐색 시작점으로 설정하여 DFS를 호출하고, 각 호출 결과 중 최댓값을 업데이트합니다. 이때, 모든 칸의 최댓값이 DP 배열에 저장되므로 효율적으로 결과를 계산할 수 있습니다.

4. 최종적으로 DP 배열에서 계산된 결과 중 가장 큰 값을 출력합니다. 이는 판다가 이동할 수 있는 최대 칸 수를 나타냅니다.

이 접근 방식은 효율적으로 탐색을 수행하며, 각 위치를 한 번만 탐색하므로 시간 복잡도는 O(n^2)로 제한됩니다. 이를 통해 대규모 입력에서도 문제를 해결할 수 있습니다.

## 코드 구현

```python
import sys
sys.setrecursionlimit(100000)  # 재귀 깊이 제한을 100,000으로 설정 (DFS 사용 시 스택 제한을 피하기 위해)

def dfs(x, y):  # (x, y) 지점에서 시작하는 DFS 함수 정의
    if dp[x][y] != -1:  # 이미 계산된 dp 값이 있는 경우, 해당 값을 반환하여 중복 계산 방지
        return dp[x][y]
    dp[x][y] = 1  # 초기값 설정: 현재 위치는 최소 1칸 이동 가능
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  # 네 방향(상, 하, 좌, 우)으로 탐색
        nx, ny = x + dx, y + dy  # 다음 탐색 위치 계산
        if 0 <= nx < n and 0 <= ny < n and forest[nx][ny] > forest[x][y]:
            # 다음 위치가 범위 내에 있고, 대나무 양이 현재 위치보다 많은 경우
            dp[x][y] = max(dp[x][y], 1 + dfs(nx, ny))
            # 이동 후의 최대 칸 수를 계산하여 dp 값 갱신
    return dp[x][y]  # 현재 위치에서 가능한 최대 칸 수 반환

n = int(input())  # 대나무 숲의 크기 n 입력 받음
forest = [list(map(int, input().split())) for _ in range(n)]
# 대나무 숲의 정보를 n x n 크기의 2차원 리스트로 입력 받음
dp = [[-1] * n for _ in range(n)]
# dp 배열을 -1로 초기화하여 아직 탐색되지 않은 상태를 표시
result = 0  # 결과값을 저장할 변수 초기화
for i in range(n):  # 대나무 숲의 모든 지점을 순회하며 시작 지점으로 설정
    for j in range(n):
        result = max(result, dfs(i, j))
        # 각 지점에서 시작한 dfs 결과 중 최댓값으로 갱신
print(result)  # 최종 결과 출력
```
