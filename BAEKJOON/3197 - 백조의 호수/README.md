# 백조의 호수 문제 풀이 및 설명

https://www.acmicpc.net/problem/3197

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-3197-%eb%b0%b1%ec%a1%b0%ec%9d%98-%ed%98%b8%ec%88%98-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 두 마리의 백조가 얼음으로 덮인 호수에서 살고 있지만 서로 만날 수 없는 상황을 해결하는 문제입니다. 호수는 직사각형 모양이고, 일부는 물(`.`), 일부는 얼음(`X`), 그리고 백조가 위치한 곳은 `L`로 표현됩니다. 시간이 지나면서 얼음은 물과 접촉한 부분부터 녹아내리며, 두 백조는 물 위에서만 움직일 수 있습니다. 즉, 얼음이 모두 녹으면 두 백조는 서로 만날 수 있습니다. 이때, 최소 며칠이 지나야 두 백조가 만날 수 있는지 계산하는 것이 문제의 목표입니다.

이 문제는 얼음이 녹는 과정을 시뮬레이션하고, 백조들이 이동 가능한 물의 범위가 얼마나 확장되는지 탐색하는 방식으로 해결할 수 있습니다. 두 백조가 서로 만날 수 있을 때까지 매일 얼음이 녹고 물이 확장되며, 그 과정에서 두 백조가 만날 수 있는지를 확인해야 합니다.

## 입출력 조건

1. **입력 조건**:

   - 첫 번째 줄에 호수의 행 개수 `R`과 열 개수 `C`가 주어집니다. (1 ≤ R, C ≤ 1500)
   - 이후 `R`개의 줄에 호수의 상태를 나타내는 길이 `C`의 문자열이 주어집니다.
     - `.`는 물을 나타내고,
     - `X`는 얼음을 나타내며,
     - `L`은 백조가 있는 위치를 나타냅니다.
     - 두 마리의 백조는 각각 하나의 `L`로 표시됩니다.

2. **출력 조건**:
   - 두 백조가 만나기까지 걸리는 최소 날짜를 출력합니다.

## 접근 방식

이 문제는 크게 두 가지 과정으로 나누어 생각할 수 있습니다.

1. **얼음이 녹는 과정 시뮬레이션**:

   - 매일 물과 인접한 얼음이 녹아 물이 됩니다. 이 과정을 시뮬레이션하며 물의 범위가 확장되는 과정을 탐색할 수 있습니다.
   - 이때 너비 우선 탐색(BFS, Breadth-First Search)을 사용하여 물과 인접한 얼음을 녹여 나가는 방식이 적합합니다. 물의 확장 속도는 상하좌우로 인접한 칸들만을 고려하므로, BFS로 매일 녹는 얼음을 처리해 나가면 효율적입니다.

2. **백조가 만날 수 있는지 확인**:
   - 백조는 물 위에서만 이동할 수 있기 때문에, 첫 번째 백조가 물 위를 이동하며 두 번째 백조에게 도달할 수 있는지를 확인해야 합니다.
   - 백조가 얼음 때문에 바로 만날 수 없다면, 얼음이 녹을 때까지 기다려야 하므로 이 역시 BFS로 탐색할 수 있습니다. 백조가 도달할 수 있는 영역을 BFS로 탐색하며, 두 번째 백조의 위치에 도달할 수 있는지 매일 확인합니다.

두 가지 과정은 동시에 진행됩니다. 즉, 얼음이 녹으면서 물의 영역이 확장되고, 백조는 물 위에서만 움직이므로, 매일 녹는 얼음의 변화에 따라 백조의 이동 경로가 확장됩니다. 이를 통해 백조들이 만나면 그때의 날짜를 출력합니다.

## 풀이 과정

1. **초기화**:

   - 입력을 받아 호수의 상태를 저장합니다. 백조의 위치는 따로 저장하고, 물의 위치는 BFS를 위한 큐에 미리 넣어둡니다.
   - 백조는 물 위에서만 움직일 수 있으므로 첫 번째 백조의 위치에서 BFS를 시작합니다. 이 과정에서 두 번째 백조의 위치에 도달할 수 있는지를 확인합니다.

2. **얼음 녹이기**:

   - 물과 인접한 얼음부터 녹이기 시작합니다. BFS로 물의 위치를 기준으로 상하좌우에 있는 얼음이 녹아 물이 되도록 매일 진행합니다.
   - 녹은 얼음의 위치는 다음 날 물로 변하게 되고, 이를 계속해서 큐에 넣어 다음 날 얼음이 녹도록 처리합니다.

3. **백조 이동 탐색**:

   - 첫 번째 백조가 물 위에서 이동할 수 있는 범위를 BFS로 탐색합니다. 물 위에서는 자유롭게 이동할 수 있고, 얼음이 있는 경우는 다음 날에 이동할 수 있으므로 다음 날 이동할 얼음의 위치를 따로 저장합니다.
   - 백조가 두 번째 백조의 위치에 도달하면 그 순간 탐색을 종료하고, 백조들이 만나기까지 걸린 날짜를 반환합니다.

4. **매일 반복**:

   - 매일 물의 범위가 확장되고, 백조가 이동할 수 있는 범위도 확장됩니다. 이 과정을 매일 반복하여 백조가 만날 수 있는지 확인합니다.
   - 두 백조가 만날 수 있게 되는 시점에 며칠이 지났는지를 계산하여 출력합니다.

5. **최종 결과 출력**:
   - 백조들이 만나는 날이 확인되면 그 날짜를 출력하고 프로그램을 종료합니다.

## 코드 구현

```python
from collections import deque

# R: 호수의 행 개수, C: 호수의 열 개수 입력 받음
R, C = map(int, input().split())

# 호수의 상태를 저장하는 2차원 리스트. 입력에서 각 줄을 받아 리스트로 변환
lake = [list(input().strip()) for _ in range(R)]

# 방향벡터. 상, 하, 좌, 우로 이동하기 위한 벡터
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# 백조의 위치를 저장할 리스트
swans = []

# 물이 있는 위치를 저장할 큐 (BFS 탐색을 위한 큐)
water_queue = deque()

# 호수 상태를 순회하며 백조의 위치와 물의 위치를 저장
for i in range(R):
    for j in range(C):
        if lake[i][j] == 'L':  # 백조의 위치일 경우
            swans.append((i, j))  # 백조 위치 저장
            lake[i][j] = '.'  # 백조가 있는 곳을 물로 변경
        if lake[i][j] == '.':  # 물 공간일 경우
            water_queue.append((i, j))  # 물의 위치를 큐에 저장

# 첫 번째 백조의 위치를 BFS 시작점으로 큐에 저장
swan_queue = deque([swans[0]])

# 백조가 이동한 위치를 기록하기 위한 방문 배열
visited_swan = [[False] * C for _ in range(R)]
visited_swan[swans[0][0]][swans[0][1]] = True  # 첫 번째 백조의 위치를 방문 처리

# 다음 날 백조가 이동할 수 있는 얼음의 위치를 저장하는 큐
next_swan_queue = deque()

# 물과 얼음을 녹이는 BFS 함수
def melt_ice():
    next_water_queue = deque()  # 다음 날에 물이 될 얼음의 위치를 저장하는 큐
    while water_queue:  # 물의 위치를 하나씩 처리
        x, y = water_queue.popleft()  # 현재 물의 위치를 꺼냄
        for i in range(4):  # 상, 하, 좌, 우로 인접한 위치를 확인
            nx, ny = x + dx[i], y + dy[i]  # 새로운 좌표 계산
            if 0 <= nx < R and 0 <= ny < C and lake[nx][ny] == 'X':  # 인접한 칸이 얼음일 경우
                lake[nx][ny] = '.'  # 얼음을 물로 변환
                next_water_queue.append((nx, ny))  # 녹은 물의 위치를 큐에 저장
    return next_water_queue  # 다음 날에 녹을 물의 위치를 반환

# 백조가 이동할 수 있는지 확인하는 BFS 함수
def move_swan():
    global next_swan_queue  # 전역 변수 사용
    while swan_queue:  # 백조의 이동을 처리하는 큐
        x, y = swan_queue.popleft()  # 현재 백조의 위치를 꺼냄
        if (x, y) == swans[1]:  # 두 번째 백조의 위치에 도착하면
            return True  # 백조들이 만났음을 나타내는 True 반환
        for i in range(4):  # 상, 하, 좌, 우로 인접한 위치를 확인
            nx, ny = x + dx[i], y + dy[i]  # 새로운 좌표 계산
            if 0 <= nx < R and 0 <= ny < C and not visited_swan[nx][ny]:  # 유효한 좌표이고 아직 방문하지 않은 경우
                visited_swan[nx][ny] = True  # 방문 처리
                if lake[nx][ny] == '.':  # 인접한 칸이 물일 경우
                    swan_queue.append((nx, ny))  # 물이므로 백조가 이동할 수 있음
                elif lake[nx][ny] == 'X':  # 인접한 칸이 얼음일 경우
                    next_swan_queue.append((nx, ny))  # 얼음이므로 다음 날에 이동할 수 있음
    return False  # 백조들이 아직 만나지 못했음을 나타내는 False 반환

# 전체 과정을 해결하는 함수
def solve():
    global water_queue, swan_queue, next_swan_queue  # 전역 변수 사용
    days = 0  # 날짜를 세기 위한 변수
    while True:  # 매일 반복
        if move_swan():  # 백조들이 만날 수 있으면
            return days  # 걸린 날짜를 반환하고 종료
        water_queue = melt_ice()  # 물을 확장하여 얼음을 녹임
        swan_queue, next_swan_queue = next_swan_queue, deque()  # 백조의 이동 경로를 다음 날로 갱신
        days += 1  # 하루가 지나면 날짜 증가

# 결과 출력
print(solve())
```
