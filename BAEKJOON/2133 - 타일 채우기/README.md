# 타일 채우기 문제 풀이 및 설명

https://www.acmicpc.net/problem/2133

## 문제 이해

이 문제는 3×N 크기의 벽을 2×1 크기의 세로 타일과 1×2 크기의 가로 타일을 사용하여 빈틈없이 채우는 경우의 수를 계산하는 문제입니다. N은 1 이상 30 이하의 값으로 주어지며, N이 1인 경우와 N이 2인 경우 등 간단한 경우는 예시에서 보여주듯이 해결할 수 있습니다. 그러나 N이 커질수록 타일을 배치하는 경우의 수가 매우 많아지기 때문에, 단순한 탐색이나 재귀로는 효율적인 해결이 어렵습니다. 이를 해결하기 위해 **동적 계획법(Dynamic Programming, DP)**을 사용하여 문제를 풀어야 합니다.

3×N 벽을 빈틈없이 채우기 위해서는 두 가지 타일 크기만 사용할 수 있는데, 각각 세로 타일(2×1)과 가로 타일(1×2)입니다. 이 타일들로 벽을 채우는 여러 가지 방법을 고려하여 모든 경우의 수를 찾아야 합니다.

## 입출력 조건

- **입력**: 첫 번째 줄에 정수 N이 주어집니다. N은 1 이상 30 이하의 자연수입니다. 이 N은 벽의 가로 길이를 나타내며, 3×N 크기의 벽을 의미합니다.
- **출력**: 첫 번째 줄에 3×N 크기의 벽을 타일로 채울 수 있는 경우의 수를 출력합니다.

## 접근 방식

이 문제를 풀기 위해서는 **동적 계획법(Dynamic Programming, DP)**을 사용하는 것이 적합합니다. DP는 복잡한 문제를 작은 부분 문제로 나누어 해결한 뒤, 그 결과를 저장하고 재사용하는 기법입니다. 이 문제에서 DP 배열을 사용하여 3×N 크기의 벽을 타일로 채우는 경우의 수를 계산할 수 있습니다.

우선, 기본적인 규칙을 이해해야 합니다. N이 2인 경우에는 채울 수 있는 방법이 3가지 있습니다. 그러나 N이 더 커질수록 타일 배치 방법은 여러 가지 패턴에 따라 달라집니다. 이때, N이 짝수인 경우에만 벽을 완전히 채울 수 있습니다. N이 홀수일 경우에는 벽을 채울 수 없기 때문에 경우의 수는 0이 됩니다.

주요 점화식은 다음과 같은 패턴을 따릅니다:

- `dp[i] = 4 * dp[i - 2] - dp[i - 4]`
  이 식은 N이 짝수일 때 벽을 채우는 경우의 수를 계산하는 방법으로, 이전 결과를 활용하여 중복되는 패턴을 제거한 후 최종적으로 경우의 수를 도출합니다.

## 풀이 과정

1. **기본 케이스 설정**:
   - N이 1인 경우, 3×1 크기의 벽을 타일로 채울 수 없으므로 경우의 수는 0입니다.
   - N이 2인 경우, 3×2 크기의 벽을 채우는 방법은 3가지이므로, 이 경우의 수는 3으로 고정합니다.
2. **동적 계획법 배열(dp 배열) 정의**:
   - `dp[i]`는 3×i 크기의 벽을 채우는 경우의 수를 저장하는 배열입니다. 초기화된 `dp` 배열은 모든 값을 0으로 설정합니다.
   - `dp[0]`은 3×0 크기의 벽을 채우는 경우, 즉 아무것도 없는 벽을 채우는 경우로 간주하여 경우의 수를 1로 설정합니다.
3. **점화식 설정 및 계산**:
   - N이 4 이상일 경우, 짝수인 N에 대해 벽을 채우는 경우의 수를 점화식으로 계산합니다.
   - 이 점화식은 `dp[i] = 4 * dp[i - 2] - dp[i - 4]`입니다. 이 식은 `dp[i - 2]`에서 파생된 경우의 수를 기반으로 하며, `dp[i - 4]`를 빼줌으로써 중복된 타일링 패턴을 제거합니다.
4. **결과 도출**:
   - 입력으로 주어진 N 값에 맞게 `dp` 배열을 채워나가고, 최종적으로 `dp[N]` 값을 출력합니다.

## 코드

```python
def count_tiling_ways(N):
    # N이 1 이하일 경우, 3xN 크기의 벽을 채울 수 없으므로 경우의 수는 0
    if N <= 0:
        return 0

    # N이 1일 경우도 3x1 크기의 벽을 채울 수 있는 방법이 없으므로 경우의 수는 0
    if N == 1:
        return 0

    # N이 2인 경우, 3x2 크기의 벽을 채울 수 있는 경우는 3가지 (기본적인 경우)
    if N == 2:
        return 3

    # N이 3 이상인 경우 동적 계획법(DP) 배열을 초기화
    # dp[i]는 3xi 크기의 벽을 채우는 경우의 수를 의미함
    dp = [0] * (N + 1)

    # 기본 케이스 설정
    dp[0] = 1  # 3x0 크기의 벽은 채울 수 있는 방법이 없음(0이므로 경우의 수는 1로 간주)
    dp[2] = 3  # 3x2 크기의 벽을 채우는 경우의 수는 3가지

    # DP 점화식을 이용하여 N이 짝수일 때 경우의 수를 계산
    # i가 짝수일 때마다 경우의 수를 업데이트함
    for i in range(4, N + 1, 2):
        # 3xi 크기의 벽을 채우는 경우의 수는 4 * (3x(i-2) 벽을 채우는 경우) - (3x(i-4) 벽을 채우는 경우)
        # 이는 특정 패턴의 타일링을 중복 계산하는 것을 방지하기 위한 점화식
        dp[i] = 4 * dp[i - 2] - dp[i - 4]

    # 최종적으로 N이 주어졌을 때 3xN 크기의 벽을 채우는 경우의 수 반환
    return dp[N]

# 표준 입력을 통해 값을 읽어들임
import sys
input = sys.stdin.read

# 입력 값으로 주어진 N을 정수로 변환
N = int(input().strip())

# 함수 호출 후 결과 출력
print(count_tiling_ways(N))
```
