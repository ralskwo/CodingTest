def count_tiling_ways(N):
    # N이 1 이하일 경우, 3xN 크기의 벽을 채울 수 없으므로 경우의 수는 0
    if N <= 0:
        return 0
    
    # N이 1일 경우도 3x1 크기의 벽을 채울 수 있는 방법이 없으므로 경우의 수는 0
    if N == 1:
        return 0
    
    # N이 2인 경우, 3x2 크기의 벽을 채울 수 있는 경우는 3가지 (기본적인 경우)
    if N == 2:
        return 3
    
    # N이 3 이상인 경우 동적 계획법(DP) 배열을 초기화
    # dp[i]는 3xi 크기의 벽을 채우는 경우의 수를 의미함
    dp = [0] * (N + 1)
    
    # 기본 케이스 설정
    dp[0] = 1  # 3x0 크기의 벽은 채울 수 있는 방법이 없음(0이므로 경우의 수는 1로 간주)
    dp[2] = 3  # 3x2 크기의 벽을 채우는 경우의 수는 3가지
    
    # DP 점화식을 이용하여 N이 짝수일 때 경우의 수를 계산
    # i가 짝수일 때마다 경우의 수를 업데이트함
    for i in range(4, N + 1, 2):
        # 3xi 크기의 벽을 채우는 경우의 수는 4 * (3x(i-2) 벽을 채우는 경우) - (3x(i-4) 벽을 채우는 경우)
        # 이는 특정 패턴의 타일링을 중복 계산하는 것을 방지하기 위한 점화식
        dp[i] = 4 * dp[i - 2] - dp[i - 4]
    
    # 최종적으로 N이 주어졌을 때 3xN 크기의 벽을 채우는 경우의 수 반환
    return dp[N]

# 표준 입력을 통해 값을 읽어들임
import sys
input = sys.stdin.read

# 입력 값으로 주어진 N을 정수로 변환
N = int(input().strip())

# 함수 호출 후 결과 출력
print(count_tiling_ways(N))
