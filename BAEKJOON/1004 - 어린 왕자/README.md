# 어린 왕자 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1004>

<https://mayquartet.com/python-백준-1004-어린-왕자/>

## 문제 이해

이 문제는 출발점에서 도착점까지 이동하는 동안 특정 행성계의 경계를 통과하는 횟수를 최소화하는 것을 목표로 합니다. 문제를 해결하기 위해 출발점과 도착점이 행성계 경계 내부 또는 외부에 위치하는지를 판단하고, 진입/이탈 횟수를 최소화해야 합니다. 문제의 핵심은 출발점과 도착점이 각각 행성계 경계에 들어가거나 나갈 때만 진입/이탈을 발생시킨다는 점입니다. 즉, 출발점과 도착점이 모두 행성계 경계 내부에 있으면 그 행성계는 진입/이탈이 없는 것이고, 둘 중 하나만 내부에 있을 때만 진입/이탈이 일어납니다.

각 행성계는 중심과 반지름으로 표현됩니다. 출발점과 도착점이 행성계 경계 내부에 있는지 여부를 확인해 경계를 몇 번 통과해야 하는지 판단하면 됩니다. 이를 통해 어린 왕자가 지나야 하는 최소 경계 횟수를 구할 수 있습니다.

## 입출력 조건

- **입력 조건**  
  첫 줄에 테스트 케이스의 개수 `T`가 주어집니다.
  각 테스트 케이스는 다음과 같은 형태로 주어집니다.

  - 첫 번째 줄에는 출발점 `(x1, y1)`과 도착점 `(x2, y2)`의 좌표가 주어집니다.
  - 두 번째 줄에는 행성계의 개수 `n`이 주어집니다.
  - 세 번째 줄부터 `n`개의 행별로 각 행성계의 중심 좌표 `(cx, cy)`와 반지름 `r`이 주어집니다.

- **출력 조건**  
  각 테스트 케이스에 대해 어린 왕자가 지나야 할 최소 진입/이탈 횟수를 한 줄에 출력합니다.

## 접근 방식

이 문제를 해결하기 위해 필요한 알고리즘적 접근은 다음과 같습니다.

1. **원 내부 판정**: 출발점과 도착점이 각각 행성계의 내부에 있는지를 판단해야 합니다. 이를 위해 두 점 간의 거리와 행성계의 반지름을 비교합니다. `(x - cx)² + (y - cy)² < r²`이면 점 `(x, y)`가 행성계 내부에 위치합니다.

2. **진입/이탈 판단**: 출발점과 도착점이 모두 행성계 내부에 있으면 해당 행성계 경계를 통과할 필요가 없습니다. 하지만 출발점과 도착점 중 하나만 내부에 있으면 경계를 통과해야 하므로 진입/이탈 횟수를 1회로 카운트합니다.

3. **반복 처리**: 각 행성계에 대해 위의 두 가지 과정을 반복하여 출발점과 도착점이 어느 행성계를 경유하는지 확인합니다.

## 풀이 과정

1. 입력값을 받아 `T`번 반복하여 각 테스트 케이스를 처리합니다. 테스트 케이스의 첫 번째 줄에서 출발점 `(x1, y1)`과 도착점 `(x2, y2)`를 입력받고, 두 번째 줄에서 행성계의 개수 `n`을 입력받습니다.

2. `n`개의 행성계 정보를 입력받고, 각 행성계의 중심 `(cx, cy)`와 반지름 `r`을 리스트 형태로 저장합니다.

3. `minimum_planet_entry_exit_count` 함수 내에서 각 행성계에 대해 `is_inside_circle` 함수를 사용해 출발점과 도착점이 행성계 내부에 위치하는지를 확인합니다. `is_inside_circle` 함수는 출발점 `(x1, y1)` 또는 도착점 `(x2, y2)`와 행성계 중심 `(cx, cy)` 간의 거리가 반지름 `r`보다 작은지를 계산하여 내부에 있는지 여부를 판정합니다.

4. 각 행성계에 대해 출발점과 도착점이 모두 내부에 있는지 확인합니다. 만약 둘 중 하나만 내부에 있는 경우, 그 행성계 경계를 통과해야 하므로 진입/이탈 횟수를 1회 추가합니다.

5. 모든 행성계에 대해 위의 과정을 완료한 후 `count` 값을 반환하여 해당 테스트 케이스의 진입/이탈 횟수를 계산합니다.

## 코드 구현

```python
import sys
import math

def is_inside_circle(x, y, cx, cy, r):
    # 주어진 점 (x, y)가 행성계의 중심 (cx, cy)과 반지름 r을 기준으로
    # 행성계 내부에 위치하는지 확인하는 함수
    # (x - cx)^2 + (y - cy)^2 < r^2이면 내부에 있다고 판단
    return (x - cx) ** 2 + (y - cy) ** 2 < r ** 2

def minimum_planet_entry_exit_count(x1, y1, x2, y2, planets):
    # 출발점 (x1, y1)에서 도착점 (x2, y2)까지 이동할 때,
    # 행성계의 경계를 넘는 최소 진입/이탈 횟수를 계산하는 함수
    count = 0  # 진입/이탈 횟수를 저장할 변수
    for cx, cy, r in planets:  # 모든 행성계에 대해 반복
        # 출발점이 현재 행성계 내부에 있는지 확인
        start_inside = is_inside_circle(x1, y1, cx, cy, r)
        # 도착점이 현재 행성계 내부에 있는지 확인
        end_inside = is_inside_circle(x2, y2, cx, cy, r)

        # 출발점과 도착점 중 하나만 내부에 있을 경우, 진입 또는 이탈이 발생하므로 카운트 증가
        if start_inside != end_inside:
            count += 1
    return count  # 최종 진입/이탈 횟수를 반환

# 테스트 케이스 개수 입력
T = int(input().strip())
results = []  # 각 테스트 케이스의 결과를 저장할 리스트

for _ in range(T):  # 각 테스트 케이스에 대해 반복
    # 출발점과 도착점의 좌표 입력
    x1, y1, x2, y2 = map(int, input().strip().split())
    # 행성계의 개수 입력
    n = int(input().strip())

    planets = []  # 각 행성계 정보를 저장할 리스트
    for _ in range(n):  # 각 행성계에 대해 반복
        # 행성계의 중심 좌표와 반지름 입력
        cx, cy, r = map(int, input().strip().split())
        planets.append((cx, cy, r))  # 행성계 정보를 리스트에 추가

    # 최소 진입/이탈 횟수를 계산하여 결과 리스트에 추가
    result = minimum_planet_entry_exit_count(x1, y1, x2, y2, planets)
    results.append(result)

# 각 테스트 케이스의 결과를 출력
for result in results:
    print(result)
```
