# 사냥꾼 문제 풀이 및 설명

https://www.acmicpc.net/problem/8983

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-8983-%ec%82%ac%eb%83%a5%ea%be%bc-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 **사대와 동물의 위치**가 주어진 사냥터에서, 사대에서 사정거리 내에 있는 동물들을 잡을 수 있는지 계산하는 문제입니다. 사대는 **x축 위에 위치한 M개의 점**으로 표현되며, 각 동물은 2차원 평면 상에서 **x, y 좌표**로 나타납니다. 주어진 사정거리 L을 기준으로, 사대에서 동물까지의 거리가 L보다 작거나 같은 경우에만 그 동물을 잡을 수 있습니다. 사대와 동물 사이의 거리는 **맨해튼 거리**로 계산되며, 이 거리는 \(|x_i - a_j| + b_j\)로 정의됩니다. 이때 **x_i**는 사대의 x 좌표, **a_j**는 동물의 x 좌표, **b_j**는 동물의 y 좌표입니다.

이 문제를 해결하기 위해서는 각 동물에 대해 가까운 사대를 찾아서 그 사대와의 거리가 사정거리 이내인지를 확인해야 합니다. 사대의 수와 동물의 수가 최대 100,000까지 주어질 수 있으므로, **효율적인 알고리즘**이 필요합니다.

## 입출력 조건

### 입력

- 첫 번째 줄에는 **사대의 수 M (1 ≤ M ≤ 100,000)**, **동물의 수 N (1 ≤ N ≤ 100,000)**, **사정거리 L (1 ≤ L ≤ 1,000,000,000)**이 공백으로 구분되어 주어집니다.
- 두 번째 줄에는 **M개의 사대 위치**가 공백으로 구분되어 주어집니다. 사대의 위치는 **x 좌표로** 주어지며, **사대의 위치는 중복되지 않습니다**.
- 세 번째 줄부터는 **N개의 동물 위치**가 각각 한 줄에 하나씩 주어집니다. 동물의 위치는 **x 좌표와 y 좌표**로 주어집니다. 동물의 위치는 모두 양의 정수이며, **동물의 위치는 중복되지 않습니다**.

### 출력

- 출력은 **한 줄**이며, 사대에서 사정거리 내에 있는 동물의 수를 **음수가 아닌 정수**로 출력합니다.

## 접근 방식

이 문제를 효율적으로 풀기 위해서는 **이분 탐색**을 사용한 방법이 가장 적합합니다. 각 동물에 대해 가장 가까운 사대를 찾고, 그 사대와의 거리를 계산하여 사정거리 L 이내에 있는지 확인하는 방식으로 문제를 해결할 수 있습니다.

1. **사대의 위치를 정렬**한 후, 각 동물에 대해 사대 위치를 기준으로 **이분 탐색**을 사용하여 가장 가까운 사대를 찾습니다. 이때, 동물의 x 좌표에 가장 가까운 사대를 찾고, 그 사대와의 거리와 사정거리를 비교합니다.
2. **맨해튼 거리**를 사용하여 사대와 동물 간의 거리를 계산합니다. 거리 계산 방식은 \(|x_i - a_j| + b_j\)로, 이는 동물의 x 좌표와 사대의 x 좌표의 차이의 절댓값에 동물의 y 좌표를 더하는 방식입니다.
3. 이분 탐색을 통해 사대 리스트에서 동물의 x 좌표보다 **가까운 두 개의 사대**를 찾아 그 중 어느 사대와의 거리가 사정거리 L 이내인지 확인합니다. 가장 가까운 사대가 동물을 사냥할 수 있는지 확인하는 것이 핵심입니다.

이 방식은 **사대의 수 M과 동물의 수 N이 최대 100,000**일 때도 효율적으로 동작합니다. 사대 위치에 대한 이분 탐색을 통해 O(log M) 시간 복잡도로 각 동물에 대한 계산을 수행할 수 있으므로, 전체 시간 복잡도는 **O(N log M)**입니다.

## 풀이 과정

1. **입력 받기 및 사대 정렬**:
   - 먼저 사대의 위치 리스트를 입력받아 **오름차순으로 정렬**합니다. 이 정렬된 리스트를 통해 이분 탐색을 수행할 수 있게 됩니다.
2. **각 동물에 대해 가까운 사대 찾기**:
   - 각 동물의 위치에 대해 **x 좌표**에 가장 가까운 사대를 찾습니다. 이를 위해 **bisect 모듈**의 `bisect_left` 함수를 사용하여 동물의 x 좌표보다 크거나 같은 첫 번째 사대의 위치를 찾습니다.
   - 이때, 찾은 사대가 사정거리 내에 있는지 확인하기 위해 맨해튼 거리를 계산합니다.
3. **맨해튼 거리 계산 및 사정거리 확인**:
   - 동물과 사대 사이의 거리를 **맨해튼 거리**로 계산합니다. 거리는 \(|x_i - a_j| + b_j\)로 계산되며, 계산된 거리가 사정거리 L 이내라면 그 동물을 잡을 수 있습니다.
   - 이분 탐색으로 찾은 사대와 **그 이전 사대**(즉, 동물의 x 좌표보다 작은 사대) 두 개를 확인합니다. 이 두 사대 중 더 가까운 사대와의 거리가 사정거리 이내인지를 계산하여, 그 동물이 잡힐 수 있는지 여부를 결정합니다.
4. **카운트 및 출력**:
   - 잡을 수 있는 동물의 수를 카운트하여 최종적으로 출력합니다.

## 코드 구현

```python
import bisect  # bisect 모듈을 사용하여 이분 탐색 기능을 제공

def count_catchable_animals(m, n, l, shooting_spots, animals):
    shooting_spots.sort()  # 사대 위치를 오름차순으로 정렬
    catchable_count = 0  # 잡을 수 있는 동물의 수를 저장할 변수 초기화

    for x, y in animals:  # 각 동물에 대해 반복
        if y > l:  # 동물의 y 좌표가 사정거리 L보다 크면 사냥 불가능
            continue  # 해당 동물은 건너뛰기

        idx = bisect.bisect_left(shooting_spots, x)  # 이분 탐색으로 동물의 x 좌표에 가장 가까운 사대를 찾음

        is_catchable = False  # 해당 동물이 잡힐 수 있는지 여부를 저장할 변수 초기화

        if idx < len(shooting_spots):  # 찾은 사대의 인덱스가 유효한지 확인
            if abs(shooting_spots[idx] - x) + y <= l:  # 해당 사대와의 거리 계산 후 사정거리 내에 있으면
                is_catchable = True  # 잡을 수 있는 동물로 표시

        if idx > 0:  # 사대의 이전 위치도 확인 (가장 가까운 사대가 이전 사대일 수 있음)
            if abs(shooting_spots[idx - 1] - x) + y <= l:  # 이전 사대와의 거리 계산 후 사정거리 내에 있으면
                is_catchable = True  # 잡을 수 있는 동물로 표시

        if is_catchable:  # 동물이 잡을 수 있는 상태이면
            catchable_count += 1  # 잡을 수 있는 동물의 수를 증가시킴

    return catchable_count  # 최종적으로 잡을 수 있는 동물의 수 반환

m, n, l = map(int, input().split())  # 사대의 수, 동물의 수, 사정거리 L 입력 받기
shooting_spots = list(map(int, input().split()))  # 사대의 위치를 리스트로 입력 받기
animals = [tuple(map(int, input().split())) for _ in range(n)]  # 각 동물의 위치를 리스트로 입력 받기

result = count_catchable_animals(m, n, l, shooting_spots, animals)  # 동물들을 잡을 수 있는지 계산
print(result)  # 결과 출력
```
