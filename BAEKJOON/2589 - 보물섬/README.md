# 보물섬 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2589>

<https://mayquartet.com/python-백준-2589-보물섬/>

## 문제 이해

이 문제는 주어진 직사각형 모양의 보물 지도에서 가장 멀리 떨어져 있는 두 육지(L) 위치 간의 최단 거리를 계산하는 문제입니다. 여기서 최단 거리란 특정 육지에서 다른 육지까지 상하좌우 인접한 칸을 통해 이동하는 최단 경로를 뜻합니다. 즉, 한 칸씩 이동할 수 있는 육지들 중 가장 먼 거리에 있는 두 지점을 찾아 그 거리를 계산해야 합니다.

이 문제는 보물 지도가 `L`과 `W`로 구성되어 있으며, `L`은 육지, `W`는 바다를 나타냅니다. 문제의 목표는 서로 가장 멀리 떨어져 있어 이동 시간이 가장 오래 걸리는 두 육지 위치를 찾아 두 위치 사이의 최단 이동 거리를 구하는 것입니다. 예시에서는 서로 가장 멀리 떨어져 있는 두 육지를 찾아 이동 시간을 계산한 결과를 출력합니다.

이 문제에서 핵심적인 관점은 "가장 먼 거리에 있는 두 육지 간의 최단 거리"를 찾는 것입니다. 따라서 전체 지도를 탐색하면서 각 육지 위치에서 다른 육지로의 최단 거리를 구해, 그 중 최대값을 찾아야 합니다.

## 입출력 조건

**입력 조건**

- 첫 줄에 보물 지도의 세로 크기 `n`과 가로 크기 `m`이 공백으로 구분되어 주어집니다. (`1 ≤ n, m ≤ 50`)
- 그다음 줄부터 `n`개의 줄에 걸쳐 `L`과 `W`로 이루어진 문자열이 주어지며, 각 문자열은 보물 지도의 가로 길이 `m`을 나타냅니다.

**출력 조건**

- 보물이 묻힌 두 위치 사이의 최장 최단 거리를 출력합니다.

## 접근 방식

이 문제를 해결하기 위해서는 다음과 같은 알고리즘을 사용할 수 있습니다.

1. **BFS(너비 우선 탐색)**:

   - BFS는 시작 지점에서 모든 다른 지점으로의 최단 거리를 구하는 데 적합한 탐색 방법입니다. BFS는 각 지점을 상하좌우로 이동하며 인접한 육지를 탐색하므로, 주어진 지점에서 다른 모든 지점까지의 최단 거리를 효율적으로 계산할 수 있습니다.
   - 이 문제에서 BFS를 활용하여 각 육지 지점에서 출발해 다른 육지까지의 거리를 구한 후, 그 중 가장 먼 거리를 기록하여 최장 최단 거리를 찾습니다.

2. **모든 육지에서 BFS 수행**:
   - 각 육지 위치에서 BFS 탐색을 수행해 최장 거리를 찾습니다. 이때, 모든 육지 위치에서 출발해 BFS를 수행하여 다른 육지까지의 최단 거리를 계산하면, 문제에서 요구하는 '가장 먼 거리에 있는 두 육지 사이의 최단 거리'를 찾을 수 있습니다.
   - 각 BFS 탐색에서 기록한 최장 거리를 저장해 둔 후, 전체 지도에서의 최장 최단 거리를 출력합니다.

이 문제는 주어진 지도에서 각 육지마다 BFS를 수행하여 최장 거리를 찾아야 하므로 시간 복잡도는 약 `O(N * M * (N + M))`입니다. 주어진 지도 크기 범위에서는 이 정도의 복잡도로도 충분히 해결할 수 있습니다.

<https://mayquartet.com/algorithm-bfs-너비-우선-탐색-알고리즘/>

## 풀이 과정

1. **지도와 방향 벡터 정의**:

   - 보물 지도를 입력받고, 각 위치의 이동을 상하좌우로 제한하기 위해 방향 벡터를 정의합니다. 방향 벡터는 `(상, 하, 좌, 우)`로 구성되어 있으며, BFS 탐색에서 인접한 칸으로 이동할 때 사용됩니다.

2. **BFS 함수 구현**:
   - BFS를 위한 함수 `bfs(x, y)`를 정의합니다. 이 함수는 `(x, y)` 위치에서 출발해 다른 육지까지의 최단 거리를 탐색합니다. 탐색 중 현재 위치에서 도달할 수 있는 최장 거리를 기록합니다.
   - `queue`를 사용해 BFS를 구현하며, 시작 위치에서부터 큐에 추가하여 인접한 육지를 탐색합니다.
   - BFS 과정 중 각 육지를 탐색할 때마다, 방문 여부를 확인하기 위해 `visited` 배열을 생성해, 이미 방문한 위치는 다시 방문하지 않도록 합니다.
   - 탐색 중 현재 위치에서 최장 거리를 `max_distance`에 저장하며, 큐가 빌 때까지 반복하여 `bfs` 함수가 호출된 위치에서 도달할 수 있는 최장 거리를 계산합니다.
3. **모든 육지 위치에서 BFS 수행**:
   - 주어진 지도의 모든 육지 위치에서 BFS를 시작해 최장 거리를 계산합니다. 전체 지도를 탐색하며, 육지(`L`)가 발견될 때마다 해당 위치에서 `bfs` 함수를 호출해 그 위치에서 도달할 수 있는 최장 거리를 계산합니다.
   - 각 BFS 탐색이 완료되면, 해당 위치에서 도달할 수 있는 최대 거리를 `max_treasure_distance` 변수와 비교하여 업데이트합니다.
4. **최종 결과 출력**:
   - 모든 BFS 탐색이 완료되면 `max_treasure_distance` 변수에 보물 지도에서 가장 먼 두 육지 간의 최단 거리가 저장됩니다.
   - 이 최종 값을 출력하여 문제에서 요구하는 보물이 묻힌 두 위치 사이의 최장 최단 거리를 구합니다.

## 코드 구현

```python
from collections import deque  # BFS 구현을 위해 deque를 사용하기 위해 임포트

n, m = map(int, input().split())  # 지도 크기인 세로(n)와 가로(m)를 입력받음
treasure_map = [input().strip() for _ in range(n)]  # 보물 지도를 입력받아 리스트로 저장

# 상하좌우 이동을 위한 방향 벡터 정의
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

# BFS 탐색을 수행하는 함수 정의
def bfs(x, y):
    # BFS를 위한 큐를 생성하고 시작 위치 (x, y)와 거리(0)를 큐에 추가
    queue = deque([(x, y, 0)])

    # 방문 여부를 확인하기 위한 2차원 배열 생성
    visited = [[False] * m for _ in range(n)]
    visited[x][y] = True  # 시작 위치를 방문으로 표시

    max_distance = 0  # 현재 BFS 탐색에서의 최대 거리를 저장하는 변수

    # 큐가 빌 때까지 반복하여 BFS 수행
    while queue:
        cx, cy, dist = queue.popleft()  # 큐에서 현재 위치와 거리를 가져옴
        max_distance = max(max_distance, dist)  # 최장 거리 갱신

        # 네 방향으로 이동하며 인접한 육지를 탐색
        for dx, dy in directions:
            nx, ny = cx + dx, cy + dy  # 새로운 위치 계산

            # 이동한 위치가 지도 범위 내에 있고, 방문하지 않았으며, 육지인 경우
            if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and treasure_map[nx][ny] == 'L':
                visited[nx][ny] = True  # 새로운 위치를 방문으로 표시
                queue.append((nx, ny, dist + 1))  # 거리 1 증가하여 큐에 추가

    return max_distance  # BFS 탐색에서 발견한 최장 거리를 반환

# 전체 탐색에서의 최장 최단 거리를 저장할 변수
max_treasure_distance = 0

# 모든 육지 위치에서 BFS 탐색을 수행하여 최장 거리를 갱신
for i in range(n):
    for j in range(m):
        if treasure_map[i][j] == 'L':  # 현재 위치가 육지인 경우에만 탐색
            max_treasure_distance = max(max_treasure_distance, bfs(i, j))  # 최장 거리 갱신

# 보물이 묻힌 두 위치 간의 최장 최단 거리를 출력
print(max_treasure_distance)
```
