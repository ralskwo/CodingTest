# 열쇠 문제 풀이 및 설명

<https://www.acmicpc.net/problem/9328>

<https://mayquartet.com/python-파이썬-백준-9328-열쇠/>

## 문제 이해

이 문제는 그래프 탐색 문제로, 상근이가 빌딩의 평면도에서 가능한 최대 개수의 문서를 획득하는 것이 목표입니다. 상근이는 처음에 건물 밖에 있으며, 건물 내부로 들어가기 위해서는 주변에 놓여 있는 열쇠를 사용해 잠긴 문을 열어야 합니다. 각 열쇠는 특정 문을 열 수 있으며, 상근이는 열쇠를 여러 번 사용할 수 있습니다. 건물은 벽(`*`), 빈 공간(`.`), 문서(`$`), 열쇠(소문자), 문(대문자)로 구성됩니다. 상근이는 상하좌우로 이동할 수 있으며, 벽을 제외한 나머지 공간에서는 자유롭게 움직일 수 있습니다. 상근이는 특정 열쇠를 얻기 전에는 해당 열쇠로 열 수 있는 문을 통과할 수 없으며, 열쇠를 얻는 즉시 그 열쇠로 열 수 있는 모든 문이 열립니다. 목표는 상근이가 모든 이동 가능한 위치를 탐색하며 얻을 수 있는 최대 문서(`$`)의 수를 계산하는 것입니다.

## 입출력 조건

- **입력 조건**:
  - 첫째 줄에는 테스트 케이스의 수 `T`가 주어집니다. `T`는 최대 100입니다.
  - 각 테스트 케이스는 다음과 같이 구성됩니다:
    - 첫째 줄에는 빌딩의 높이 `h`와 너비 `w`가 공백을 두고 주어집니다. 여기서 `2 ≤ h, w ≤ 100`입니다.
    - 그 다음 `h`개의 줄에는 `w`개의 문자를 포함한 빌딩의 평면도가 주어집니다. 평면도는 빈 공간(`.`), 벽(`*`), 문서(`$`), 문(대문자), 열쇠(소문자)로 이루어져 있습니다.
    - 마지막 줄에는 상근이가 처음에 가지고 있는 열쇠들이 공백 없이 주어집니다. 열쇠가 없으면 "0"이 주어집니다.
- **출력 조건**:
  - 각 테스트 케이스마다 상근이가 획득할 수 있는 최대 문서(`$`)의 개수를 한 줄에 출력합니다.

## 접근 방식

이 문제를 해결하기 위해서는 BFS(너비 우선 탐색) 알고리즘을 사용하는 것이 적합합니다. BFS는 그래프를 레벨별로 탐색하므로, 상근이가 빌딩 내부에서 이동 가능한 모든 경로를 탐색하는 데 효과적입니다. 문제를 해결하기 위해 다음과 같은 전략을 사용할 수 있습니다:

1. **빌딩의 가장자리에서 시작**: 상근이는 처음에 건물 외부에 있으므로, 빌딩의 가장자리(즉, 건물의 외부와 접한 위치)에서 접근 가능한 모든 위치를 탐색의 시작점으로 삼습니다.
2. **열쇠와 문의 관리**: BFS를 진행하면서 열쇠를 발견하면 이를 기록하고, 해당 열쇠로 열 수 있는 모든 문을 즉시 열어 더 많은 경로를 탐색할 수 있도록 합니다. 열쇠를 얻기 전에는 해당 문을 통과할 수 없으므로, 열쇠를 얻을 때까지 해당 문 앞에서 대기할 필요가 있습니다.
3. **BFS를 이용한 탐색**: BFS를 사용해 현재 위치에서 이동할 수 있는 모든 위치를 탐색하며, 벽이나 열쇠가 없는 문은 자유롭게 이동합니다. 문서(`$`)를 발견하면 획득한 문서의 개수를 증가시킵니다.
4. **패딩 추가**: 상근이가 건물 외부에서 내부로 접근하는 과정을 쉽게 처리하기 위해, 빌딩에 패딩을 추가하여 외곽의 빈 공간(`.`)을 만들고, 이곳에서 탐색을 시작합니다.

<https://mayquartet.com/algorithm-bfs-너비-우선-탐색-알고리즘/>

## 풀이 과정

1. **입력 처리 및 초기화**:
   - `T`개의 테스트 케이스를 처리하기 위해, 각 테스트 케이스마다 빌딩의 크기와 평면도, 상근이가 가진 초기 열쇠 정보를 입력받습니다.
   - 빌딩의 외곽에 빈 공간을 추가한 새로운 평면도를 생성하여 상근이가 외부에서 시작할 수 있도록 합니다. 이를 통해, 빌딩의 가장자리에 있는 문과 열쇠를 쉽게 접근할 수 있습니다.
2. **BFS 탐색 준비**:
   - BFS 탐색을 위한 큐를 초기화하고, 상근이가 시작하는 위치인 `(0, 0)`을 큐에 추가합니다.
   - `visited` 배열을 사용해 각 위치의 방문 여부를 기록하여 중복 방문을 방지합니다.
   - `keys` 집합을 통해 상근이가 가진 열쇠들을 관리합니다. 열쇠를 발견할 때마다 `keys` 집합에 추가합니다.
   - `inaccessible_doors` 딕셔너리를 사용하여 열쇠를 얻기 전까지 접근할 수 없는 문의 위치들을 저장합니다. 나중에 해당 열쇠를 얻으면 이 위치들을 큐에 추가하여 탐색을 이어갑니다.
3. **BFS 탐색 진행**:
   - 큐가 빌 때까지 현재 위치에서 상하좌우로 이동 가능한 모든 위치를 탐색합니다.
   - 다음 위치가 벽(`*`)인 경우 이동할 수 없으므로 무시하고 넘어갑니다.
   - 빈 공간(`.`), 문서(`$`), 열쇠(소문자), 문(대문자)에 따라 각각 다르게 처리합니다:
     - `.` 또는 `$`: 빈 공간일 경우 계속 이동할 수 있습니다. 문서일 경우 획득한 문서의 개수를 증가시킵니다.
     - 소문자(열쇠): 열쇠를 발견하면 `keys` 집합에 추가하고, 이 열쇠로 열 수 있는 모든 대기 중인 문을 큐에 추가해 탐색을 이어갑니다.
     - 대문자(문): 해당 문에 필요한 열쇠가 없는 경우 `inaccessible_doors`에 해당 문의 좌표를 저장하고 대기 상태로 둡니다. 나중에 열쇠를 얻으면 다시 접근하여 탐색합니다.
4. **결과 반환 및 출력**:
   - 각 테스트 케이스마다 `documents_collected` 변수에 저장된 획득한 문서의 개수를 반환합니다.
   - 최종적으로 각 테스트 케이스의 결과를 한 줄씩 출력하여 상근이가 수집할 수 있는 최대 문서 수를 계산합니다.

## 코드 구현

```python
from collections import deque

# BFS를 사용하여 상근이가 얻을 수 있는 최대 문서 수를 계산하는 함수
def optimized_bfs(h, w, building, initial_keys):
    # BFS에서 사용할 상하좌우 이동 방향 설정
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    # 빌딩 맵을 확장하여 가장자리에 빈 공간을 추가하여 상근이가 건물 외부에서 시작할 수 있도록 설정
    extended_building = [['.'] * (w + 2)] + [['.'] + list(row) + ['.'] for row in building] + [['.'] * (w + 2)]

    # 초기 열쇠 목록을 대문자로 변환하여 집합에 저장 (열쇠가 "0"인 경우 제외)
    keys = set(k.upper() for k in initial_keys if k != '0')

    # BFS 탐색을 위한 큐 초기화 및 방문 여부 기록 배열 초기화
    queue = deque([(0, 0)])  # 상근이는 (0, 0) 위치에서 시작
    visited = [[False] * (w + 2) for _ in range(h + 2)]
    visited[0][0] = True  # 시작 위치를 방문 처리

    # 열쇠가 없어서 접근할 수 없는 문을 저장할 딕셔너리
    inaccessible_doors = {}
    # 상근이가 획득한 문서의 개수를 기록할 변수
    documents_collected = 0

    # BFS 탐색 시작
    while queue:
        # 큐에서 현재 위치를 꺼냄
        x, y = queue.popleft()

        # 상하좌우 네 방향에 대해 탐색
        for dx, dy in directions:
            nx, ny = x + dx, y + dy

            # 새로운 위치가 지도 범위 내에 있고 방문하지 않은 경우
            if 0 <= nx < h + 2 and 0 <= ny < w + 2 and not visited[nx][ny]:
                cell = extended_building[nx][ny]  # 해당 위치의 셀 값을 가져옴

                # 벽('*')인 경우, 이동할 수 없으므로 무시하고 넘어감
                if cell == '*':
                    continue

                # 현재 위치를 방문 처리
                visited[nx][ny] = True

                # 문서('$')를 발견한 경우, 문서 개수를 증가시킴
                if cell == '$':
                    documents_collected += 1
                # 소문자(열쇠)를 발견한 경우
                elif cell.islower():
                    key = cell.upper()  # 소문자를 대문자로 변환하여 열쇠로 사용
                    # 새로운 열쇠를 얻은 경우
                    if key not in keys:
                        keys.add(key)  # 열쇠를 추가
                        # 해당 열쇠로 열 수 있는 문들이 대기 중인 경우, 대기열에서 꺼내 큐에 추가
                        if key in inaccessible_doors:
                            queue.extend(inaccessible_doors[key])
                            del inaccessible_doors[key]  # 대기열을 제거
                # 대문자(문)를 발견한 경우
                elif cell.isupper():
                    # 해당 문에 필요한 열쇠가 없는 경우
                    if cell not in keys:
                        # 열쇠가 없으므로 대기열에 해당 문의 좌표를 저장하고 탐색을 멈춤
                        inaccessible_doors.setdefault(cell, []).append((nx, ny))
                        continue

                # 빈 공간 또는 열쇠가 있는 경우 큐에 추가하여 탐색을 계속 진행
                queue.append((nx, ny))

    # 획득한 문서의 총 개수를 반환
    return documents_collected

# 각 테스트 케이스를 처리하는 함수
def solve():
    # 빌딩의 높이와 너비 입력 받기
    h, w = map(int, input().split())
    # 빌딩의 평면도를 입력받아 리스트로 저장
    building = [input().strip() for _ in range(h)]
    # 상근이가 처음에 가지고 있는 열쇠 정보를 입력받음
    initial_keys = input().strip()
    # BFS 결과로 얻을 수 있는 최대 문서 개수를 반환
    return optimized_bfs(h, w, building, initial_keys)

# 테스트 케이스의 수를 입력받음
T = int(input())
# 각 테스트 케이스에 대해 결과를 출력
for _ in range(T):
    print(solve())
```
