# 지름길 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1446>

<https://mayquartet.com/python-파이썬-백준-1446-지름길-문제-풀이-및-설명/>

## 문제 이해

이 문제는 세준이가 고속도로를 이용해 학교까지 가는 도중, **지름길**을 사용해 운전해야 하는 거리를 최소화하는 문제입니다. 고속도로의 길이는 D로 주어지고, 여러 개의 지름길이 존재합니다. 지름길은 시작점과 끝점이 명확히 주어지며, 지름길을 이용할 경우 직선 거리를 단축할 수 있습니다. 하지만 지름길을 반드시 사용해야 하는 것은 아니며, 직선 거리가 더 짧으면 지름길을 사용하지 않아도 됩니다. 이 문제에서 우리가 해결해야 하는 것은, 주어진 고속도로에서 **최소한의 거리로 이동**하는 경로를 찾는 것입니다.

따라서 문제의 핵심은 고속도로를 따라가는 직선 경로와 지름길 중에서 **더 짧은 경로를 선택하는 최적화 문제**입니다. 문제의 조건에 맞게 지름길을 사용할지 여부를 결정하며 이동 거리를 최소화하는 것이 이 문제의 목표입니다.

## 입출력 조건

### 입력

1. 첫 번째 줄에는 지름길의 개수 `N`과 고속도로의 길이 `D`가 공백으로 구분되어 주어집니다.
   - `N`은 최대 12이며, 이는 지름길의 개수가 매우 적다는 것을 의미합니다.
   - `D`는 10,000 이하의 자연수로, 고속도로의 전체 길이를 나타냅니다.
2. 두 번째 줄부터 `N`개의 줄에는 각각의 지름길에 대한 정보가 주어집니다. 각 줄은 `시작점`, `끝점`, 그리고 해당 지름길의 `길이`로 구성됩니다.
   - 시작점과 끝점은 고속도로 상의 위치를 나타내며, 0 이상 10,000 이하의 자연수입니다.
   - 각 지름길의 시작점은 도착점보다 항상 작습니다.
   - 지름길의 길이는 시작점과 끝점 사이의 거리를 대체할 수 있으며, 그 길이가 더 짧을 때 유용합니다.

### 출력

- 세준이가 학교까지 가기 위해 운전해야 하는 **최소 거리**를 출력합니다. 즉, 고속도로를 지나는 여러 경로 중에서 가장 짧은 경로를 찾아 그 거리를 출력합니다.

## 접근 방식

이 문제는 최단 경로를 구하는 문제로, 우리가 해결해야 할 핵심은 **현재 위치에서 다음 위치로 가는 최단 경로를 선택하는 것**입니다. 이 문제는 기본적인 다익스트라 알고리즘의 변형 문제라고 볼 수 있습니다. 주어진 고속도로는 직선 경로로 이동할 수 있지만, 중간중간 지름길을 통해 더 짧은 거리를 이동할 수 있습니다. 다익스트라 알고리즘을 사용하는 이유는 **최단 경로를 효율적으로 탐색**할 수 있기 때문입니다.

문제를 해결하기 위해 필요한 단계는 다음과 같습니다:

1. **거리 배열 초기화**: 각 지점까지의 최소 거리를 저장할 배열을 생성합니다. 처음에는 모든 거리를 무한대로 설정한 후, 시작 지점(0)의 거리를 0으로 설정합니다.
2. **우선순위 큐 사용**: 다익스트라 알고리즘처럼 현재 위치에서 가장 짧은 경로를 탐색해야 하므로, 우선순위 큐를 사용해 현재 위치에서 다음 위치로 가는 최단 거리를 빠르게 처리합니다.

3. **직선 이동 및 지름길 사용 여부 판단**: 각 위치에서 직선으로 이동하는 경우와 지름길을 사용하는 경우 중, 더 짧은 경로를 선택하여 거리를 갱신합니다.

4. **탐색 종료**: 큐가 빌 때까지 모든 지점을 탐색하며, 마지막 지점인 고속도로 끝까지 도착하는 최단 경로를 반환합니다.

이 문제에서 중요한 점은 **매 지점마다 가능한 모든 경로(직선과 지름길)를 고려하여, 최단 경로를 선택해야 한다는 것**입니다. 이를 위해 다익스트라 알고리즘을 활용하여, 우선순위 큐를 통해 효율적으로 최단 경로를 찾을 수 있습니다.

## 풀이 과정

1. **초기 거리 설정**:

   - 0부터 D까지의 고속도로 길이에 대한 배열 `dist`를 생성합니다. 이 배열의 각 인덱스는 해당 지점까지의 최소 거리를 나타냅니다.
   - 시작점(0번 지점)은 거리가 0이므로 `dist[0] = 0`으로 설정하고, 나머지 지점은 모두 무한대(`float('inf')`)로 설정합니다. 이는 아직 계산되지 않았다는 의미입니다.

2. **우선순위 큐 사용**:

   - 다익스트라 알고리즘을 구현하기 위해 우선순위 큐를 사용합니다. 우선순위 큐는 현재까지의 최단 거리를 기준으로 가장 짧은 경로부터 처리할 수 있게 도와줍니다.
   - 시작점 `(0, 0)`을 큐에 넣습니다. 여기서 `(거리, 위치)`의 형태로 저장됩니다. 즉, 현재 위치가 0번 지점이고, 그 위치까지의 거리는 0입니다.

3. **현재 위치에서 다음 위치로 이동**:

   - 큐에서 가장 짧은 거리의 지점을 꺼내서 그 위치에서 다음 위치로 이동하는 경로를 계산합니다. 이때 두 가지 경우를 고려합니다:
     1. **직선 이동**: 현재 위치에서 다음 위치로 1칸 이동하는 경우.
     2. **지름길 이동**: 현재 위치가 지름길의 시작점이라면, 지름길을 이용해 끝점으로 이동하는 경우.
   - 이 두 가지 이동 방법 중 더 짧은 경로를 선택하여 `dist` 배열을 갱신합니다. 만약 새로운 경로가 더 짧다면, 그 값을 갱신하고 큐에 새로 넣어 계속 탐색합니다.

4. **지름길 적용**:

   - 각 지름길은 시작점, 끝점, 지름길의 길이를 갖고 있습니다. 현재 위치에서 지름길의 시작점에 도착했을 때, 지름길을 이용하여 끝점까지 이동하는 것이 더 빠르면 그 거리를 갱신합니다.
   - 예를 들어, 현재 위치가 지름길의 시작점과 일치하고, 지름길을 통해 도착할 수 있는 거리가 기존의 거리보다 짧다면, 그 값을 갱신하여 큐에 넣습니다.

5. **최종 결과 출력**:
   - 우선순위 큐가 비게 되면 탐색이 종료되고, 마지막 지점 `D`까지의 최소 거리가 `dist[D]`에 저장됩니다.
   - 최종적으로 `dist[D]`를 출력하여, 고속도로 끝까지 가는 최단 거리를 반환합니다.

이 과정은 효율적으로 최소 거리를 찾기 위한 다익스트라 알고리즘을 기반으로 하며, 지름길과 직선 경로 중 더 짧은 경로를 선택하는 방식으로 문제를 해결합니다.

## 코드 구현

```python
import heapq  # 힙큐 모듈을 불러옴 (다익스트라 알고리즘에서 우선순위 큐로 사용할 것)

def shortest_path(N, D, shortcuts):
    dist = [float('inf')] * (D + 1)  # 고속도로의 길이 D까지의 거리를 저장하는 리스트, 처음에는 무한대로 설정
    dist[0] = 0  # 시작 위치(0)까지의 거리는 0으로 설정

    pq = []  # 우선순위 큐를 저장할 리스트
    heapq.heappush(pq, (0, 0))  # 시작점 (거리 0, 위치 0)을 우선순위 큐에 삽입

    while pq:  # 큐가 빌 때까지 반복
        current_dist, current_pos = heapq.heappop(pq)  # 큐에서 가장 짧은 거리를 가진 위치를 꺼냄

        if current_dist > dist[current_pos]:  # 만약 현재 거리가 이미 처리된 거리보다 크면 무시
            continue

        if current_pos + 1 <= D and dist[current_pos + 1] > current_dist + 1:
            dist[current_pos + 1] = current_dist + 1  # 직선으로 다음 위치까지 이동하는 경우
            heapq.heappush(pq, (dist[current_pos + 1], current_pos + 1))  # 갱신된 거리를 큐에 삽입

        for start, end, length in shortcuts:  # 지름길을 탐색
            if current_pos == start and end <= D and dist[end] > current_dist + length:
                dist[end] = current_dist + length  # 지름길을 통해 도착하는 경우 더 짧다면 갱신
                heapq.heappush(pq, (dist[end], end))  # 갱신된 거리를 큐에 삽입

    return dist[D]  # D 위치까지의 최소 거리를 반환

N, D = map(int, input().split())  # 지름길의 개수 N과 고속도로의 길이 D 입력
shortcuts = [tuple(map(int, input().split())) for _ in range(N)]  # N개의 지름길 정보를 입력받아 리스트로 저장

print(shortest_path(N, D, shortcuts))  # 최단 경로를 계산한 후 출력
```
