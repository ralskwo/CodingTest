# 탈출 문제 풀이 및 설명

https://www.acmicpc.net/problem/3055

## 문제 이해

이 문제는 고슴도치가 물이 차오르는 숲에서 비버의 굴로 안전하게 도착할 수 있는지 확인하는 문제입니다. 숲은 R x C 크기의 격자 형태로 주어지며, 각 칸은 고슴도치의 위치(S), 비버의 굴(D), 물이 있는 위치(*), 또는 빈 칸(.)으로 표시됩니다. 물은 매 분마다 인접한 네 방향(상하좌우)으로 확장되며, 고슴도치는 물을 피하며 비버의 굴로 이동해야 합니다. 문제는 고슴도치가 비버의 굴로 도착할 수 있는 최소 시간을 계산하고, 만약 도착할 수 없다면 "KAKTUS"를 출력하는 것입니다.

이 문제를 이해하는 데 중요한 포인트는 물이 확산되는 속도와 고슴도치가 이동할 수 있는 시간이 연관되어 있다는 점입니다. 고슴도치는 물보다 먼저 비버의 굴에 도달해야 하며, 이때 물이 퍼진 위치에는 갈 수 없습니다. 따라서, 물이 퍼지는 시간과 고슴도치의 이동 시간을 함께 고려해야 합니다.

## 입력 조건

- 첫 번째 줄에는 숲의 크기를 나타내는 두 정수 R과 C가 주어집니다. (1 ≤ R, C ≤ 50)
- 다음 R개의 줄에는 숲의 지도가 주어지며, 각 줄은 C개의 문자로 구성됩니다.
  - '.'은 빈 칸을 나타냅니다.
  - '*'는 물이 있는 위치를 나타냅니다.
  - 'X'는 돌로 막힌 지역을 나타냅니다.
  - 'D'는 비버의 굴 위치를 나타냅니다.
  - 'S'는 고슴도치의 초기 위치를 나타냅니다.

출력 조건은 고슴도치가 비버의 굴에 도달할 수 있는 최소 시간을 출력하고, 도달할 수 없는 경우 "KAKTUS"를 출력하는 것입니다.

## 접근 방식

이 문제는 BFS(너비 우선 탐색, Breadth-First Search) 알고리즘을 사용하여 해결할 수 있습니다. BFS는 특정 지점에서 시작해 인접한 노드를 탐색하면서 최단 거리를 구하는 데 효과적인 알고리즘입니다. 이 문제에서는 고슴도치와 물의 이동 경로를 각각 BFS로 처리하여 물이 퍼지는 속도와 고슴도치의 이동 속도를 비교하면서 비버의 굴에 도달할 수 있는지를 판단해야 합니다.

1. 먼저, 물이 퍼지는 시간을 기록하는 BFS를 실행합니다. 물은 동시에 퍼져나가므로, 각 지점에 도달하는 시간을 기록하면서 퍼져나가는 것이 중요합니다.
2. 그 다음, 고슴도치의 이동을 BFS로 처리합니다. 이때 고슴도치는 물이 퍼지기 전에 도달할 수 있는지 판단해야 하므로, 물이 퍼진 시간보다 더 빨리 이동할 수 있는지 확인하면서 이동합니다.
3. BFS를 사용하면 가장 먼저 비버의 굴에 도달할 때의 시간이 최소 시간이 됩니다. 만약 고슴도치가 비버의 굴에 도달할 수 없으면 "KAKTUS"를 출력합니다.

## 풀이 과정

1. **초기화 단계**:
   - 물과 고슴도치의 초기 위치를 각각 큐에 저장합니다. 물의 위치는 `water_queue`에, 고슴도치의 위치는 `hedgehog_queue`에 저장합니다.
   - 물과 고슴도치의 이동 시간을 기록하기 위해 각각 `water_time`과 `hedgehog_time` 배열을 생성하고, 모든 칸을 -1로 초기화합니다. 초기 위치는 각각 0으로 설정합니다.

2. **물 퍼짐 BFS 실행**:
   - `water_queue`에서 물의 위치를 하나씩 꺼내어, 인접한 네 방향으로 물이 퍼져나가도록 합니다.
   - 새로운 위치가 빈 칸이고 아직 물이 도달하지 않은 곳이라면, 현재 시간보다 1 증가된 시간을 기록하고, 해당 위치를 큐에 추가합니다.
   - 이 과정을 반복하여 물이 퍼질 수 있는 모든 위치에 대해 퍼지는 시간을 기록합니다.

3. **고슴도치 이동 BFS 실행**:
   - `hedgehog_queue`에서 고슴도치의 위치를 하나씩 꺼내어, 인접한 네 방향으로 이동합니다.
   - 새로운 위치가 비버의 굴이라면 현재 위치의 시간보다 1 증가된 시간을 반환합니다. 이는 최소 시간에 도달했음을 의미합니다.
   - 새로운 위치가 빈 칸이고, 아직 방문하지 않은 곳이며, 물이 도달하는 시간보다 빨리 도착할 수 있는 경우에만 이동합니다.
   - 이동 가능한 위치를 큐에 추가하고, 계속해서 이동 경로를 확장해 나갑니다.

4. **결과 출력**:
   - 만약 고슴도치가 BFS 탐색 중에 비버의 굴에 도달하지 못하면, "KAKTUS"를 출력합니다.

이렇게 BFS를 두 번 실행하여, 고슴도치가 비버의 굴에 도달할 수 있는지, 있다면 최소 몇 분 만에 도달할 수 있는지를 계산할 수 있습니다. 이 과정에서 물의 퍼짐과 고슴도치의 이동을 동시에 고려하기 때문에 정확한 결과를 얻을 수 있습니다.

## 코드 구현
```python
from collections import deque  # deque를 사용하기 위해 collections 모듈에서 deque를 임포트

def bfs_escape(R, C, forest):  # 고슴도치 탈출을 계산하는 함수 정의
    water_queue = deque()  # 물의 위치를 저장할 큐를 생성
    hedgehog_queue = deque()  # 고슴도치의 위치를 저장할 큐를 생성
    water_time = [[-1] * C for _ in range(R)]  # 물의 퍼짐 시간을 저장할 2차원 배열을 초기화 (-1로 초기화)
    hedgehog_time = [[-1] * C for _ in range(R)]  # 고슴도치의 이동 시간을 저장할 2차원 배열을 초기화 (-1로 초기화)
    
    for i in range(R):  # 맵의 각 행을 순회
        for j in range(C):  # 각 행의 열을 순회
            if forest[i][j] == '*':  # 현재 위치에 물이 있으면
                water_queue.append((i, j))  # 해당 위치를 물 큐에 추가
                water_time[i][j] = 0  # 물의 시작 시간을 0으로 설정
            elif forest[i][j] == 'S':  # 현재 위치에 고슴도치가 있으면
                hedgehog_queue.append((i, j))  # 해당 위치를 고슴도치 큐에 추가
                hedgehog_time[i][j] = 0  # 고슴도치의 시작 시간을 0으로 설정
    
    while water_queue:  # 물 큐가 빌 때까지 반복
        x, y = water_queue.popleft()  # 물의 위치를 큐에서 꺼냄
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  # 상하좌우 방향으로 이동
            nx, ny = x + dx, y + dy  # 새로운 위치 계산
            if 0 <= nx < R and 0 <= ny < C and forest[nx][ny] == '.' and water_time[nx][ny] == -1:
                # 새로운 위치가 맵 내부이고, 빈 칸이며, 아직 물이 도달하지 않은 곳이라면
                water_time[nx][ny] = water_time[x][y] + 1  # 새로운 위치의 물 퍼짐 시간을 현재 위치의 시간보다 1 증가시킴
                water_queue.append((nx, ny))  # 새로운 위치를 물 큐에 추가
    
    while hedgehog_queue:  # 고슴도치 큐가 빌 때까지 반복
        x, y = hedgehog_queue.popleft()  # 고슴도치의 위치를 큐에서 꺼냄
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  # 상하좌우 방향으로 이동
            nx, ny = x + dx, y + dy  # 새로운 위치 계산
            if 0 <= nx < R and 0 <= ny < C:  # 새로운 위치가 맵 내부인지 확인
                if forest[nx][ny] == 'D':  # 새로운 위치가 비버의 굴이라면
                    return hedgehog_time[x][y] + 1  # 현재 위치의 시간보다 1 증가된 시간을 반환 (탈출 성공)
                if forest[nx][ny] == '.' and hedgehog_time[nx][ny] == -1:  # 빈 칸이고, 아직 방문하지 않은 곳이라면
                    if water_time[nx][ny] == -1 or water_time[nx][ny] > hedgehog_time[x][y] + 1:
                        # 해당 위치에 물이 도달하지 않았거나, 물이 도달하는 시간보다 고슴도치가 먼저 도달할 수 있는 경우
                        hedgehog_time[nx][ny] = hedgehog_time[x][y] + 1  # 새로운 위치의 고슴도치 이동 시간을 현재 위치의 시간보다 1 증가시킴
                        hedgehog_queue.append((nx, ny))  # 새로운 위치를 고슴도치 큐에 추가
    
    return "KAKTUS"  # 비버의 굴에 도달할 수 없을 경우 "KAKTUS" 반환

R, C = map(int, input().split())  # 맵의 크기 R(행)과 C(열)을 입력받음
forest = [input().strip() for _ in range(R)]  # 맵의 상태를 입력받아 리스트로 저장

print(bfs_escape(R, C, forest))  # 고슴도치 탈출 결과를 출력
