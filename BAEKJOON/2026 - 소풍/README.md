# 소풍 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2026>

<https://mayquartet.com/python-백준-2026-소풍/>

## 문제 이해

이 문제는 학생들의 친구 관계를 기반으로 특정 인원 수만큼 소풍에 데려갈 학생들을 선발하는 문제입니다. 선발된 학생들은 모두 서로 친구 관계에 있어야 하며, 그렇지 않은 경우 소풍을 갈 수 없습니다. 소풍에 데려갈 학생 수는 정해져 있으며, 학생 수와 친구 관계 수는 입력으로 주어집니다.

핵심은 모든 학생이 서로 친구인 상태로 구성된 완전한 부분 집합을 찾는 것입니다. 이러한 부분 집합을 **클릭(Clique)**이라고 합니다. 클릭은 그래프 이론에서 모든 정점이 서로 인접한 부분 그래프를 의미합니다. 문제에서 요구하는 것은 크기가 K인 클릭을 찾는 것입니다.

문제는 단순한 탐색으로는 풀기 어렵습니다. 학생 수가 최대 900명이고 친구 관계는 5600개까지 존재할 수 있기 때문에, 모든 조합을 확인하는 방식으로는 시간 초과가 발생합니다. 따라서 효율적인 탐색 방법인 **백트래킹(Backtracking)**을 사용해 조건을 만족하는 부분 집합을 찾아야 합니다.

이 문제는 그래프 이론과 백트래킹을 결합해 해결하는 전형적인 **조합 최적화 문제**로, 모든 경우의 수를 확인하면서 조건에 맞는 조합을 찾는 방식으로 접근해야 합니다.

## 입출력 조건

입력은 총 두 부분으로 구성됩니다.  
첫 번째 줄에는 세 개의 정수 K, N, F가 공백으로 구분되어 주어집니다.

- K는 소풍에 선발해야 할 학생 수로 1 이상 62 이하입니다.
- N은 전체 학생 수로 1 이상 900 이하입니다.
- F는 친구 관계의 수로 1 이상 5600 이하입니다.

두 번째 줄부터 F개의 줄에 걸쳐 친구 관계가 주어집니다. 각 줄에는 두 개의 정수 A, B가 공백으로 구분되어 주어지며, 이는 A번 학생과 B번 학생이 서로 친구라는 의미입니다. 친구 관계는 양방향으로 작용하므로 A와 B가 친구이면 B와 A도 친구입니다.

출력은 다음과 같이 이루어집니다.

- 만약 조건을 만족하는 K명의 학생을 찾을 수 없는 경우 -1을 출력합니다.
- 조건을 만족하는 경우에는 K명의 학생 번호를 오름차순으로 한 줄에 하나씩 출력합니다.

만약 조건을 만족하는 경우가 여러 개라면, 학생 번호가 가장 작은 조합을 출력해야 합니다. 학생 번호가 같은 경우, 두 번째 학생의 번호가 작은 경우를 출력하는 방식으로 번호가 작은 조합을 우선하여 출력합니다.

## 접근 방식

이 문제는 그래프에서 크기 K인 완전 부분 그래프(클릭)를 찾는 문제로, **백트래킹 알고리즘**을 사용해 해결해야 합니다. 완전 탐색으로는 시간 내에 해결할 수 없기 때문에 백트래킹을 통해 불필요한 탐색을 가지치기(Pruning) 하며 탐색을 진행합니다.

문제를 해결하기 위한 핵심 아이디어는 다음과 같습니다.

1. 그래프를 인접 리스트 형태로 구성하여 친구 관계를 저장합니다.
2. 학생을 하나씩 선택하면서 현재까지 선택된 학생들과 모두 친구 관계인지 확인합니다.
3. 조건을 만족하지 않는 경우 더 이상 탐색을 진행하지 않고 바로 중단합니다.
4. 선택된 학생 수가 K명에 도달하면 결과를 출력하고 프로그램을 종료합니다.
5. 모든 경우를 탐색했음에도 조건을 만족하는 K명의 학생을 찾지 못한 경우 -1을 출력합니다.

백트래킹은 가능한 모든 경우의 수를 탐색하되, 조건을 만족하지 않는 경우에는 해당 경로를 더 이상 탐색하지 않습니다. 이를 통해 탐색 시간을 절약할 수 있습니다.

<https://mayquartet.com/algorithm-알고리즘-backtracking-백트래킹-알고리즘-이해하기/>

## 풀이 과정

문제를 해결하는 과정은 다음과 같은 단계로 이루어집니다.

1. **그래프 데이터 구조 구성**  
   먼저, 학생들의 친구 관계를 저장할 그래프를 인접 리스트 형태로 구성합니다. 각 학생 번호에 해당하는 리스트를 생성하고, 친구 관계가 주어질 때마다 양방향으로 친구를 추가합니다. 이를 통해 그래프가 완성됩니다.

2. **백트래킹 함수 구현**  
   학생을 하나씩 선택해 나가면서 조건을 만족하는 경우에만 탐색을 진행하는 백트래킹 함수를 구현합니다.

   - 학생이 선택되지 않은 경우 1번 학생부터 탐색을 시작합니다.
   - 학생이 이미 선택된 경우, 가장 마지막에 선택된 학생 번호보다 큰 번호부터 탐색합니다.
   - 현재 선택한 학생이 이전에 선택된 모든 학생과 친구 관계에 있는 경우에만 선택을 진행합니다.
   - 선택된 학생 수가 K명에 도달하면 결과를 출력하고 프로그램을 종료합니다.

3. **출력 조건**  
   결과를 출력할 때는 학생 번호를 오름차순으로 정렬하여 출력합니다. 만약 여러 조합이 존재한다면, 사전 순으로 가장 앞서는 조합을 출력해야 합니다.

4. **종료 조건**  
   모든 경우를 탐색했음에도 K명의 학생을 찾지 못했다면 -1을 출력합니다.

5. **시간 복잡도 고려**  
   최대 학생 수가 900명, 친구 관계 수가 5600개로 설정되어 있으므로 완전 탐색으로는 시간이 부족합니다. 백트래킹을 통해 가지치기를 수행하여 탐색 시간을 단축해야 합니다.

## 코드 구현

```python
import sys
input = sys.stdin.read
sys.setrecursionlimit(10000)

def picnic(K, N, F, friendships):
    friends = [set() for _ in range(N + 1)]

    for a, b in friendships:
        friends[a].add(b)
        friends[b].add(a)

    def backtrack(selected):
        if len(selected) == K:
            for s in sorted(selected):
                print(s)
            exit(0)

        start = selected[-1] + 1 if selected else 1

        for i in range(start, N + 1):
            if all(i in friends[s] for s in selected):
                backtrack(selected + [i])

    backtrack([])
    print(-1)

if __name__ == "__main__":
    data = input().splitlines()
    K, N, F = map(int, data[0].split())
    friendships = [tuple(map(int, line.split())) for line in data[1:]]

    picnic(K, N, F, friendships)
```
