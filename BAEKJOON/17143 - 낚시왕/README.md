# 낚시왕 문제 풀이 및 설명

https://www.acmicpc.net/problem/17143

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-17143-%eb%82%9a%ec%8b%9c%ec%99%95-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 낚시왕이 상어를 낚는 과정을 시뮬레이션하는 문제입니다. 주어진 격자판에서 낚시왕이 각 열을 한 칸씩 이동하면서 상어를 잡고, 상어들은 자신들의 속도와 방향에 따라 이동하는 상황을 구현해야 합니다. 상어는 격자판에서 속도에 따라 움직이고, 경계를 넘어가면 방향을 반대로 바꿉니다. 여러 상어가 같은 칸에 도달하게 되면 크기가 가장 큰 상어만 남고 나머지는 사라지게 됩니다. 이 과정에서 낚시왕이 잡은 상어들의 크기 합을 구하는 것이 목표입니다.

주어진 문제를 풀기 위해서는 상어가 이동할 때 경계 처리를 잘 해야 하며, 상어끼리 겹쳤을 때 크기가 큰 상어만 남는 처리를 정확히 해야 합니다. 또한, 낚시왕이 상어를 잡는 로직도 중요합니다. 문제를 시뮬레이션 방식으로 해결해야 하며, 상어들의 이동과 낚시왕의 상어 낚시 과정을 순차적으로 처리하는 것이 핵심입니다.

## 입출력 조건

### 입력 조건:

- 첫 번째 줄에는 격자판의 크기 \( R \times C \)와 상어의 수 \( M \)이 주어집니다.
  - \( 2 \leq R, C \leq 100 \): 격자판의 크기.
  - \( 0 \leq M \leq R \times C \): 상어의 수.
- 두 번째 줄부터는 상어의 정보가 \( M \)줄에 걸쳐 주어집니다.
  - \( r \), \( c \): 상어의 위치 (1-based).
  - \( s \): 상어의 속도 (칸/초).
  - \( d \): 상어의 이동 방향 (1: 위, 2: 아래, 3: 오른쪽, 4: 왼쪽).
  - \( z \): 상어의 크기.
- 입력의 상어는 서로 다른 칸에 놓여 있으며, 하나의 칸에 둘 이상의 상어가 있는 경우는 없습니다.

### 출력 조건:

- 낚시왕이 잡은 상어의 크기의 총합을 출력합니다.

## 접근 방식

이 문제는 전형적인 시뮬레이션 문제입니다. 주어진 조건에 맞게 상어의 이동과 상어를 잡는 과정을 정확히 구현해야 합니다. 문제를 풀기 위해서는 다음과 같은 전략을 사용할 수 있습니다:

1. **상어의 이동 처리**: 상어는 자신이 바라보는 방향에 따라 속도에 맞춰 이동합니다. 만약 상어가 격자의 경계에 도달하면, 그때 방향을 반대로 바꿔야 합니다. 이를 효율적으로 처리하기 위해서는 각 방향에 대해 주기적으로 상어가 되돌아가는 성질을 활용할 수 있습니다.
2. **낚시왕의 이동 및 상어 낚시**: 낚시왕은 1번 열부터 시작해 오른쪽으로 한 칸씩 이동합니다. 매번 자신이 있는 열에서 가장 가까운 상어를 잡아야 하며, 해당 상어는 사라집니다. 상어를 잡는 순서는 가장 가까운 상어(즉, 행의 번호가 작은 상어)부터 처리합니다.

3. **상어가 한 칸에 여러 마리 있는 경우 처리**: 상어가 이동을 마쳤을 때, 같은 칸에 여러 상어가 있을 수 있습니다. 이때는 크기가 가장 큰 상어만 남기고 나머지는 사라지게 해야 합니다. 이 과정은 상어가 이동을 마친 후 각 칸을 확인하면서 처리하면 됩니다.

4. **반복적 시뮬레이션**: 낚시왕이 오른쪽 끝까지 이동할 때까지, 매번 상어를 잡고 상어들이 이동하는 과정을 반복적으로 시뮬레이션해야 합니다.

## 풀이 과정

1. **입력 처리**: 격자의 크기 \( R \times C \)와 상어의 수 \( M \)을 입력받습니다. 이후 각 상어의 위치, 속도, 방향, 크기를 입력받아 저장합니다. 이때 상어의 위치는 1-based로 주어지므로, 이를 0-based로 변환해 저장합니다.

2. **방향 배열 설정**: 상어의 이동 방향은 위, 아래, 오른쪽, 왼쪽 4가지입니다. 각 방향에 따른 이동을 처리하기 위해 상하좌우로 이동하는 배열을 설정합니다. 이를 통해 상어가 이동할 때, 해당 배열을 참조하여 좌표를 업데이트할 수 있도록 합니다.

3. **낚시왕이 상어를 잡는 과정**: 낚시왕이 각 열을 한 칸씩 이동하면서, 해당 열에 있는 가장 가까운 상어를 잡습니다. 상어를 잡으면 그 상어의 크기를 합산하고, 해당 상어는 격자판에서 삭제됩니다.

4. **상어 이동**: 상어는 자신이 가진 속력과 방향에 맞춰 이동합니다. 경계를 넘어갈 경우 방향을 반대로 바꾸는 처리가 필요하며, 상어가 이동을 마친 후에는 같은 칸에 여러 상어가 있을 수 있으므로, 크기가 가장 큰 상어만 남도록 처리합니다. 이때 상어는 이동 중에 경계에 도달하면 방향을 전환하고 다시 이동합니다.

5. **상어가 한 칸에 겹치는 경우 처리**: 이동이 완료된 후 한 칸에 여러 상어가 있을 경우, 크기가 가장 큰 상어만 남기고 나머지 상어는 사라집니다. 이를 위해 새로운 상어 배열에 이동 결과를 저장한 후, 동일한 위치에 있는 상어들을 비교해 가장 큰 상어만 남깁니다.

6. **시뮬레이션 반복**: 낚시왕이 오른쪽 끝까지 이동할 때까지 위의 과정을 반복합니다. 매번 상어를 잡고 상어가 이동한 후 겹치는 상어를 처리하는 과정을 통해 시뮬레이션을 반복 수행합니다.

7. **최종 결과 출력**: 낚시왕이 잡은 상어들의 크기 총합을 출력합니다.

## 문제 제출 시 주의사항

이 문제는 Python3로 제출하면 시간 초과 오류가 발생하므로, Python3 대신 PyPy3로 제출해야 합니다.

## 코드 구현

```python
from collections import defaultdict

# 격자의 크기와 상어의 수를 입력받는다.
R, C, M = map(int, input().split())

# 상어 정보를 저장할 딕셔너리. 키는 (r, c) 좌표, 값은 [속도 s, 방향 d, 크기 z].
sharks = {}
for _ in range(M):
    r, c, s, d, z = map(int, input().split())
    sharks[(r-1, c-1)] = [s, d, z]  # 입력 좌표는 1부터 시작하므로 0-based 좌표로 변경하여 저장

# 상하좌우 이동을 위한 방향 배열 (1: 위, 2: 아래, 3: 오른쪽, 4: 왼쪽)
dr = [-1, 1, 0, 0]  # 행 이동 (위로 -1, 아래로 +1)
dc = [0, 0, 1, -1]  # 열 이동 (오른쪽 +1, 왼쪽 -1)

# 상어가 이동하는 함수
def move_sharks():
    # 새로 이동된 상어의 정보를 저장할 딕셔너리
    new_sharks = defaultdict(list)

    # 모든 상어에 대해 이동을 처리
    for (r, c), (s, d, z) in sharks.items():
        nr, nc, nd = r, c, d  # 현재 상어의 좌표와 방향을 가져옴

        # 상하 이동(1: 위, 2: 아래)일 때
        if d == 1 or d == 2:
            s %= (R - 1) * 2  # 상하 이동은 (R-1) * 2 주기를 가짐 (리밋 없이 계속 이동할 수 없도록 주기 처리)
            for _ in range(s):
                if nr == 0 and d == 1:  # 맨 위쪽에 도달하고 위로 이동할 경우, 아래로 방향 전환
                    d = 2
                elif nr == R-1 and d == 2:  # 맨 아래쪽에 도달하고 아래로 이동할 경우, 위로 방향 전환
                    d = 1
                nr += dr[d-1]  # 새 좌표로 이동

        # 좌우 이동(3: 오른쪽, 4: 왼쪽)일 때
        else:
            s %= (C - 1) * 2  # 좌우 이동은 (C-1) * 2 주기를 가짐
            for _ in range(s):
                if nc == 0 and d == 4:  # 맨 왼쪽에 도달하고 왼쪽으로 이동할 경우, 오른쪽으로 방향 전환
                    d = 3
                elif nc == C-1 and d == 3:  # 맨 오른쪽에 도달하고 오른쪽으로 이동할 경우, 왼쪽으로 방향 전환
                    d = 4
                nc += dc[d-1]  # 새 좌표로 이동

        # 상어가 이동한 후, 같은 위치에 상어가 있을 경우 크기가 큰 상어만 남도록 처리
        if (nr, nc) in new_sharks:
            if new_sharks[(nr, nc)][2] < z:  # 크기가 더 큰 상어가 있으면 기존 상어를 덮어씀
                new_sharks[(nr, nc)] = [s, d, z]
        else:
            new_sharks[(nr, nc)] = [s, d, z]  # 빈 칸이면 새로운 상어 정보를 저장

    return new_sharks  # 이동이 완료된 상어들의 새로운 상태 반환

# 낚시왕이 잡은 상어의 크기를 저장할 변수
total_size = 0

# 낚시왕이 1번 열부터 마지막 열까지 이동하며 상어를 잡는 과정
for king_pos in range(C):
    # 1번 열부터 차례대로 가장 가까운 상어를 잡는 과정
    for row in range(R):
        if (row, king_pos) in sharks:  # 현재 낚시왕이 있는 열에서 가장 가까운 상어를 찾음
            total_size += sharks[(row, king_pos)][2]  # 상어 크기를 합산
            del sharks[(row, king_pos)]  # 상어를 잡았으므로 해당 상어는 삭제
            break  # 한 마리만 잡을 수 있으므로 루프 종료

    # 상어들이 이동하는 과정
    sharks = move_sharks()

# 낚시왕이 잡은 상어 크기의 총합을 출력
print(total_size)
```
