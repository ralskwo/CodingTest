# 토마토 문제 풀이 및 설명

<https://www.acmicpc.net/problem/7569>

<https://mayquartet.com/python-파이썬-백준-7569-토마토/>

## 문제 이해

이 문제는 익은 토마토가 인접한 익지 않은 토마토에 영향을 주어 익게 만드는 과정을 시뮬레이션하고, 모든 토마토가 익는 데 걸리는 최소 일수를 구하는 문제입니다. 이 문제를 해결하기 위해서는 3차원 배열을 이용해 각 칸의 상태를 관리하고, 익은 토마토들이 동시에 인접한 익지 않은 토마토로 익히는 과정을 여러 단계로 진행해야 합니다. 문제를 해결하기 위해 고려해야 할 사항은 다음과 같습니다.

- **토마토의 상태**: 각 칸의 토마토 상태는 다음과 같이 세 가지 값으로 표현됩니다.
  - `1`: 익은 토마토.
  - `0`: 익지 않은 토마토.
  - `-1`: 토마토가 들어있지 않은 빈 칸.
- **토마토의 영향을 받는 인접 칸**: 각 토마토는 상자 안의 인접한 여섯 방향에 있는 토마토만 익게 만들 수 있습니다. 즉, `위`, `아래`, `앞`, `뒤`, `왼쪽`, `오른쪽` 여섯 방향으로만 영향을 줄 수 있으며, 대각선 방향은 영향을 주지 못합니다.

- **목표**: 모든 토마토가 익기까지 최소 며칠이 걸리는지를 구합니다. 만약 모든 토마토가 익을 수 없는 상황이라면 `-1`을 반환해야 하며, 처음부터 모든 토마토가 익어 있다면 `0`을 반환해야 합니다.

## 입출력 조건

- **입력**:

  - 첫 줄에는 `M`(가로 크기), `N`(세로 크기), `H`(쌓여 있는 상자의 층 수)가 주어집니다.
    - `2 ≤ M ≤ 100`: 상자의 가로 칸 수는 최소 2에서 최대 100까지입니다.
    - `2 ≤ N ≤ 100`: 상자의 세로 칸 수는 최소 2에서 최대 100까지입니다.
    - `1 ≤ H ≤ 100`: 상자의 층 수는 최소 1에서 최대 100까지입니다.
  - 다음 줄부터는 각 상자에 담긴 토마토의 상태가 주어집니다.
    - 각 상자는 `N`개의 줄로 표현되며, 각 줄은 `M`개의 정수로 이루어져 있습니다.
    - 정수 `1`은 익은 토마토를, 정수 `0`은 익지 않은 토마토를, 정수 `-1`은 토마토가 들어있지 않은 칸을 나타냅니다.
    - 이러한 `N`개의 줄이 `H`번 반복되므로, 입력 데이터는 총 `N * H`개의 줄로 주어집니다.

- **출력**:
  - 모든 토마토가 익는 데 걸리는 최소 일수를 출력합니다.
  - 처음부터 모든 토마토가 익어 있는 상태라면 `0`을 출력합니다.
  - 만약 토마토가 모두 익을 수 없는 상황이라면 `-1`을 출력합니다.

## 접근 방식

이 문제는 그래프 탐색 알고리즘 중 **너비 우선 탐색(BFS)**을 3차원 배열에 적용하여 해결할 수 있습니다. BFS는 여러 개의 출발점에서 동시에 시작하여 인접한 노드로 탐색을 확장해 나가는 방식으로, 최단 경로를 구하는 데 적합합니다. 이 문제에서 익은 토마토들이 동시에 인접한 토마토를 익히는 과정이 바로 BFS로 표현할 수 있는 상황입니다.

1. **3차원 BFS 탐색 사용**: 상자가 `M` x `N` x `H`의 크기를 가지기 때문에, 3차원 배열로 탐색을 진행해야 합니다. 3차원 BFS를 사용하여 익은 토마토가 있는 모든 위치에서 동시에 출발하여, 인접한 토마토를 익히는 과정을 반복합니다.

2. **큐를 사용한 탐색**: BFS는 `큐(queue)` 자료구조를 사용하여, 현재 익은 토마토의 위치와 일수를 관리합니다. 큐에 `층`, `행`, `열`의 좌표와 경과 일수를 저장하여, 현재 위치에서 6가지 방향으로 인접한 위치를 탐색하고 익지 않은 토마토를 익게 만든 후, 해당 위치를 큐에 추가합니다.

3. **상태 확인 및 종료 조건**: BFS 탐색이 종료된 후, 익지 않은 토마토가 남아 있다면 모든 토마토를 익게 만들 수 없으므로 `-1`을 반환하고, 모든 토마토가 익었다면 그때의 경과된 일수를 반환합니다. 만약 처음부터 모든 토마토가 익어있다면 바로 `0`을 반환합니다.

<https://mayquartet.com/algorithm-bfs-너비-우선-탐색-알고리즘/>

## 풀이 과정

1. **입력 값 처리**:

   - 첫 줄에서 `M`, `N`, `H`를 입력받아 각각 상자의 가로, 세로, 층 수를 저장합니다.
   - `N` x `M`의 2차원 리스트를 `H`번 반복하여, 전체 토마토 상자를 `3차원 리스트(box)`로 저장합니다.
   - 각 토마토의 상태를 읽어들여, 초기 상태에서 익은 토마토의 위치를 큐에 추가하고 전체 토마토의 개수와 익은 토마토의 개수를 세어둡니다.

2. **모든 토마토가 이미 익은 상태인지 확인**:

   - 익은 토마토의 개수와 전체 토마토의 개수가 동일한 경우, 이미 모든 토마토가 익어 있는 상태이므로 `0`을 반환합니다.

3. **BFS를 통한 탐색**:

   - 큐에서 토마토의 위치와 경과 일수를 꺼내어, 6가지 방향(위, 아래, 앞, 뒤, 왼쪽, 오른쪽)으로 인접한 위치를 확인합니다.
   - 인접한 위치가 상자 범위 내에 있고, 익지 않은 토마토(`0`)가 있다면 그 토마토를 익은 상태(`1`)로 변경하고 큐에 추가합니다.
   - 이 과정을 반복하여 모든 익지 않은 토마토가 익을 때까지 BFS 탐색을 진행합니다.

4. **결과 반환**:
   - BFS 탐색이 종료된 후, 전체 상자를 다시 확인하여 익지 않은 토마토가 남아 있는지 확인합니다.
   - 익지 않은 토마토가 있다면 `-1`을 반환하고, 없다면 BFS를 통해 계산된 경과 일수를 반환합니다.

위와 같은 풀이 과정을 통해 모든 토마토가 익기까지 걸리는 최소 일수를 효율적으로 계산할 수 있습니다.

## 코드 구현

```python
from collections import deque  # deque 라이브러리 임포트

def tomato_ripening(M, N, H, box):  # 토마토가 익는 최소 일수를 구하는 함수 정의
    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]  # 위, 아래, 앞, 뒤, 왼쪽, 오른쪽 6방향을 나타내는 리스트
    queue = deque()  # BFS를 위한 큐 정의
    total_tomatoes = 0  # 전체 토마토의 개수를 저장할 변수 초기화
    ripe_tomatoes = 0  # 익은 토마토의 개수를 저장할 변수 초기화

    # 상자의 각 층, 행, 열을 순회하면서 익은 토마토 위치를 큐에 추가하고 전체 토마토와 익은 토마토 개수를 센다
    for h in range(H):  # 층을 순회
        for n in range(N):  # 행을 순회
            for m in range(M):  # 열을 순회
                if box[h][n][m] == 1:  # 현재 위치의 토마토가 익은 상태라면
                    queue.append((h, n, m, 0))  # (층, 행, 열, 현재까지의 일수)를 큐에 추가
                    ripe_tomatoes += 1  # 익은 토마토 개수 증가
                if box[h][n][m] != -1:  # 토마토가 있는 칸이라면 (빈 칸이 아닌 경우)
                    total_tomatoes += 1  # 전체 토마토 개수 증가

    # 처음부터 모든 토마토가 익어있는 상태인 경우
    if ripe_tomatoes == total_tomatoes:  # 익은 토마토 개수와 전체 토마토 개수가 동일하면
        return 0  # 0일이 걸리므로 0 반환

    days = 0  # 최소 일수를 저장할 변수 초기화
    while queue:  # 큐가 빌 때까지 반복
        z, x, y, days = queue.popleft()  # 큐에서 현재 위치와 경과된 일수를 꺼낸다

        # 6방향으로 인접한 위치를 탐색
        for dz, dx, dy in directions:  # 각 방향에 대해 반복
            nz, nx, ny = z + dz, x + dx, y + dy  # 새로운 위치 계산
            # 새로운 위치가 상자 범위 내에 있고, 익지 않은 토마토(0)가 있다면
            if 0 <= nz < H and 0 <= nx < N and 0 <= ny < M and box[nz][nx][ny] == 0:
                box[nz][nx][ny] = 1  # 익은 토마토로 상태 변경
                queue.append((nz, nx, ny, days + 1))  # 큐에 (새로운 위치, 경과된 일수 + 1)을 추가

    # 모든 토마토가 익었는지 확인
    for h in range(H):  # 층을 순회
        for n in range(N):  # 행을 순회
            for m in range(M):  # 열을 순회
                if box[h][n][m] == 0:  # 익지 않은 토마토가 있다면
                    return -1  # 모든 토마토를 익게 만들 수 없으므로 -1 반환

    return days  # 최소 일수 반환

# 입력 처리
M, N, H = map(int, input().split())  # 첫 줄에서 가로 크기, 세로 크기, 높이 입력 받기
box = []  # 토마토 상태를 저장할 3차원 리스트 초기화
for _ in range(H):  # 층의 수만큼 반복
    box.append([list(map(int, input().split())) for _ in range(N)])  # 각 층의 토마토 상태를 입력 받아 추가

# 결과 출력
print(tomato_ripening(M, N, H, box))  # 함수 호출 후 최소 일수를 출력
```
