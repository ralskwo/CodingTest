# 내리막 길 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1520>

<https://mayquartet.com/python-파이썬-백준-1520-내리막-길/>

## 문제 이해

이 문제는 그래프 탐색 문제로, 주어진 지도를 이용하여 경로의 수를 찾는 문제입니다. 문제에서는 여행자 세준이가 항상 내리막길로만 이동하여 시작 지점(지도에서 제일 왼쪽 위)에서 도착 지점(지도에서 제일 오른쪽 아래)까지 가는 경로의 수를 구해야 합니다. 각 지점의 높이가 주어지며, 세준이는 현재 지점보다 높이가 낮은 지점으로만 이동할 수 있습니다. 이러한 이동 조건을 만족하며 목적지까지 도달할 수 있는 모든 경로의 수를 계산해야 합니다.

따라서 문제는 단순한 경로 탐색이 아니라 "내리막길 경로"를 찾아야 한다는 조건이 붙어있습니다. 이 조건 때문에 단순한 BFS 또는 DFS 탐색만으로는 중복된 계산이 발생할 수 있습니다. 이 문제를 효율적으로 풀기 위해서는 다이나믹 프로그래밍(`Dynamic Programming`)을 사용하여 중복 계산을 줄이는 것이 필요합니다.

문제는 세 가지 주요 사항을 염두에 두어야 합니다.

1. **높이가 낮은 지점으로만 이동 가능**:
   세준이는 현재 지점의 높이보다 낮은 지점으로만 이동할 수 있으므로, 지도에서 각 지점마다 상하좌우로 이동 가능한 지점을 찾을 때, 높이 조건을 만족하는지 확인해야 합니다.

2. **중복된 경로 계산 방지**:
   시작 지점에서 출발하여 각 지점을 탐색할 때, 이미 방문한 지점의 경로의 수를 기록하고 중복 계산을 피하기 위해 메모이제이션(`Memoization`) 기법을 사용합니다.

3. **출발 지점에서 도착 지점까지의 경로의 수 계산**:
   `(0, 0)` 지점에서 출발하여 `(M-1, N-1)` 지점까지 도달할 수 있는 모든 경로의 수를 찾아 출력해야 합니다.

## 입출력 조건

1. **입력 조건**:

   - 첫 줄에는 지도의 세로 크기 `M`과 가로 크기 `N`이 주어지며, 이는 각각 `500` 이하의 자연수입니다.
   - 이후 `M`개의 줄에 걸쳐, 각 줄에는 `N`개의 숫자가 빈칸으로 구분되어 입력되며, 이 숫자는 각 지점의 높이를 나타냅니다. 각 지점의 높이는 `10,000` 이하의 자연수입니다.

2. **출력 조건**:
   - 첫째 줄에 세준이가 시작 지점에서 도착 지점까지 도달할 수 있는 경로의 수 `H`를 출력합니다.
   - 모든 입력에 대해 경로의 수 `H`는 `10억 이하의 음이 아닌 정수`로 주어집니다.

## 접근 방식

1. **DFS(깊이 우선 탐색)와 메모이제이션(Memoization) 결합**:

   - 이 문제는 기본적으로 `DFS(깊이 우선 탐색)`를 사용하여 모든 경로를 탐색하면서, 도달 가능한 경로의 수를 계산할 수 있습니다.
   - 그러나 단순한 DFS로는 중복된 경로를 여러 번 계산하여 시간 복잡도가 매우 커질 수 있으므로, 메모이제이션을 결합하여 이미 계산된 경로의 수를 저장하고 재사용해야 합니다.
   - 이를 위해, `dp[y][x]`를 사용하여 `(y, x)` 지점에서 목적지까지 도달할 수 있는 경로의 수를 저장합니다.

2. **상하좌우 네 방향 탐색**:

   - `DFS` 탐색 시 각 지점에서 상하좌우로 이동할 수 있습니다. 단, 이동할 지점의 높이는 현재 지점의 높이보다 낮아야만 이동이 가능합니다.
   - 방향 벡터를 사용하여 상하좌우 네 방향을 탐색하고, 이동 가능한 지점인지 확인한 후 `DFS`를 재귀적으로 호출합니다.

3. **경로 수 누적**:

   - 목적지 `(M-1, N-1)`에 도달하면 `1`을 반환하여 경로의 수를 누적합니다.
   - 그 외의 지점에서는 상하좌우 이동을 반복하여, 이동 가능한 지점의 경로 수를 모두 더해 현재 지점의 경로 수로 설정합니다.

4. **최적화**:
   - 이미 방문한 지점에서 목적지까지의 경로 수가 계산되었으면, 그 값을 반환하여 중복 계산을 방지하고 시간을 절약합니다.

<https://mayquartet.com/algorithm-알고리즘-dfs-깊이-우선-탐색-알고리즘-이해하기/>

## 풀이 과정

1. **입력값 처리 및 초기화**:

   - 입력받은 지도의 크기 `M`, `N`을 저장하고, 각 지점의 높이를 `heights`라는 2차원 리스트에 저장합니다.
   - 방문하지 않은 지점을 나타내기 위해 `dp` 테이블을 `-1`로 초기화합니다.
   - 방향 벡터 `directions`를 정의하여 상하좌우 네 방향으로 이동할 수 있도록 설정합니다.

2. **DFS 함수 구현**:

   - `dfs(x, y)` 함수는 현재 `(x, y)` 지점에서 시작하여 목적지 `(M-1, N-1)`까지 도달할 수 있는 경로의 수를 반환합니다.
   - `(x, y)` 지점이 목적지 `(M-1, N-1)`에 도달하면 `1`을 반환하여 경로의 수를 하나 증가시킵니다.
   - 현재 위치에서 상하좌우 네 방향으로 이동하며, 이동할 수 있는 지점이 현재 지점보다 낮은 높이를 가지고 있는지 확인합니다.
   - 만약 이동할 수 있다면 `dfs`를 재귀적으로 호출하여 다음 지점에서 목적지까지의 경로 수를 계산하고, 해당 값을 `dp[y][x]`에 누적하여 더합니다.

3. **메모이제이션 처리**:

   - `dp[y][x]`가 `-1`이 아니라면, 이미 경로의 수가 계산된 지점이므로 `dp[y][x]` 값을 반환하여 중복 계산을 방지합니다.

4. **결과 출력**:
   - 시작 지점 `(0, 0)`에서 `dfs(0, 0)`을 호출하여 전체 경로의 수를 계산하고, 이를 `result` 변수에 저장합니다.
   - 최종적으로 `result` 값을 출력하여 경로의 수를 확인합니다.

## 코드 구현

```python
import sys
sys.setrecursionlimit(10000)  # 파이썬의 기본 재귀 깊이 제한을 늘려서 깊은 재귀 호출이 가능하게 설정

def dfs(x, y):
    if x == N - 1 and y == M - 1:  # 목적지에 도달했을 때, 경로를 찾았으므로 1 반환
        return 1

    if dp[y][x] != -1:  # 이미 계산된 경로 수가 있으면 해당 값을 반환하여 중복 계산 방지
        return dp[y][x]

    dp[y][x] = 0  # 현재 위치에서 가능한 경로 수를 0으로 초기화

    for dx, dy in directions:  # 상하좌우 네 방향에 대해 이동 가능성 확인
        nx, ny = x + dx, y + dy  # 이동할 새로운 위치 좌표
        if 0 <= nx < N and 0 <= ny < M and heights[ny][nx] < heights[y][x]:  # 지도 범위 내에 있고 현재 위치보다 높이가 낮은 경우
            dp[y][x] += dfs(nx, ny)  # 다음 지점으로 이동하여 경로의 수를 누적하여 더함

    return dp[y][x]  # 계산된 현재 위치의 경로 수를 반환

M, N = map(int, input().split())  # 지도 세로 크기 M과 가로 크기 N 입력받기
heights = [list(map(int, input().split())) for _ in range(M)]  # M줄에 걸쳐 각 지점의 높이를 입력받아 heights 리스트에 저장
dp = [[-1] * N for _ in range(M)]  # dp 테이블을 -1로 초기화하여 방문하지 않은 지점을 표시
directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # 상하좌우 이동을 위한 방향 벡터 설정

result = dfs(0, 0)  # 시작 지점 (0, 0)에서 dfs 호출하여 목적지까지의 경로의 수 계산
print(result)  # 계산된 경로의 수 출력
```
