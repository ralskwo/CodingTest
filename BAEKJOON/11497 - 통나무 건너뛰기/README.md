# 통나무 건너뛰기 문제 풀이 및 설명

<https://www.acmicpc.net/problem/11497>

<https://mayquartet.com/python-백준-11497-통나무-건너뛰기/>

## 문제 이해

이 문제는 주어진 통나무의 높이를 원형으로 배치한 후, 인접한 통나무 간의 높이 차이의 최댓값을 최소화하는 배열을 구성하는 것을 목표로 합니다. 통나무는 원형으로 배치되기 때문에 마지막 통나무와 첫 번째 통나무도 인접하게 됩니다. 따라서, 모든 인접한 통나무들 간의 높이 차이를 계산하고 그 중 최댓값을 최소화하는 방법을 찾아야 합니다. 문제에서 제시된 난이도는 이 최댓값을 의미하며, 주어진 높이 배열을 적절히 재배열하여 난이도를 최소화하는 배열을 구성하는 것이 핵심입니다.

문제를 해결하기 위해 통나무 높이를 재배열하는 규칙을 찾는 것이 중요하며, 이는 통나무의 높이 값들을 효과적으로 배치함으로써 높이 차이를 최소화할 수 있습니다. 최적의 배열을 찾는 과정에서 모든 경우를 시도하는 방법은 비효율적이므로, 정렬과 그리디 알고리즘을 활용해 문제를 해결할 수 있습니다.

## 입출력 조건

### 입력 조건

1. 첫 줄에는 테스트 케이스의 개수를 나타내는 정수 T가 주어집니다.
2. 다음 각 테스트 케이스마다 두 줄로 구성됩니다.
   - 첫 번째 줄에는 통나무의 개수를 나타내는 정수 N이 주어집니다. N은 5 이상 10,000 이하의 값을 가집니다.
   - 두 번째 줄에는 통나무의 높이를 나타내는 정수들이 공백으로 구분되어 주어집니다. 각 높이 값은 1 이상 100,000 이하의 정수입니다.

### 출력 조건

각 테스트 케이스에 대해 한 줄에 하나씩 최소 난이도를 출력합니다. 최소 난이도는 인접한 통나무들 간의 높이 차의 최댓값을 의미하며, 계산된 최솟값을 순서대로 출력합니다.

## 접근 방식

이 문제를 해결하기 위해 다음과 같은 접근 방식을 사용할 수 있습니다.

1. 통나무 높이를 오름차순으로 정렬합니다. 정렬된 배열은 각 높이 값 간의 차이가 최소화된 상태를 제공합니다.
2. 정렬된 높이 값을 번갈아 가며 양쪽 끝부터 배열합니다. 이는 가장 큰 높이 차를 발생시키지 않도록 하기 위한 전략입니다. 예를 들어, 작은 값, 큰 값, 두 번째 작은 값, 두 번째 큰 값의 순으로 배치하면 인접한 높이 값의 차이가 최소화됩니다.
3. 재배치된 배열에서 인접한 값 간의 높이 차이를 계산합니다. 원형 배열이므로 마지막 값과 첫 번째 값 간의 차이도 계산에 포함해야 합니다.
4. 위 과정을 각 테스트 케이스마다 반복하여 결과를 도출합니다.

이 접근 방식은 문제를 효율적으로 해결하기 위해 정렬과 그리디 알고리즘을 사용합니다. 모든 경우를 탐색하지 않고도 최적의 배열을 구성할 수 있습니다.

<https://mayquartet.com/algorithm-알고리즘-greedy-그리디-알고리즘탐욕법-이해하기/>

## 풀이 과정

1. 테스트 케이스 개수 T를 입력받고, 각 테스트 케이스의 통나무 높이 배열을 입력받아 저장합니다.
2. 각 테스트 케이스마다 통나무 높이 배열을 오름차순으로 정렬합니다. 이는 높이 값 간의 차이를 최소화하기 위한 기초 단계입니다.
3. 정렬된 높이를 번갈아 가며 양쪽 끝부터 배열합니다. 짝수 번째 값은 배열의 왼쪽부터, 홀수 번째 값은 배열의 오른쪽부터 채워넣습니다. 이렇게 하면 높이 차가 큰 값들이 직접적으로 인접하지 않게 됩니다.
4. 재배치된 배열에서 인접한 값 간의 높이 차이를 계산합니다. 원형 배열이므로 마지막 값과 첫 번째 값 간의 차이도 포함하여 높이 차의 최댓값을 구합니다.
5. 구한 높이 차의 최댓값을 최소 난이도로 간주하고 결과 리스트에 저장합니다.
6. 모든 테스트 케이스에 대해 위 과정을 반복한 뒤, 결과 리스트에 저장된 값을 순서대로 출력합니다.

이 과정을 통해 효율적으로 문제를 해결할 수 있으며, 정렬과 재배치 과정에서 시간 복잡도는 테스트 케이스 당 O(N log N)으로 제한됩니다. 이는 문제의 입력 조건을 충분히 처리할 수 있는 성능을 제공합니다.

## 코드 구현

```python
def min_difficulty(t_cases):
    # 결과를 저장할 리스트 생성
    results = []
    for case in t_cases:
        # 각 테스트 케이스의 통나무 개수와 높이 배열을 가져옴
        N, heights = case
        # 통나무 높이를 오름차순으로 정렬
        heights.sort()

        # 통나무를 재배치할 배열 초기화
        arranged = [0] * N
        # 배열의 양 끝을 가리키는 포인터 초기화
        left, right = 0, N - 1

        # 정렬된 높이를 번갈아 배열에 배치
        for i, height in enumerate(heights):
            if i % 2 == 0:
                arranged[left] = height  # 왼쪽에 작은 값 배치
                left += 1
            else:
                arranged[right] = height  # 오른쪽에 큰 값 배치
                right -= 1

        # 난이도의 최댓값 계산
        max_diff = 0
        for i in range(N):
            # 현재 통나무와 다음 통나무 간의 높이 차 계산
            max_diff = max(max_diff, abs(arranged[i] - arranged[(i + 1) % N]))

        # 계산된 난이도를 결과 리스트에 추가
        results.append(max_diff)
    return results


# 테스트 케이스 개수 입력 받음
T = int(input())
# 각 테스트 케이스를 저장할 리스트
t_cases = []
for _ in range(T):
    # 통나무 개수와 높이를 입력 받음
    N = int(input())
    heights = list(map(int, input().split()))
    t_cases.append((N, heights))

# 각 테스트 케이스의 최소 난이도를 계산
results = min_difficulty(t_cases)
for result in results:
    # 결과를 한 줄씩 출력
    print(result)
```
