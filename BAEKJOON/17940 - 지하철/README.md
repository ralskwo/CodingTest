# 지하철 문제 풀이 및 설명

<https://www.acmicpc.net/problem/17940>

<https://mayquartet.com/python-파이썬-17940-지하철/>

## 문제 이해

이 문제는 출발지에서 도착지까지 이동할 때, 지하철 환승 횟수를 최소화하면서 이동 시간을 최소화하는 최적의 경로를 찾는 것입니다. 각 지하철역은 두 개의 회사, 즉 `A`와 `B`가 운영하는데, 경쟁 관계에 있는 두 회사 간의 환승 시에는 추가 요금이 발생하므로 환승 횟수를 줄이는 것이 매우 중요합니다. 이 문제에서 환승은 출발 회사와 도착 회사가 다를 때 발생하며, 환승 횟수를 줄이는 것이 우선이지만, 환승 횟수가 같을 경우 총 이동 시간을 최소화하는 경로를 선택해야 합니다.

또한 문제는 지하철역 수와 각 역을 운영하는 회사 정보, 그리고 역 간의 연결 상태와 이동 시간을 제공합니다. 출발지는 항상 역 `0`이고, 주어진 도착지까지 연결이 보장되므로 모든 역이 연결된 상태입니다.

## 입출력 조건

- **입력**

  - 첫 번째 줄에는 `지하철역의 수`인 `N`과 `도착지 역 번호` `M`이 공백으로 구분되어 주어집니다.
  - 두 번째 줄부터는 각 지하철역을 운영하는 회사 정보 `C_i`가 주어집니다. `C_i` 값은 `0` 또는 `1`로 나타내며, `0`은 `A`회사를, `1`은 `B`회사를 뜻합니다.
  - 그 다음에는 `N`개의 줄이 이어지며, 각 줄에는 지하철역 간의 연결 상태 `E_ij`가 주어집니다. `E_ij` 값이 `0`보다 크면 `i`번째 역과 `j`번째 역이 연결되어 있으며 이동 시간이 `E_ij`임을 의미합니다. `E_ij`가 `0`이면 두 역이 연결되어 있지 않음을 나타냅니다.

- **출력**
  - 환승 횟수와 총 소요 시간을 공백으로 구분하여 출력합니다. 환승 횟수를 우선 최소화하고, 환승 횟수가 같을 경우 총 이동 시간이 최소가 되는 값을 출력합니다.

## 접근 방식

이 문제는 `다익스트라 알고리즘`을 확장하여 해결할 수 있습니다. 기본적으로 다익스트라 알고리즘은 최단 경로를 찾는 알고리즘으로, 이 문제에서는 `환승 횟수`와 `이동 시간`이라는 두 가지 조건을 동시에 고려해야 하므로 다중 상태를 관리하는 방식으로 다익스트라를 적용해야 합니다. 이 문제를 해결하기 위한 접근 방식은 다음과 같습니다.

1. **그래프 모델링**: 각 지하철역을 `노드`로, 지하철역 간의 연결 상태를 `엣지`로 나타냅니다. 각 노드는 해당 역을 운영하는 회사 정보(`0` 또는 `1`)와 연결된 이동 시간을 포함하는 형태로 설정됩니다.

2. **다중 상태 관리**: 각 노드의 상태는 운영 회사에 따라 달라지므로, `환승 횟수`와 `이동 시간`을 회사 상태에 따라 각각 관리합니다. 이를 위해 각 노드의 상태는 `[A 회사 상태, B 회사 상태]`로 구분하여 저장합니다.

3. **우선순위 큐 사용**: 다익스트라 알고리즘처럼 우선순위 큐를 활용해 `환승 횟수`와 `이동 시간`을 기준으로 최적 경로를 탐색합니다. 큐에는 `(환승 횟수, 이동 시간, 현재 위치, 회사)` 형태의 정보를 넣어 관리합니다.

4. **최적 경로 선택**: 도착지에 도달하는 여러 경로 중에서 환승 횟수가 최소인 경로를 선택하고, 환승 횟수가 동일하다면 이동 시간이 가장 짧은 경로를 최종 결과로 선택합니다.

<https://mayquartet.com/algorithm-dijkstra-다익스트라-알고리즘-이해하기/>

## 풀이 과정

1. **입력 파싱 및 초기화**

   - `N`과 `M`을 입력 받아 지하철역의 수와 도착지를 설정합니다.
   - 각 지하철역의 소속 회사 정보를 `companies` 리스트에 저장합니다. `0`은 `A`회사를, `1`은 `B`회사를 의미합니다.
   - `N x N` 크기의 인접 행렬 `adj_matrix`를 통해 각 역 간의 연결 상태와 이동 시간을 저장합니다. 이 행렬에서 `E_ij`가 `0`인 경우 연결되지 않은 상태를 나타내므로, 해당 값은 무시됩니다.

2. **거리 배열 및 우선순위 큐 초기화**

   - `dist` 배열을 통해 각 역에 대해 `[A 회사 상태, B 회사 상태]`로 나누어 `(환승 횟수, 이동 시간)` 정보를 저장합니다. 초기에는 모든 값을 `(INF, INF)`로 설정하여 무한대 값을 통해 초기 상태를 표시합니다.
   - `dist[0][companies[0]]` 값을 `(0, 0)`으로 초기화하여 출발지의 환승 횟수와 이동 시간을 `0`으로 설정합니다.
   - `heapq`를 이용해 우선순위 큐 `pq`를 초기화하고, 출발지의 `(환승 횟수, 이동 시간, 현재 위치, 회사)` 정보를 `(0, 0, 0, companies[0])` 형태로 추가합니다.

3. **다익스트라 알고리즘 확장**

   - 우선순위 큐에서 `pq`가 빌 때까지 반복하여 최적 경로를 탐색합니다. 각 반복에서 현재 노드의 `(환승 횟수, 이동 시간, 역 번호, 회사)` 정보를 꺼내고, 이미 더 좋은 경로로 방문된 경우라면 건너뜁니다.
   - 현재 노드에서 이동할 수 있는 모든 역을 확인하여, 해당 역으로 이동할 때의 `이동 시간`과 `회사` 정보를 가져옵니다. 이때 회사가 다르다면 환승이 발생하므로, 환승 횟수를 증가시키고 이동 시간을 누적하여 다음 경로로 설정합니다.
   - 각 경로가 `dist` 배열에 저장된 값보다 더 나은 값이라면, `dist` 배열을 업데이트하고 우선순위 큐에 추가하여 탐색을 이어나갑니다.

4. **최적 경로 선택 및 출력**
   - 도착지 `M`에서의 최소 환승 횟수와 최소 이동 시간을 `dist[M]`에서 확인합니다.
   - `min(dist[M], key=lambda x: (x[0], x[1]))`을 통해 환승 횟수가 최소이고, 환승 횟수가 동일한 경우 이동 시간이 최소인 값을 선택합니다.
   - 선택된 결과의 `환승 횟수`와 `이동 시간`을 출력합니다.

이와 같은 방식으로 `환승 횟수와 이동 시간`을 모두 고려하여 최적 경로를 탐색할 수 있습니다.

## 코드 구현

```python
import heapq
import sys

input = sys.stdin.read  # 전체 입력을 받아오는 함수로 설정
INF = float('inf')  # 무한대를 나타내기 위한 상수

def main():
    data = input().splitlines()  # 입력 데이터를 줄 단위로 분리하여 리스트로 저장
    first_line = data[0].split()  # 첫 줄에서 역의 수와 도착지 번호를 분리
    N = int(first_line[0])  # 지하철역의 수
    M = int(first_line[1])  # 도착지의 역 번호

    companies = list(map(int, data[1:N+1]))  # 각 역의 소속 회사 정보를 리스트로 변환
    adj_matrix = [list(map(int, line.split())) for line in data[N+1:2*N+1]]  # 역 간 연결 정보를 인접 행렬로 저장

    dist = [[(INF, INF) for _ in range(2)] for _ in range(N)]  # 최소 환승 횟수와 이동 시간을 저장할 배열, 각 역에 대해 A/B 두 가지 상태로 초기화
    dist[0][companies[0]] = (0, 0)  # 출발지에서 출발 회사의 환승과 시간 값을 0으로 설정

    pq = []  # 다익스트라 알고리즘에 사용할 우선순위 큐를 초기화
    heapq.heappush(pq, (0, 0, 0, companies[0]))  # 출발 역을 우선순위 큐에 추가, (환승, 시간, 역 번호, 회사) 형태로 저장

    while pq:  # 우선순위 큐가 빌 때까지 반복
        transfers, time, node, curr_company = heapq.heappop(pq)  # 우선순위 큐에서 가장 작은 값을 꺼냄

        # 이미 더 좋은 경로가 있는 경우 현재 경로는 무시
        if (transfers, time) > dist[node][curr_company]:
            continue

        # 현재 역에서 이동 가능한 모든 역을 확인
        for next_node in range(N):
            travel_time = adj_matrix[node][next_node]  # 현재 역에서 다음 역까지의 이동 시간
            if travel_time == 0:
                continue  # 연결되지 않은 경우 스킵

            next_company = companies[next_node]  # 다음 역의 소속 회사
            new_transfers = transfers + (1 if curr_company != next_company else 0)  # 회사가 다른 경우 환승 횟수를 증가
            new_time = time + travel_time  # 이동 시간을 추가

            # 다음 역으로 가는 새로운 경로가 기존보다 나은 경우 업데이트
            if (new_transfers, new_time) < dist[next_node][next_company]:
                dist[next_node][next_company] = (new_transfers, new_time)  # 최소 환승과 시간으로 업데이트
                heapq.heappush(pq, (new_transfers, new_time, next_node, next_company))  # 업데이트된 경로를 우선순위 큐에 추가

    result = min(dist[M], key=lambda x: (x[0], x[1]))  # 도착지에서 최소 환승과 최소 시간을 찾음
    print(result[0], result[1])  # 환승 횟수와 총 소요 시간을 출력

if __name__ == "__main__":
    main()  # main 함수를 호출하여 프로그램 실행
```
