# 타임머신 문제 풀이 및 설명

<https://www.acmicpc.net/problem/11657>

<https://mayquartet.com/python-백준-11657-타임머신/>

## 문제 이해

이 문제는 그래프 이론을 기반으로 하여 특정 시작 도시에서 다른 도시들로의 최단 시간을 계산하는 문제입니다. 도시 간 이동 시간은 양수, 0(순간 이동), 또는 음수(타임머신)일 수 있습니다. 특히, 음수 가중치가 포함된 경우, 음수 사이클(일정 경로를 반복적으로 지나면서 시간이 무한히 감소하는 상황)이 발생할 수 있는지를 판단해야 합니다. 음수 사이클이 존재한다면, 특정 도시로의 최단 경로가 무의미해지므로 이를 감지하고 `-1`을 출력해야 합니다.

이 문제에서 주요 관점은 다음과 같습니다.

1. 시작 도시에서 모든 도시로 이동 가능한 최단 시간을 계산해야 합니다.
2. 음수 사이클이 있는지 확인해야 합니다.
3. 도달할 수 없는 도시는 최단 시간을 `-1`로 표시해야 합니다.

따라서 이 문제는 단순히 최단 경로를 계산하는 것을 넘어 음수 사이클까지 처리해야 하므로, 알고리즘 설계 시 이에 주의해야 합니다.

## 입출력 조건

### 입력 조건

1. 첫째 줄에 도시의 개수 `N`(1 ≤ N ≤ 500)과 버스 노선의 개수 `M`(1 ≤ M ≤ 6,000)이 주어집니다.
2. 둘째 줄부터 `M`개의 줄에 걸쳐 각각의 버스 노선 정보가 주어집니다.
   - `A`, `B`, `C`로 주어지며, 이는 시작 도시 `A`, 도착 도시 `B`, 이동 시간 `C`를 의미합니다.
   - `1 ≤ A, B ≤ N`
   - `-10,000 ≤ C ≤ 10,000`
3. 시작 도시는 항상 1번 도시입니다.

### 출력 조건

1. 음수 사이클이 존재할 경우 첫 줄에 `-1`을 출력합니다.
2. 그렇지 않은 경우, 1번 도시에서 2번 도시, 3번 도시, ..., N번 도시로 가는 최단 시간을 각각 한 줄에 출력합니다.
3. 도달할 수 없는 도시는 `-1`을 출력합니다.

## 접근 방식

이 문제는 음수 가중치를 포함한 그래프에서의 최단 경로를 다루므로, 최적의 알고리즘으로 **벨만-포드 알고리즘**을 선택해야 합니다.

1. **벨만-포드 알고리즘 특징**:

   - 다익스트라 알고리즘과 달리, 음수 가중치가 있는 그래프에서도 동작합니다.
   - 간선을 최대 \(N-1\)번 순회하며 최단 거리를 갱신합니다.
   - 추가로 \(N\)번째 순회에서 갱신이 발생하면 음수 사이클이 존재한다고 판단할 수 있습니다.

2. **알고리즘 동작**:

   - 시작 도시에서 각 도시까지의 최단 거리를 `INF`로 초기화합니다.
   - 시작 도시의 거리는 `0`으로 설정합니다.
   - 각 간선을 반복적으로 확인하면서 최단 거리 정보를 갱신합니다.
   - 모든 도시를 \(N-1\)번 순회한 후, 음수 사이클을 탐지하기 위해 한 번 더 순회합니다.

3. **문제 해결 목표**:
   - 최단 거리 계산 결과를 출력합니다.
   - 음수 사이클이 감지되면 `-1`을 출력합니다.
   - 특정 도시에 도달할 수 없는 경우에도 `-1`을 출력합니다.

## 풀이 과정

1. **초기화**:

   - 도시의 개수 \(N\)과 간선 정보를 입력받습니다.
   - 모든 도시의 최단 거리를 `INF`로 초기화하며, 시작 도시(1번 도시)의 거리는 `0`으로 설정합니다.
   - 간선 정보는 리스트에 저장합니다.

2. **벨만-포드 알고리즘 수행**:

   - 모든 도시를 최대 \(N-1\)번 순회하며 간선 정보를 이용해 최단 거리를 갱신합니다.
   - 갱신 조건은 다음과 같습니다:
     - 현재 도시의 거리가 `INF`가 아니고, 현재 도시를 통해 다른 도시로 이동하는 거리가 기존 거리보다 짧을 경우 최단 거리를 갱신합니다.
   - \(N-1\)번 순회 후, 한 번 더 순회하여 최단 거리가 갱신된다면 음수 사이클이 존재한다고 판단합니다.

3. **결과 출력**:

   - 음수 사이클이 존재할 경우 `-1`을 출력하고 종료합니다.
   - 음수 사이클이 없을 경우, 2번 도시부터 \(N\)번 도시까지의 최단 거리를 출력합니다.
   - 도달할 수 없는 도시의 거리는 `-1`로 출력합니다.

4. **특이 케이스 처리**:
   - 도시가 1개인 경우 추가 작업 없이 종료합니다.
   - 음수 사이클이 발생하지 않아도 특정 도시로 가는 경로가 존재하지 않을 수 있습니다. 이 경우에도 `-1`을 출력합니다.

## 코드 구현

```python
import sys
from collections import defaultdict

# 벨만-포드 알고리즘 구현 함수
def bellman_ford(n, edges, start):
    INF = float('inf')  # 무한대를 나타내는 상수 설정
    distance = [INF] * (n + 1)  # 모든 도시의 최단 거리를 무한대로 초기화
    distance[start] = 0  # 시작 도시의 거리를 0으로 설정

    # 모든 도시를 최대 n-1번 순회하며 거리 갱신
    for i in range(n):
        for u, v, cost in edges:  # 각 간선을 확인
            if distance[u] != INF and distance[u] + cost < distance[v]:
                distance[v] = distance[u] + cost  # 최단 거리 갱신
                if i == n - 1:  # n번째 순회에서 갱신이 발생하면 음수 사이클 존재
                    return -1

    return distance  # 모든 도시로의 최단 거리 배열 반환

# 메인 함수
def main():
    input = sys.stdin.read  # 표준 입력 읽기
    data = input().splitlines()  # 입력 데이터를 줄 단위로 나누기

    n, m = map(int, data[0].split())  # 도시 개수 n과 버스 노선 개수 m 읽기
    edges = []  # 간선 정보를 저장할 리스트

    for i in range(1, m + 1):  # 각 버스 노선의 정보를 읽어들임
        a, b, c = map(int, data[i].split())  # 시작 도시 a, 도착 도시 b, 비용 c
        edges.append((a, b, c))  # 간선 정보를 리스트에 추가

    result = bellman_ford(n, edges, 1)  # 1번 도시에서 출발하여 최단 거리 계산

    if result == -1:  # 음수 사이클이 존재하는 경우
        print(-1)  # -1 출력
    else:
        for dist in result[2:]:  # 2번 도시부터 n번 도시까지 최단 거리 확인
            if dist == float('inf'):  # 도달할 수 없는 경우
                print(-1)  # -1 출력
            else:
                print(dist)  # 최단 거리 출력

# 프로그램의 시작점
if __name__ == "__main__":
    main()
```
