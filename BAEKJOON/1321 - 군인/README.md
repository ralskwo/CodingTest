# 군인 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1321>

<https://mayquartet.com/python-파이썬-백준-1321-군인/>

## 문제 이해

이 문제는 전쟁 중 여러 개의 부대가 각자 군사 수를 관리하는 상황에서, 시간이 지나면서 부대의 군사 수가 증가하거나 감소할 수 있음을 고려해야 합니다. 문제의 목표는 이러한 변화가 주어졌을 때, 특정 군번의 군인이 어느 부대에 속해 있는지를 빠르게 찾아내는 것입니다. 문제의 핵심은 다음과 같습니다:

1. **부대별로 군인의 숫자가 주어지며, 이 숫자는 변동될 수 있습니다.**

   - 각 부대에는 초기 군사 수가 주어지고, 군번은 1번 부대부터 순차적으로 배정됩니다.
   - 예를 들어, 1번 부대에 4명, 2번 부대에 3명, 3번 부대에 7명의 군인이 있다면, 6번 군인은 2번 부대에 배치됩니다.

2. **주어지는 명령에 따라 부대의 군사 수가 변경될 수 있으며, 이러한 변경이 있을 때마다 군번의 위치를 찾아야 합니다.**

   - 명령은 두 가지 형태로 주어집니다:
     - `1 i a`: `i`번 부대에 `a`명을 증원하거나 감원하는 명령입니다.
     - `2 i`: `i`번 군번의 군인이 어느 부대에 속해 있는지를 출력하는 명령입니다.

3. **군번의 위치를 효율적으로 찾아야 합니다.**
   - 부대별로 군사 수가 변경될 때마다 순차적으로 군번을 확인하는 것은 비효율적입니다.
   - 이 문제를 해결하려면 효율적인 자료구조를 사용하여 군번이 어느 부대에 속하는지 빠르게 찾아야 합니다.

## 입출력 조건

1. **입력 조건**

   - 첫 번째 줄에는 부대의 개수 `N`이 주어집니다. (`1 ≤ N ≤ 500,000`)
   - 두 번째 줄에는 각 부대에 속한 군인의 수가 `N`개 정수로 주어집니다. 각 부대의 군사 수는 최대 `1000`명입니다.
   - 세 번째 줄에는 명령의 개수 `M`이 주어집니다. (`1 ≤ M ≤ 10,000`)
   - 이후 `M`개의 줄에는 명령이 주어집니다. 명령은 다음 두 가지 형태 중 하나로 주어집니다:
     - `1 i a`: `i`번 부대에 `a`명을 증원하거나 감원합니다. (`1 ≤ i ≤ N`, `-3000 ≤ a ≤ 3000`)
     - `2 i`: `i`번 군번의 군인이 어느 부대에 속해 있는지를 묻습니다. (`1 ≤ i ≤ 전체 군인 수`)
   - 각 명령은 개행 문자(`\n`)를 기준으로 구분됩니다.

2. **출력 조건**
   - 각 `2 i` 명령에 대해서 `i`번 군번의 군인이 속한 부대 번호를 출력합니다.
   - 결과는 한 줄에 하나씩 출력합니다.

## 접근 방식

1. **효율적인 자료구조 사용: 세그먼트 트리 (Segment Tree)**

   - 각 부대의 군사 수는 변동될 수 있으므로, 배열이나 단순 누적합으로는 효율적으로 문제를 해결할 수 없습니다.
   - 세그먼트 트리를 사용하여 각 부대의 군사 수를 관리하면, 특정 부대의 군사 수를 빠르게 갱신할 수 있고, 특정 군번이 어느 부대에 속해 있는지를 빠르게 찾을 수 있습니다.
   - 세그먼트 트리의 루트 노드는 전체 부대의 군사 수를 나타내며, 각 노드는 특정 구간의 군사 수를 합으로 갖습니다.

2. **세그먼트 트리를 통한 문제 해결 방식**

   - `1 i a` 명령에 대해:
     - 세그먼트 트리의 특정 위치에 값을 더하거나 뺍니다.
     - 특정 부대의 군사 수가 변경될 때마다 해당 부대를 포함한 모든 구간의 합을 갱신해야 하므로, 세그먼트 트리의 값을 업데이트하는 과정이 필요합니다.
   - `2 i` 명령에 대해:
     - 주어진 군번 `i`가 어느 부대에 속해 있는지 빠르게 찾기 위해, 세그먼트 트리의 구간 합을 활용하여 이진 탐색을 수행합니다.
     - 루트 노드에서 시작하여, 각 자식 노드의 군사 수를 이용해 군번 `i`가 어느 구간에 속하는지를 찾아나갑니다.

3. **시간 복잡도 분석**
   - 각 명령은 `O(log N)`의 시간 복잡도로 처리할 수 있습니다.
   - `1 i a` 명령은 세그먼트 트리의 값을 변경하는 것이므로 `O(log N)`의 시간 복잡도를 가집니다.
   - `2 i` 명령은 세그먼트 트리를 통해 군번의 위치를 찾는 것이므로 `O(log N)`의 시간 복잡도를 가집니다.
   - 전체 시간 복잡도는 `O(M log N)`으로, `N`이 최대 500,000, `M`이 최대 10,000이므로 충분히 빠르게 동작합니다.

<https://mayquartet.com/algorithm-세그먼트-트리segment-tree-알고리즘-이해하기/>

## 풀이 과정

1. **세그먼트 트리 초기화**

   - 입력받은 부대의 개수 `N`을 기준으로 세그먼트 트리를 초기화합니다.
   - 초기 배열을 세그먼트 트리의 리프 노드에 배치하고, 각 부모 노드를 자식 노드들의 합으로 초기화합니다.

2. **`1 i a` 명령 처리**

   - `i`번 부대의 군사 수를 `a`만큼 증감시킵니다.
   - 세그먼트 트리에서 `i-1` 위치에 해당하는 리프 노드를 찾아 `a`만큼 값을 더하거나 빼줍니다.
   - 이후 부모 노드로 거슬러 올라가며 모든 노드의 값을 갱신합니다.
   - 이 과정은 트리의 높이에 해당하는 `O(log N)` 시간 내에 완료됩니다.

3. **`2 i` 명령 처리**

   - `i`번 군번이 속한 부대를 찾기 위해, 세그먼트 트리의 루트 노드에서 시작하여 자식 노드로 내려갑니다.
   - 현재 노드의 왼쪽 자식 노드의 군사 수와 비교하여 `i`번 군번이 어느 자식 노드에 속해 있는지를 결정합니다.
   - 만약 `i`번 군번이 왼쪽 자식 노드의 군사 수보다 작거나 같으면 왼쪽으로 이동하고, 그렇지 않으면 `i`번 군번에서 왼쪽 자식 노드의 군사 수를 빼고 오른쪽 자식 노드로 이동합니다.
   - 리프 노드에 도달할 때까지 이 과정을 반복하며, 최종적으로 `i`번 군번이 속한 부대 번호를 계산하여 반환합니다.

4. **출력 처리**
   - `2 i` 명령으로 찾은 부대 번호를 차례대로 출력합니다.
   - 각 결과는 한 줄에 하나씩 출력됩니다.

## 코드 구현

```python
import sys
input = sys.stdin.readline

# 세그먼트 트리(SegmentTree) 클래스 정의
class SegmentTree:
    def __init__(self, n):  # 세그먼트 트리의 초기화 메서드
        self.size = 1  # 초기 사이즈를 1로 설정
        # 주어진 n보다 크거나 같은 가장 가까운 2의 제곱수 찾기
        while self.size < n:
            self.size *= 2  # 사이즈를 2배씩 늘림
        # 트리 배열을 0으로 초기화. 트리의 크기는 2 * self.size
        self.tree = [0] * (2 * self.size)

    # 초기 배열을 세그먼트 트리에 빌드하는 함수
    def build(self, arr):
        # 입력 배열을 세그먼트 트리의 리프 노드에 삽입
        for i in range(len(arr)):
            self.tree[self.size + i] = arr[i]
        # 리프 노드 이후의 모든 부모 노드들을 자식 노드들의 합으로 초기화
        for i in range(self.size - 1, 0, -1):
            self.tree[i] = self.tree[2*i] + self.tree[2*i+1]

    # 특정 인덱스의 값을 변경하는 함수
    def update(self, index, value):
        # 인덱스를 트리의 리프 노드 위치로 이동
        index += self.size
        # 리프 노드의 값을 value만큼 더함
        self.tree[index] += value
        # 부모 노드로 거슬러 올라가면서 값을 갱신
        while index > 1:
            index //= 2  # 부모 노드로 이동
            # 부모 노드는 두 자식 노드의 합으로 설정
            self.tree[index] = self.tree[2*index] + self.tree[2*index+1]

    # 특정 군번이 속한 부대를 찾는 함수
    def query(self, soldier):
        # soldier가 전체 군인의 수를 초과할 경우 -1을 반환
        if soldier > self.tree[1]:
            return -1
        index = 1  # 루트 노드에서 탐색 시작
        # 리프 노드에 도달할 때까지 반복
        while index < self.size:
            # 왼쪽 자식 노드의 값이 soldier보다 크거나 같으면 왼쪽으로 이동
            if soldier <= self.tree[2*index]:
                index = 2*index
            # 그렇지 않으면 오른쪽으로 이동하고, soldier 값을 왼쪽 자식의 값만큼 감소
            else:
                soldier -= self.tree[2*index]
                index = 2*index + 1
        # index는 리프 노드의 위치이므로, 이를 부대 번호로 변환하여 반환
        return index - self.size + 1

# 입력: 부대의 개수 n
n = int(input())

# 입력: 각 부대의 군사 수
soldiers = list(map(int, input().split()))

# 세그먼트 트리 생성 및 초기화
seg_tree = SegmentTree(n)
seg_tree.build(soldiers)

# 입력: 명령의 개수 m
m = int(input())

# m개의 명령을 처리
for _ in range(m):
    # 각 명령을 입력받음
    query = list(map(int, input().split()))

    # "1 i a" 형태의 명령: i번 부대에 a명 증감
    if query[0] == 1:
        seg_tree.update(query[1]-1, query[2])  # 부대 번호를 0-based index로 변환하여 업데이트

    # "2 i" 형태의 명령: i번 군번이 속한 부대 찾기
    else:
        print(seg_tree.query(query[1]))  # i번 군번이 속한 부대를 출력
```
