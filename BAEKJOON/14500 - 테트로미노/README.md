# 테트로미노 문제 풀이 및 설명

https://www.acmicpc.net/problem/14500

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-14500-%ed%85%8c%ed%8a%b8%eb%a1%9c%eb%af%b8%eb%85%b8-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 N x M 크기의 종이 위에 테트로미노 하나를 놓아서, 그 테트로미노가 차지하는 칸에 적힌 수들의 합을 최대화하는 것을 목표로 한다. 테트로미노는 크기가 1x1인 정사각형 4개를 변끼리 연결하여 만든 도형으로, 회전과 대칭이 가능하다. 따라서 총 5가지 기본 모양에 대해 회전 및 대칭을 포함한 19가지 모양을 고려해야 한다. 테트로미노를 종이 위에 놓았을 때 그 위치에 적혀 있는 수들의 합을 계산하고, 이 합의 최댓값을 찾는 것이 목표다. 종이의 각 칸에는 최대 1,000 이하의 자연수가 주어지며, 이러한 제한을 고려하여 문제를 해결해야 한다.

## 입출력 조건

입력은 다음과 같은 형식으로 주어진다:

1. 첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 공백으로 구분되어 주어진다. (4 ≤ N, M ≤ 500)
2. 둘째 줄부터 N개의 줄에 종이에 적힌 수가 공백으로 구분되어 주어진다. 이 수들은 각 칸에 적혀 있으며, 1,000 이하의 자연수이다.

출력은 다음과 같다:

- 테트로미노가 놓인 칸에 적힌 수들의 합 중 최댓값을 출력한다.

## 접근 방식

이 문제는 테트로미노의 모양을 종이 위에 모든 가능한 위치에 놓아보면서 최대 합을 찾아야 한다. 하지만 테트로미노의 모양은 회전과 대칭을 포함해 총 19가지로 다양하기 때문에 모든 경우를 하나씩 고려해야 한다. 이 문제를 풀기 위해 다음과 같은 알고리즘과 방식을 사용한다:

1. **DFS(깊이 우선 탐색)**를 사용하여 네 칸을 탐색하면서 테트로미노의 모양을 찾아 나간다. 이때 방문한 칸을 기록하여 중복 방문을 방지하고, 최대 합을 갱신한다. 이 방식으로 대부분의 테트로미노 모양을 탐색할 수 있다.
2. 하지만 DFS로는 'ㅗ' 모양의 테트로미노를 표현할 수 없기 때문에, 'ㅗ' 모양은 따로 처리한다. 이 모양은 중심을 기준으로 상하좌우에 3개의 칸이 배치되는 형태이므로, 각각의 칸을 중심으로 하여 상하좌우 중 3개의 칸을 더하여 최대 합을 계산한다.
3. 모든 칸을 테트로미노의 시작점으로 하여 가능한 모든 배치에 대해 합을 계산하고 그중 최대값을 찾는다.

## 풀이 과정

1. **초기화 및 입력 처리**:

   - N과 M을 입력받아 종이의 크기를 정하고, 각 칸에 쓰인 수를 2차원 리스트로 저장한다.
   - 테트로미노가 움직일 수 있는 네 방향(상, 하, 좌, 우)을 리스트로 정의한다.
   - 테트로미노를 놓았을 때 최대 합을 저장할 변수를 0으로 초기화한다.

2. **DFS를 이용한 테트로미노 모양 탐색**:

   - 모든 칸을 시작점으로 하여 DFS를 수행한다. 각 칸을 테트로미노의 첫 칸으로 지정하고, 최대 네 칸까지 이동하며 테트로미노 모양을 탐색한다.
   - DFS의 깊이가 4가 되면 테트로미노의 한 모양이 완성된 것이므로 그 합을 계산하여 최대값을 갱신한다.
   - 각 이동마다 경계 조건을 확인하여 종이의 범위를 벗어나지 않도록 한다.
   - 방문한 칸을 기록하고, 탐색이 끝나면 다시 방문 표시를 해제하여 다음 탐색에 영향을 주지 않도록 한다.

3. **'ㅗ' 모양 테트로미노 처리**:

   - DFS로는 'ㅗ' 모양의 테트로미노를 만들 수 없으므로, 이 모양은 따로 처리한다.
   - 각 칸을 중심으로 상하좌우 4방향 중 3방향을 선택하여 'ㅗ', 'ㅜ', 'ㅓ', 'ㅏ' 모양을 구성한다.
   - 각 칸에 대해 가능한 'ㅗ' 모양의 합을 계산하고, 최대값을 갱신한다.
   - 경계 조건을 확인하여 종이의 범위를 벗어나지 않는 경우에만 합을 계산한다.

4. **최대 합 계산 및 출력**:
   - 모든 칸을 시작점으로 하여 DFS를 수행하고, 'ㅗ' 모양을 확인하면서 최대 합을 찾는다.
   - 최종적으로 구한 최대 합을 출력한다.

## 코드 구현

```python
# 종이의 세로 크기 N과 가로 크기 M을 입력받음
N, M = map(int, input().split())

# 종이에 쓰여 있는 수를 2차원 리스트로 입력받음
paper = [list(map(int, input().split())) for _ in range(N)]

# 테트로미노의 이동 방향을 나타내는 리스트 (상, 하, 좌, 우)
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

# 테트로미노를 놓았을 때의 최대 합을 저장할 변수
max_sum = 0

# DFS를 사용하여 가능한 모든 테트로미노 모양을 탐색하는 함수
def dfs(x, y, depth, total):
    global max_sum
    # 깊이가 4가 되면 테트로미노가 완성된 것이므로 최대 합을 갱신
    if depth == 4:
        max_sum = max(max_sum, total)
        return

    # 4방향으로 이동하며 테트로미노의 다음 칸을 탐색
    for dx, dy in directions:
        nx, ny = x + dx, y + dy
        # 종이의 경계 안에 있고 아직 방문하지 않은 칸이라면
        if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny]:
            # 해당 칸을 방문 표시하고 DFS로 재귀 호출
            visited[nx][ny] = True
            dfs(nx, ny, depth + 1, total + paper[nx][ny])
            # 탐색이 끝나면 방문 표시를 해제하여 다음 탐색에 영향을 주지 않도록 함
            visited[nx][ny] = False

# 'ㅗ' 모양 테트로미노를 처리하는 함수
def check_special_shape(x, y):
    global max_sum
    # 'ㅗ' 모양은 각 칸을 중심으로 상하좌우 4방향 중 3방향을 선택하여 모양을 만듦
    for i in range(4):
        total = paper[x][y]
        # 3개의 방향을 선택하여 'ㅗ' 모양을 만듦
        for j in range(3):
            # (i + j) % 4를 통해 순환하며 3방향 선택
            k = (i + j) % 4
            nx = x + directions[k][0]
            ny = y + directions[k][1]
            # 선택한 방향이 종이의 경계를 벗어나면 현재 모양은 무시
            if not (0 <= nx < N and 0 <= ny < M):
                break
            total += paper[nx][ny]
        else:
            # 'ㅗ' 모양이 완성되면 최대 합을 갱신
            max_sum = max(max_sum, total)

# 각 칸을 테트로미노의 시작점으로 설정하여 가능한 모든 테트로미노 모양을 탐색
visited = [[False] * M for _ in range(N)]
for i in range(N):
    for j in range(M):
        # 현재 칸을 방문 표시하고 DFS를 시작
        visited[i][j] = True
        dfs(i, j, 1, paper[i][j])
        # DFS 탐색이 끝나면 방문 표시를 해제
        visited[i][j] = False

        # 'ㅗ' 모양은 DFS로 처리할 수 없으므로 따로 처리
        check_special_shape(i, j)

# 최종적으로 찾은 테트로미노의 최대 합을 출력
print(max_sum)
```
