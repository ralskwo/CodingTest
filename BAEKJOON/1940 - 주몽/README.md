# 주몽 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1940>

<https://mayquartet.com/python-파이썬-백준-1940-주몽-문제-풀이-및-설명/>

## 문제 이해

이 문제는 주어진 재료 리스트에서 두 개의 재료를 선택하여 그 합이 특정 값 `M`이 되는 경우를 찾아내는 문제입니다. 각 재료는 고유한 번호를 가지고 있으며, 이 고유 번호는 자연수입니다. 두 개의 재료를 선택할 때, 그들의 번호를 더해서 `M`이 될 수 있다면 그 재료로 갑옷을 만들 수 있습니다. 즉, 문제에서 요구하는 것은 주어진 재료 리스트에서 두 숫자의 합이 `M`이 되는 쌍이 몇 개나 있는지를 구하는 것입니다.

따라서 이 문제는 다음과 같은 두 가지 중요한 요소를 파악해야 합니다.

- 두 재료의 합이 정확히 `M`이어야 갑옷을 만들 수 있음.
- 재료 리스트 내에서 몇 쌍의 재료가 이 조건을 만족하는지 계산해야 함.

## 입출력 조건

### 입력 조건

1. 첫 번째 줄에 재료의 개수 `N`이 주어집니다. 여기서 `N`은 1 이상 15,000 이하의 정수입니다.
2. 두 번째 줄에는 두 재료의 합으로 만들어야 하는 값 `M`이 주어집니다. `M`은 1 이상 10,000,000 이하의 정수입니다.
3. 세 번째 줄에는 `N`개의 재료들의 고유 번호가 공백으로 구분되어 주어집니다. 각 고유 번호는 100,000 이하의 자연수입니다.

### 출력 조건

- 갑옷을 만들 수 있는 경우의 수를 첫 번째 줄에 출력합니다.

## 접근 방식

이 문제는 두 숫자의 합이 특정 값이 되는 경우를 찾는 문제입니다. 주어진 문제의 조건에서 효율적인 알고리즘을 사용하지 않으면, `N`의 범위가 최대 15,000이기 때문에 시간 복잡도가 높은 방법으로 풀 경우 시간이 많이 소요될 수 있습니다. 특히, 단순히 모든 쌍을 확인하는 방법(브루트 포스 방식)은 `O(N^2)`의 시간 복잡도를 가지므로 비효율적입니다.

효율적으로 풀기 위해 **투 포인터(Two Pointer) 알고리즘**을 사용하는 것이 적합합니다. 투 포인터는 정렬된 리스트에서 두 포인터를 이용하여 합이 `M`이 되는 두 숫자를 찾는 방식입니다. 이 방법은 리스트를 정렬한 후, 리스트의 처음과 끝에서 출발하는 두 개의 포인터를 사용하여 진행합니다. 이 방식은 `O(N \log N)`의 시간 복잡도로 문제를 해결할 수 있어 매우 효율적입니다.

## 풀이 과정

1. **재료 리스트 정렬**: 먼저 재료 리스트를 오름차순으로 정렬합니다. 이 과정은 `O(N \log N)`의 시간 복잡도를 가집니다. 정렬을 하는 이유는 두 포인터를 활용해 재료의 합을 효율적으로 계산하기 위해서입니다.

2. **투 포인터 설정**: 정렬된 리스트에서 두 개의 포인터를 설정합니다. 하나는 리스트의 첫 번째 요소를 가리키는 `left` 포인터이고, 다른 하나는 리스트의 마지막 요소를 가리키는 `right` 포인터입니다. 이 두 포인터는 리스트의 양 끝에서 시작하여 서로를 향해 이동하면서 두 값의 합을 확인합니다.

3. **두 포인터를 사용한 합 계산**:

   - `left` 포인터가 가리키는 값과 `right` 포인터가 가리키는 값을 더해 그 합을 계산합니다.
   - 이 합이 `M`과 같다면, 갑옷을 만들 수 있는 한 쌍을 찾은 것이므로 카운트를 1 증가시키고, 두 포인터를 각각 이동시킵니다.
   - 만약 두 값의 합이 `M`보다 작다면, 더 큰 합을 만들기 위해 `left` 포인터를 오른쪽으로 이동시킵니다.
   - 두 값의 합이 `M`보다 크다면, 더 작은 합을 만들기 위해 `right` 포인터를 왼쪽으로 이동시킵니다.

4. **반복**: `left` 포인터가 `right` 포인터를 넘지 않을 때까지 위의 과정을 반복합니다. 즉, 두 포인터가 겹치지 않는 한 계속해서 가능한 모든 쌍을 검사합니다.

5. **결과 출력**: 모든 쌍에 대해 탐색을 완료하면, 갑옷을 만들 수 있는 경우의 수를 출력합니다.

이 방식은 투 포인터를 사용하므로 한 번의 탐색으로 모든 가능성을 확인할 수 있습니다. 최악의 경우 시간 복잡도는 리스트를 정렬하는 데 `O(N \log N)`, 리스트를 탐색하는 데 `O(N)`이 걸리므로 전체 시간 복잡도는 `O(N \log N)`입니다. 이는 충분히 효율적이어서 주어진 범위의 입력을 처리할 수 있습니다.

## 코드 구현

```python
def count_armors(N, M, materials):
    # 재료들의 고유 번호 리스트를 오름차순으로 정렬
    materials.sort()

    # 왼쪽 포인터는 0, 오른쪽 포인터는 리스트의 마지막 인덱스로 설정
    left = 0
    right = N - 1
    count = 0  # 갑옷을 만들 수 있는 경우의 수를 셀 변수

    # 두 포인터가 겹치지 않을 때까지 반복
    while left < right:
        # 현재 왼쪽 포인터와 오른쪽 포인터가 가리키는 값의 합을 계산
        sum_value = materials[left] + materials[right]

        # 두 재료의 합이 M과 같을 경우
        if sum_value == M:
            count += 1  # 갑옷을 만들 수 있는 경우이므로 카운트를 증가
            left += 1   # 왼쪽 포인터를 오른쪽으로 한 칸 이동
            right -= 1  # 오른쪽 포인터를 왼쪽으로 한 칸 이동
        # 두 재료의 합이 M보다 작을 경우
        elif sum_value < M:
            left += 1   # 합을 키우기 위해 왼쪽 포인터를 오른쪽으로 이동
        # 두 재료의 합이 M보다 클 경우
        else:
            right -= 1  # 합을 줄이기 위해 오른쪽 포인터를 왼쪽으로 이동

    # 갑옷을 만들 수 있는 경우의 수를 반환
    return count

# 첫 번째 줄에서 재료의 개수 입력 받기
N = int(input())

# 두 번째 줄에서 갑옷을 만들기 위한 합 M 입력 받기
M = int(input())

# 세 번째 줄에서 재료들의 고유 번호 리스트 입력 받기
materials = list(map(int, input().split()))

# 갑옷을 만들 수 있는 경우의 수를 출력
print(count_armors(N, M, materials))
```
