# 단절선 문제 풀이 및 설명

<https://www.acmicpc.net/problem/11400>

<https://mayquartet.com/python-백준-11400-단절선/>

# 단절선 찾기 문제 풀이

## 문제 이해

주어진 문제는 그래프에서 특정 간선을 제거했을 때 그래프가 분리되는 간선, 즉 **단절선(Bridge)**을 찾는 것입니다. 단절선은 해당 간선을 제거했을 때 그래프의 연결 요소(connected component)의 개수가 증가하는 간선을 의미합니다.

이 문제는 다음과 같은 특성을 가지고 있습니다:

1. 입력 그래프는 항상 연결되어 있습니다. 즉, 그래프의 모든 정점은 간선을 통해 서로 도달 가능합니다.
2. 그래프는 양방향 그래프입니다. 따라서 간선 정보는 서로 대칭적입니다.
3. 모든 간선이 서로 다른 노드 간에 연결되어 있으며, 동일한 간선이 두 번 이상 주어지지 않습니다.

단절선을 찾기 위해서는 그래프에서 각 간선을 제거했을 때의 연결성을 평가해야 합니다. 이 문제는 단순히 간선을 하나씩 제거하고 연결성을 검사하는 브루트포스 방식으로 해결하기 어렵습니다. 따라서, 효율적인 탐색 방법인 **깊이 우선 탐색(DFS)**과 **Low-Link 값** 개념을 활용하여 문제를 해결해야 합니다.

## 입출력 조건

### 입력 조건

1. 첫 번째 줄에 두 정수 `V`와 `E`가 주어집니다.
   - `V`: 그래프의 정점 개수 (1 ≤ V ≤ 100,000)
   - `E`: 그래프의 간선 개수 (1 ≤ E ≤ 1,000,000)
2. 다음 `E`개의 줄에는 간선 정보가 주어집니다.
   - 각 간선은 두 정수 `A`와 `B`로 주어지며, 이는 정점 `A`와 정점 `B`가 연결되었음을 의미합니다.
   - `1 ≤ A, B ≤ V`이며, A ≠ B입니다.
3. 같은 간선이 두 번 이상 주어지지 않으며, 자기 자신과 연결된 간선도 주어지지 않습니다.

### 출력 조건

1. 첫 번째 줄에 단절선의 개수 `K`를 출력합니다.
2. 다음 `K`개의 줄에는 각 단절선을 출력합니다.
   - 단절선은 "A B" 형식으로 출력하며, 항상 `A < B`를 만족해야 합니다.
   - 단절선은 사전순으로 정렬된 상태로 출력합니다.

## 접근 방식

단절선을 찾는 데에는 **Tarjan 알고리즘**을 사용하는 것이 효과적입니다. 이 알고리즘은 DFS를 활용하여 노드의 방문 순서와 Low-Link 값을 계산하고, 이를 통해 단절선을 효율적으로 판별합니다.

Tarjan 알고리즘을 사용하여 문제를 해결하는 주요 접근 방식은 다음과 같습니다:

1. **DFS와 방문 순서 기록**:
   - 그래프를 DFS 방식으로 탐색하며, 각 노드의 방문 순서를 기록합니다.
   - 방문 순서는 그래프 탐색에서 노드를 처음 방문하는 순간에 부여되는 고유한 값입니다.
2. **Low-Link 값 계산**:
   - Low-Link 값은 특정 노드에서 시작했을 때 도달할 수 있는 가장 낮은 방문 순서를 의미합니다.
   - 이 값은 DFS 트리를 따라가거나 이미 방문한 노드로 되돌아가는 간선을 통해 계산됩니다.
3. **단절선 판별**:
   - DFS 탐색 중 특정 간선 `(u, v)`에 대해 `low[v] > dfs_num[u]` 조건을 만족한다면, 간선 `(u, v)`는 단절선입니다.
   - 이는 노드 `v`가 노드 `u`를 통해서만 상위 노드에 도달할 수 있음을 나타냅니다.
4. **정렬과 출력 형식 조정**:
   - 단절선 결과를 정렬하여 `A < B` 조건을 만족하도록 출력합니다.

이 알고리즘은 DFS 기반으로 작동하므로 시간 복잡도는 \(O(V + E)\)입니다. 따라서 이 문제의 입력 조건에서도 효율적으로 작동합니다.

<https://mayquartet.com/algorithm-알고리즘-dfs-깊이-우선-탐색-알고리즘-이해하기/>

## 풀이 과정

1. **그래프 구성**:

   - 간선 정보를 읽어와 그래프를 인접 리스트로 저장합니다. 이는 DFS 탐색에 효율적이며, 입력 조건에서 노드 번호는 1부터 시작하므로 크기가 `V + 1`인 리스트를 생성합니다.

2. **DFS 및 Low-Link 값 계산**:

   - DFS를 통해 각 노드를 탐색하며 방문 순서를 기록합니다. 방문 순서는 `dfs_num` 배열에 저장되며, 초기값은 -1로 설정하여 방문 여부를 확인합니다.
   - 각 노드의 Low-Link 값은 `low` 배열에 저장됩니다. 이는 해당 노드가 도달할 수 있는 가장 낮은 방문 순서를 나타냅니다.
   - DFS 과정에서 이웃 노드를 탐색하며 다음과 같은 과정을 수행합니다:
     - 이웃 노드가 아직 방문되지 않았다면 DFS를 재귀적으로 호출합니다.
     - 재귀 호출 이후, 현재 노드의 Low-Link 값을 이웃 노드의 Low-Link 값과 비교하여 갱신합니다.
     - 이웃 노드의 Low-Link 값이 현재 노드의 방문 순서보다 크다면, 이 간선은 단절선임을 확인합니다.
   - 이미 방문된 이웃 노드라면, Low-Link 값을 현재 노드의 방문 순서와 비교하여 갱신합니다.

3. **단절선 저장**:

   - 단절선을 발견할 때마다 이를 리스트에 저장합니다. 저장할 때 `A < B` 조건을 만족하도록 작은 번호를 앞에 배치합니다.

4. **결과 정렬 및 출력**:
   - 단절선 리스트를 정렬하여 사전순으로 배치합니다.
   - 단절선 개수와 각 단절선을 출력 형식에 맞게 출력합니다.

이 과정을 통해 효율적으로 문제를 해결할 수 있습니다. DFS와 Low-Link 값 계산은 간선과 노드 개수의 합만큼 탐색을 수행하며, 추가적인 정렬은 \(O(K \log K)\)에 수행됩니다.

## 코드 구현

```python
from collections import defaultdict  # defaultdict를 사용해 그래프를 인접 리스트로 표현
import sys  # 재귀 한도를 설정하기 위해 sys 모듈을 사용

sys.setrecursionlimit(10**6)  # 재귀 한도를 100만으로 설정


def find_bridges(V, edges):
    graph = defaultdict(list)  # 그래프를 저장할 인접 리스트 생성
    for a, b in edges:  # 주어진 간선 정보를 그래프에 추가
        graph[a].append(b)
        graph[b].append(a)

    dfs_num = [-1] * (V + 1)  # 각 노드의 방문 순서를 저장하는 리스트
    low = [-1] * (V + 1)  # 각 노드의 최소 도달 순서를 저장하는 리스트
    bridges = []  # 단절선을 저장할 리스트
    timer = [0]  # DFS 탐색 순서를 저장할 타이머 변수

    def dfs(curr, parent):
        dfs_num[curr] = low[curr] = timer[
            0
        ]  # 현재 노드의 방문 순서와 low 값을 타이머로 초기화
        timer[0] += 1  # 타이머를 증가

        for neighbor in graph[curr]:  # 현재 노드와 연결된 모든 이웃 노드 탐색
            if neighbor == parent:  # 부모 노드로 되돌아가는 간선은 무시
                continue
            if dfs_num[neighbor] == -1:  # 이웃 노드가 아직 방문되지 않은 경우
                dfs(neighbor, curr)  # 이웃 노드로 DFS 탐색
                low[curr] = min(low[curr], low[neighbor])  # low 값을 업데이트

                if low[neighbor] > dfs_num[curr]:  # 단절선 조건을 만족하는 경우
                    bridges.append(
                        (min(curr, neighbor), max(curr, neighbor))
                    )  # 단절선을 리스트에 추가
            else:  # 이미 방문한 이웃 노드라면
                low[curr] = min(low[curr], dfs_num[neighbor])  # low 값을 업데이트

    for i in range(1, V + 1):  # 모든 노드에 대해 DFS 탐색 수행
        if dfs_num[i] == -1:  # 아직 방문되지 않은 노드에서만 탐색 시작
            dfs(i, -1)  # -1은 부모 노드가 없음을 의미

    bridges.sort()  # 단절선을 사전순으로 정렬
    return bridges  # 정렬된 단절선 리스트 반환


input = sys.stdin.read  # 표준 입력을 읽어들임
data = input().splitlines()  # 입력 데이터를 줄 단위로 분리

V, E = map(int, data[0].split())  # 첫 번째 줄에서 노드와 간선의 개수를 추출
edges = [
    tuple(map(int, line.split())) for line in data[1:]
]  # 간선 정보를 리스트로 저장

bridges = find_bridges(V, edges)  # 단절선을 찾는 함수 호출

print(len(bridges))  # 단절선의 개수 출력
for u, v in bridges:  # 단절선을 하나씩 출력
    print(u, v)
```
