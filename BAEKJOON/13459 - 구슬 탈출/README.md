# 구슬 탈출 문제 풀이 및 설명

<https://www.acmicpc.net/problem/13459>

<https://mayquartet.com/python-백준-13459-구슬-탈출/>

## 문제 이해

이 문제는 빨간 구슬과 파란 구슬이 있는 보드에서 빨간 구슬만 구멍에 빠뜨리는 게임을 시뮬레이션하는 문제입니다.  
목표는 주어진 보드에서 빨간 구슬을 10번 이내로 기울여 구멍에 빠뜨리면서, 파란 구슬은 빠뜨리지 않는 것입니다.  
빨간 구슬이 구멍에 빠지고 파란 구슬은 빠지지 않은 상태가 성공 조건입니다.  
만약 파란 구슬이 구멍에 빠지면 실패로 간주됩니다.  
빨간 구슬과 파란 구슬은 동시에 같은 칸에 있을 수 없으며, 하나의 구슬이 다른 구슬 뒤에 놓이는 방식으로 조정됩니다.

이 문제는 구슬이 중력에 의해 움직이는 물리적 게임을 프로그래밍 방식으로 구현하는 것이므로, 상태를 지속적으로 업데이트하고 각 경우의 수를 모두 탐색해야 합니다.  
구슬이 이동하는 도중 벽이나 장애물에 부딪힐 때까지 계속 이동해야 하며, 동시에 두 구슬이 움직인다는 점에서 이를 제대로 시뮬레이션하는 것이 핵심입니다.

## 입출력 조건

입력 조건은 보드의 크기와 상태에 대한 정보를 포함합니다.

첫 줄에는 보드의 세로 길이와 가로 길이를 나타내는 두 개의 정수 N, M이 주어집니다.

- N은 보드의 세로 크기
- M은 가로 크기
- N과 M은 각각 3 이상 10 이하의 값을 가집니다.

다음 N개의 줄에는 보드의 상태가 길이 M의 문자열로 주어집니다.  
이 문자열은 다섯 가지 문자로 구성됩니다.

- `.` : 빈 칸을 의미합니다. 구슬이 이동할 수 있는 위치입니다.
- `#` : 벽이나 장애물을 의미합니다. 구슬이 이동할 수 없는 위치입니다.
- `O` : 구멍을 의미하며, 구슬이 빠질 수 있는 위치입니다.
- `R` : 빨간 구슬의 초기 위치를 나타냅니다.
- `B` : 파란 구슬의 초기 위치를 나타냅니다.

보드의 가장자리는 항상 벽으로 막혀 있으며, 구멍은 하나만 존재합니다.  
빨간 구슬과 파란 구슬도 각각 하나씩 주어집니다.

출력 조건은 다음과 같습니다.

- 빨간 구슬이 파란 구슬을 구멍에 빠뜨리지 않고 10번 이내로 구멍에 빠질 수 있으면 1을 출력합니다.
- 불가능하면 0을 출력합니다.

## 접근 방식

이 문제는 상태 탐색 및 시뮬레이션을 기반으로 하는 전형적인 BFS(너비 우선 탐색) 문제로 접근해야 합니다.

먼저 빨간 구슬과 파란 구슬을 동시에 이동시켜 가능한 모든 경우의 수를 탐색해야 합니다.  
BFS는 이러한 상태 탐색 문제에서 매우 유용합니다.  
큐를 사용해 상태를 관리하며, 각 상태에서 네 방향(상, 하, 좌, 우)으로 구슬을 기울이는 동작을 수행합니다.

구슬이 움직일 때, 구슬은 벽이나 장애물을 만날 때까지 계속 이동해야 합니다.  
만약 빨간 구슬이 구멍에 빠지면 성공으로 간주하고, 파란 구슬이 구멍에 빠지면 실패로 간주합니다.  
빨간 구슬과 파란 구슬이 같은 위치에 도달하는 경우, 이동 거리(몇 칸을 이동했는지)를 비교해 뒤따라온 구슬을 한 칸 뒤로 이동시켜야 합니다.

최대 10번의 이동 기회를 제공하며, 10번을 초과할 경우 실패로 처리해야 합니다.  
BFS 탐색 과정에서 각 상태를 방문 여부로 관리해 이미 방문한 상태를 다시 방문하지 않도록 해야 합니다.  
이를 통해 중복된 상태를 방지하고 탐색 속도를 높일 수 있습니다.

<https://mayquartet.com/algorithm-bfs-너비-우선-탐색-알고리즘/>

## 풀이 과정

1. 보드의 상태를 입력받고, 빨간 구슬과 파란 구슬의 초기 위치를 찾아 저장합니다.

   - 초기 상태에서 빨간 구슬과 파란 구슬의 위치, 그리고 횟수(기울인 횟수)를 큐에 저장해 BFS 탐색을 시작합니다.

2. BFS 탐색을 수행하며 큐에서 상태를 하나씩 꺼내 네 방향으로 구슬을 기울입니다.

   - 빨간 구슬과 파란 구슬을 각각 이동시키며, 구슬이 벽에 부딪히거나 구멍에 빠질 때까지 계속 이동합니다.

3. 빨간 구슬이 구멍에 빠진 경우 바로 성공으로 간주하고 1을 반환합니다.

   - 파란 구슬이 구멍에 빠진 경우 실패로 간주하고 해당 상태는 무시합니다.

4. 두 구슬이 동시에 같은 위치에 도달한 경우, 이동 거리를 비교해 더 많이 이동한 구슬을 한 칸 뒤로 이동시켜 같은 칸에 존재하지 않도록 조정합니다.

5. 이동이 완료된 새로운 상태가 이전에 방문한 적 없는 상태라면 큐에 추가하고 탐색을 이어갑니다.

   - 상태는 빨간 구슬의 위치, 파란 구슬의 위치, 그리고 이동 횟수를 기준으로 저장됩니다.

6. 만약 10번 이내에 빨간 구슬을 구멍에 빠뜨리지 못했다면 0을 반환합니다.

   - 10번 이상 기울이는 경우는 실패로 처리되며, 0을 반환합니다.

7. 최종적으로 빨간 구슬이 구멍에 빠지는 경우에만 1을 반환하고, 모든 경우를 탐색했음에도 성공하지 못하면 0을 반환합니다.
   - BFS 알고리즘은 모든 경우의 수를 빠짐없이 탐색하는 방식이므로, 최적의 해를 찾는 데 적합합니다.

## 코드 구현

```python
from collections import deque

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def move(x, y, dx, dy, board):
    count = 0
    while board[x + dx][y + dy] != '#' and board[x][y] != 'O':
        x += dx
        y += dy
        count += 1
    return x, y, count

def bfs(board, rx, ry, bx, by):
    queue = deque()
    queue.append((rx, ry, bx, by, 0))
    visited = set()
    visited.add((rx, ry, bx, by))

    while queue:
        rx, ry, bx, by, depth = queue.popleft()

        if depth >= 10:
            return 0

        for i in range(4):
            nrx, nry, rcnt = move(rx, ry, dx[i], dy[i], board)
            nbx, nby, bcnt = move(bx, by, dx[i], dy[i], board)

            if board[nbx][nby] == 'O':
                continue
            if board[nrx][nry] == 'O':
                return 1

            if nrx == nbx and nry == nby:
                if rcnt > bcnt:
                    nrx -= dx[i]
                    nry -= dy[i]
                else:
                    nbx -= dx[i]
                    nby -= dy[i]

            if (nrx, nry, nbx, nby) not in visited:
                visited.add((nrx, nry, nbx, nby))
                queue.append((nrx, nry, nbx, nby, depth + 1))

    return 0

def solve(board):
    N = len(board)
    M = len(board[0])
    rx = ry = bx = by = 0

    for i in range(N):
        for j in range(M):
            if board[i][j] == 'R':
                rx, ry = i, j
            if board[i][j] == 'B':
                bx, by = i, j

    return bfs(board, rx, ry, bx, by)

if __name__ == "__main__":
    N, M = map(int, input().split())
    board = [list(input().strip()) for _ in range(N)]
    print(solve(board))
```
