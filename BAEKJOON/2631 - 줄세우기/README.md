# 줄세우기 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2631>

<https://mayquartet.com/python-백준-2631-줄세우기/>

## 문제 이해

이 문제는 주어진 숫자 배열(아이들의 번호)을 최소한의 움직임으로 번호 순서대로 정렬하는 방법을 찾는 문제입니다. 여기서 움직임은 배열의 특정 요소를 다른 위치로 이동시키는 것을 의미합니다. 정렬된 상태란 배열이 1부터 N까지 오름차순으로 배치된 상태를 뜻합니다. 이 문제는 숫자를 단순히 정렬하는 것이 아니라, 최소한의 이동만으로 정렬 상태를 만드는 방법을 찾아야 한다는 점에서 독특합니다. 따라서 최적의 방법을 찾는 것이 중요합니다.

문제를 푸는 핵심은 배열에서 이미 정렬된 상태를 이루는 부분 배열(즉, 최장 증가 부분 수열)을 찾아, 이 부분을 유지하고 나머지 요소만 움직이는 것입니다. 이렇게 하면 움직임의 최소 횟수를 계산할 수 있습니다.

## 입출력 조건

### 입력 조건

- 첫 번째 줄에 아이들의 수를 나타내는 정수 N이 주어집니다. N은 2 이상 200 이하입니다.
- 두 번째 줄부터 N개의 줄에 1부터 N까지의 정수가 한 줄에 하나씩 주어집니다. 이 숫자들은 임의의 순서로 배열되어 있습니다.

### 출력 조건

- 번호를 순서대로 정렬하기 위해 이동해야 하는 아이들의 최소 수를 한 줄에 출력합니다.

## 접근 방식

이 문제는 최장 증가 부분 수열(LIS, Longest Increasing Subsequence)을 계산하여 해결할 수 있습니다. LIS란 주어진 배열에서 원소들이 증가하는 순서대로 선택될 수 있는 가장 긴 부분 배열을 말합니다. LIS를 찾으면 다음과 같은 논리가 성립합니다:

1. LIS에 속한 원소는 이미 정렬된 상태에 있으므로 이동할 필요가 없습니다.
2. LIS에 속하지 않은 원소만 이동시키면 되므로, 최소 이동 횟수는 전체 아이들의 수(N)에서 LIS의 길이를 뺀 값이 됩니다.

LIS를 계산하는 가장 효율적인 방법은 이진 탐색을 활용하여 O(N log N)의 시간 복잡도로 구현하는 것입니다. 이를 위해 `bisect` 모듈을 사용할 수 있습니다.

<https://mayquartet.com/algorithm-lis-longest-increasing-subsequence/>

## 풀이 과정

1. 먼저 아이들의 수와 각 아이의 번호를 입력받아 리스트로 저장합니다.
2. LIS를 계산하기 위한 빈 리스트를 초기화합니다.
3. 입력받은 숫자를 순회하며 다음 과정을 수행합니다:
   - 현재 숫자가 LIS 리스트에 들어갈 위치를 찾습니다. 이를 위해 이진 탐색을 활용합니다.
   - 만약 찾은 위치가 LIS 리스트의 끝이라면, 현재 숫자를 LIS 리스트에 추가합니다.
   - 그렇지 않으면 LIS 리스트의 해당 위치 값을 현재 숫자로 업데이트하여 LIS 조건을 유지합니다.
4. 모든 숫자를 처리한 후, LIS 리스트의 길이를 구합니다. 이 길이는 정렬 상태를 유지하는 데 필요한 최소한의 아이들의 수를 나타냅니다.
5. 전체 아이들의 수(N)에서 LIS 길이를 뺀 값을 계산하여 이동해야 하는 최소 아이들의 수를 구합니다.
6. 마지막으로 결과를 출력합니다.

## 코드 구현

```python
import bisect  # bisect 모듈을 불러옵니다. 이진 탐색을 활용해 LIS를 계산할 때 사용됩니다.

# 입력 받기
n = int(input())  # 첫 번째 줄에서 아이들의 수 N을 입력받습니다.
children = [int(input()) for _ in range(n)]  # 두 번째 줄부터 N개의 숫자를 리스트에 저장합니다.

# LIS 계산
lis = []  # LIS를 저장할 리스트를 초기화합니다.
for num in children:  # 모든 아이들의 번호를 순회합니다.
    pos = bisect.bisect_left(lis, num)  # 현재 번호가 LIS 리스트에 삽입될 위치를 찾습니다.
    if pos == len(lis):  # 위치가 LIS 리스트의 끝이라면
        lis.append(num)  # 현재 번호를 LIS 리스트에 추가합니다.
    else:  # 그렇지 않다면
        lis[pos] = num  # 기존 값을 현재 번호로 업데이트하여 LIS 리스트를 유지합니다.

# 움직여야 하는 최소 아이들의 수 계산
min_moves = n - len(lis)  # 전체 아이들의 수에서 LIS 길이를 빼서 이동해야 하는 최소 아이들의 수를 계산합니다.
print(min_moves)  # 계산된 최소 이동 수를 출력합니다.
```
