# 미로만들기 문제 풀이 및 설명

https://www.acmicpc.net/status?user_id=ralskwo&problem_id=2665&from_mine=1

https://mayquartet.com/python-파이썬-백준-2665-미로만들기-문제-풀이-및-설명/

## 문제 이해

이 문제는 바둑판 모양의 방 배열에서 출발점에서 도착점까지 가는 경로를 찾아야 하는 문제입니다. 하지만 문제를 단순히 경로 탐색 문제로 바라볼 것이 아니라, 검은 방을 흰 방으로 바꿔가면서 경로를 만들어내는 문제로 접근해야 합니다. 각 방은 흰 방(1)과 검은 방(0)으로 나뉘며, 흰 방은 자유롭게 통과할 수 있지만, 검은 방은 통과할 수 없습니다. 검은 방을 흰 방으로 바꾸어야만 경로를 만들 수 있으며, 그때 바꾸어야 하는 검은 방의 최소 개수를 구하는 것이 목표입니다.

중요한 점은 검은 방을 무작정 많이 바꾸는 것이 아니라, 최소한의 개수만 바꿔서 출발점에서 도착점까지 가는 경로를 만드는 것입니다. 검은 방을 하나도 바꾸지 않아도 갈 수 있다면 0을 출력하면 됩니다. 이 문제는 경로를 찾는 동시에 최소한의 방을 바꾸는 최적화 문제로 볼 수 있습니다.

## 입출력 조건

### 입력 조건

1. 첫 번째 줄에 방의 크기 `n`이 주어집니다. `n`은 1 이상 50 이하의 자연수로, 방은 `n x n` 크기의 배열로 주어집니다.
2. 그 다음 `n`개의 줄에 걸쳐 각 줄마다 `0`과 `1`로 이루어진 길이 `n`의 수열이 주어집니다.
   - `1`은 흰 방을 나타내며, 자유롭게 지나갈 수 있는 방입니다.
   - `0`은 검은 방을 나타내며, 통과할 수 없는 방이지만, 필요하다면 흰 방으로 바꿀 수 있습니다.
3. 시작 방은 좌측 상단 (0, 0) 위치의 방이며, 도착 방은 우측 하단 (n-1, n-1) 위치의 방입니다. 시작 방과 도착 방은 항상 흰 방(1)입니다.

### 출력 조건

- 첫 번째 줄에 출발점에서 도착점까지 가기 위해 흰 방으로 바꾸어야 하는 최소 검은 방의 수를 출력합니다. 만약 검은 방을 바꾸지 않아도 되는 경우에는 0을 출력합니다.

## 접근 방식

이 문제는 **그래프 탐색** 문제로, BFS(너비 우선 탐색)를 응용하여 해결할 수 있습니다. 일반적인 BFS 탐색은 간선의 가중치가 모두 동일할 때 사용할 수 있지만, 이 문제는 검은 방(0)을 흰 방으로 바꿀 때 비용이 1 증가하는 가중치가 있는 상태입니다. 따라서, 각 이동에 대해 비용이 달라질 수 있으므로 **0-1 BFS** 알고리즘을 사용해야 합니다.

0-1 BFS는 가중치가 0 또는 1인 간선에서 최단 경로를 구할 때 매우 효율적입니다. 흰 방으로 이동하는 경우는 비용이 0이므로 우선순위가 더 높으며, 검은 방을 흰 방으로 바꿔 이동할 경우에는 비용이 1이 추가됩니다. 이러한 특성 때문에 우리는 덱(deque)을 사용하여 BFS 탐색을 수행할 수 있습니다. 흰 방으로 이동할 때는 덱의 앞쪽에 삽입하고, 검은 방으로 이동할 때는 덱의 뒤쪽에 삽입하는 방식으로 최단 경로를 찾습니다.

따라서, 이 문제의 핵심은 **0-1 BFS** 알고리즘을 사용하여 검은 방을 최소한으로 바꾸면서 출발점에서 도착점까지의 경로를 찾는 것입니다.

## 풀이 과정

1. **입력 처리 및 초기화**:

   - 먼저 `n`과 방 배열을 입력받습니다. 방 배열은 `n x n` 크기의 2차원 리스트로 처리되며, 각 방은 흰 방(1) 또는 검은 방(0)으로 주어집니다.
   - 각 방까지 도달할 때 바꾼 검은 방의 최소 개수를 저장하는 `dist` 배열을 생성합니다. 이 배열은 처음에 모두 무한대(`float('inf')`)로 초기화하고, 시작점인 (0, 0)은 0으로 설정합니다. 이는 시작점에서는 아무 방도 바꿀 필요가 없기 때문입니다.

2. **BFS 탐색 준비**:

   - BFS 탐색을 위해 덱(deque)을 사용합니다. 시작점 `(0, 0)`을 덱에 삽입하고 탐색을 시작합니다. 덱은 0-1 BFS에서 경로 탐색 시 비용이 작은 곳(흰 방)부터 우선 탐색하기 위해 사용됩니다.
   - 4방향(상, 하, 좌, 우)으로 이동할 수 있으므로 이를 나타내기 위한 `dx`와 `dy` 배열을 미리 정의해둡니다.

3. **BFS 탐색 수행**:

   - 덱에서 현재 위치 `(x, y)`를 꺼내어, 4방향으로 이동 가능한 모든 경우를 탐색합니다.
   - 이동하려는 방이 흰 방(1)일 경우:
     - 이미 저장된 비용보다 더 적은 비용으로 도달할 수 있다면, 해당 방까지의 최소 비용을 업데이트합니다.
     - 흰 방은 비용을 추가하지 않으므로 덱의 앞에 삽입하여 우선적으로 탐색합니다.
   - 이동하려는 방이 검은 방(0)일 경우:
     - 검은 방을 흰 방으로 바꾸는 비용 1을 추가하여 비용을 업데이트합니다.
     - 검은 방은 비용이 추가되므로 덱의 뒤에 삽입하여 나중에 탐색됩니다.

4. **결과 출력**:
   - BFS 탐색이 완료되면 도착점 `(n-1, n-1)`에 도달할 때까지 바꾼 검은 방의 최소 개수를 출력합니다. 만약 도착점까지 바꾸지 않고도 도달할 수 있다면 0을 출력하게 됩니다.

## 코드 구현

```python
from collections import deque  # deque를 사용하기 위해 collections 모듈에서 deque를 임포트

# 4방향(상, 하, 좌, 우)으로 이동할 때의 x축, y축 변화를 저장
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def bfs_min_change(n, grid):  # BFS 알고리즘을 이용하여 최소 검은 방 변경 수를 계산하는 함수
    # 각 방까지 도달할 때 최소로 검은 방을 흰 방으로 바꾼 횟수를 저장하는 배열을 생성, 처음에는 무한대 값으로 초기화
    dist = [[float('inf')] * n for _ in range(n)]

    # 출발점인 (0,0)은 흰 방이므로 변경할 필요가 없으므로 0으로 설정
    dist[0][0] = 0

    # 시작점 (0, 0)을 deque에 추가, BFS 시작
    dq = deque([(0, 0)])

    # deque가 빌 때까지 반복, BFS 탐색 진행
    while dq:
        # deque에서 현재 좌표를 꺼냄
        x, y = dq.popleft()

        # 4방향으로 이동 시도
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]

            # 이동하려는 좌표가 유효한 범위 내에 있는지 확인
            if 0 <= nx < n and 0 <= ny < n:
                # 이동하려는 방이 흰 방이고, 이전보다 적은 비용으로 도달할 수 있으면
                if grid[nx][ny] == '1' and dist[nx][ny] > dist[x][y]:
                    # 그 방까지의 최소 비용을 업데이트
                    dist[nx][ny] = dist[x][y]
                    # 흰 방은 비용이 추가되지 않으므로 deque의 앞에 추가
                    dq.appendleft((nx, ny))
                # 이동하려는 방이 검은 방이고, 이전보다 적은 비용으로 도달할 수 있으면
                elif grid[nx][ny] == '0' and dist[nx][ny] > dist[x][y] + 1:
                    # 검은 방을 흰 방으로 바꾸는 비용(1)을 추가하여 최소 비용을 업데이트
                    dist[nx][ny] = dist[x][y] + 1
                    # 검은 방은 비용이 추가되므로 deque의 뒤에 추가
                    dq.append((nx, ny))

    # 도착점 (n-1, n-1)에 도달할 때 최소로 검은 방을 흰 방으로 바꾼 횟수를 반환
    return dist[n-1][n-1]

# 첫 번째 줄에서 n을 입력받음
n = int(input())

# n개의 줄에서 각 줄마다 방의 상태를 입력받아 리스트로 저장
grid = [input().strip() for _ in range(n)]

# BFS 탐색 결과를 출력
print(bfs_min_change(n, grid))
```
