# 탈옥 문제 풀이 및 설명

https://www.acmicpc.net/problem/9376

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-9376-%ed%83%88%ec%98%a5-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 감옥에서 두 명의 죄수를 탈옥시키기 위해 필요한 최소한의 문의 개수를 계산하는 문제입니다. 감옥의 평면도가 주어지며, 평면도는 벽, 빈 공간, 문, 그리고 죄수의 위치를 나타냅니다. 상근이는 감옥 밖에서 자유롭게 이동할 수 있으며, 주어진 평면도를 통해 두 죄수를 감옥 밖으로 탈출시켜야 합니다. 이 과정에서 문을 열어야 하는데, 문을 열 때마다 시간이 걸리므로 가능한 한 최소한의 문만 열어야 합니다. 문은 한 번 열면 계속 열린 상태로 유지됩니다. 문제의 핵심은 두 죄수를 탈출시키기 위해 필요한 최소한의 문의 개수를 구하는 것입니다.

## 입출력 조건

- **입력 조건**:

  - 첫 번째 줄에 테스트 케이스의 개수 `T`가 주어집니다. `T`는 100을 넘지 않습니다.
  - 각 테스트 케이스의 첫 번째 줄에는 평면도의 높이 `h`와 너비 `w`가 주어집니다. (`2 ≤ h, w ≤ 100`)
  - 다음 `h`개의 줄에는 평면도의 정보가 주어집니다. 각 줄은 `w`개의 문자로 이루어져 있으며, 각 문자는 감옥의 특정 위치의 상태를 나타냅니다.
    - `.`: 빈 공간
    - `*`: 지나갈 수 없는 벽
    - `#`: 문
    - `$`: 죄수의 위치 (죄수는 항상 두 명이 주어집니다)
  - 상근이는 감옥 밖에서 시작할 수 있으며, 모든 테스트 케이스에서 각 죄수와 감옥 밖을 연결하는 경로가 반드시 존재합니다.

- **출력 조건**:
  - 각 테스트 케이스마다 두 죄수를 탈옥시키기 위해서 열어야 하는 문의 최솟값을 출력합니다.

## 접근 방식

이 문제를 해결하기 위해서는 그래프 이론의 BFS(너비 우선 탐색) 알고리즘을 사용하는 것이 적합합니다. BFS를 사용하여 각 위치에서 다른 위치로 이동할 때의 최단 경로를 구할 수 있습니다. 특히, 이 문제에서는 각 죄수와 감옥 외부에서 시작하여 감옥 내부의 모든 위치까지 도달할 수 있는 최단 경로를 구해야 합니다. 각 경로를 구하는 동안 문을 통과할 때마다 가중치를 추가하여, 가능한 최소한의 문의 개수를 구해야 합니다.

문제의 중요한 부분은 죄수들이 탈출할 수 있는 경로를 각각 독립적으로 구한 뒤, 이 경로들이 만나는 지점에서의 문의 개수를 최적화하는 것입니다. 따라서 세 번의 BFS를 수행하여 각각의 최소 경로를 구하고, 그 결과를 바탕으로 최종적으로 최소 문의 개수를 계산해야 합니다.

## 풀이 과정

1. **평면도 확장 및 초기화**:

   - 감옥의 평면도를 입력받을 때, 감옥 외부에서 자유롭게 이동할 수 있다는 점을 고려하여 평면도의 외부를 빈 공간(`.`)으로 확장합니다. 이렇게 하면, 상근이가 감옥 외부에서 출발할 수 있으며, 이 외부 확장된 부분을 통해 각 죄수의 위치로부터 시작하는 경로를 계산할 수 있습니다.

2. **BFS를 이용한 최단 경로 탐색**:

   - 세 번의 BFS를 수행합니다:
     1. 감옥 외부에서 시작하는 BFS.
     2. 첫 번째 죄수의 위치에서 시작하는 BFS.
     3. 두 번째 죄수의 위치에서 시작하는 BFS.
   - 각 BFS는 해당 위치에서 감옥의 모든 위치까지 도달하는 최단 거리를 계산합니다. 문을 통과할 때는 가중치가 추가되며, 빈 공간은 가중치가 추가되지 않은 채로 다음 위치로 이동합니다.

3. **최소 문의 개수 계산**:
   - 세 번의 BFS 결과를 바탕으로, 각 감옥 내부의 위치에서 세 경로가 만나는 지점의 문의 개수를 계산합니다.
   - 각 위치에서의 총 문의 개수는 세 경로의 가중치를 더한 값으로 계산됩니다. 만약 해당 위치가 문(`.`)이라면, 문의 가중치가 중복되어 계산되므로 이를 보정하여 총 가중치에서 2를 빼줍니다.
   - 이 과정에서 계산된 문의 개수 중 최소값을 구하여, 최종적으로 탈옥을 위해 필요한 최소 문의 개수를 출력합니다.

이와 같은 방법으로 문제를 접근하고 풀이하면, 모든 테스트 케이스에 대해 정확한 답을 도출할 수 있습니다. BFS를 통해 각 위치까지의 최단 경로를 계산하고, 이를 바탕으로 중복된 문의 비용을 최소화하여 최적의 탈옥 경로를 찾는 것이 핵심입니다.

## 코드 구현

```python
from collections import deque  # deque를 사용하기 위해 collections 모듈에서 deque를 import

def bfs(start, prison_map, h, w):
    # 거리를 저장할 2차원 리스트를 초기화. 초기값은 무한대(float('inf'))
    dist = [[float('inf')] * (w + 2) for _ in range(h + 2)]

    # 시작 위치를 deque에 추가하고, 시작 위치의 거리를 0으로 설정
    queue = deque([start])
    dist[start[0]][start[1]] = 0

    # BFS를 수행하여 모든 경로를 탐색
    while queue:
        x, y = queue.popleft()  # 큐에서 현재 위치를 꺼냄

        # 네 방향(상, 하, 좌, 우)으로 이동할 수 있는 경우를 검사
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy  # 다음 이동할 위치 계산
            # 다음 위치가 감옥 평면도 내에 있는지 확인
            if 0 <= nx < h + 2 and 0 <= ny < w + 2:
                # 다음 위치가 벽이 아니고 아직 방문하지 않은 경우
                if prison_map[nx][ny] != '*' and dist[nx][ny] == float('inf'):
                    # 다음 위치가 문인 경우
                    if prison_map[nx][ny] == '#':
                        dist[nx][ny] = dist[x][y] + 1  # 문의 개수를 증가시키며 이동
                        queue.append((nx, ny))  # 다음 위치를 큐에 추가
                    else:
                        dist[nx][ny] = dist[x][y]  # 문이 아니면 동일한 거리로 이동
                        queue.appendleft((nx, ny))  # 큐의 앞에 추가해 우선적으로 처리

    return dist  # 시작점으로부터 각 위치까지의 최소 거리를 반환

def solve(prison_map, h, w):
    prisoners = []  # 죄수들의 위치를 저장할 리스트
    # 감옥 평면도 전체를 탐색하며 죄수들의 위치를 찾음
    for i in range(h + 2):
        for j in range(w + 2):
            if prison_map[i][j] == '$':
                prisoners.append((i, j))  # 죄수의 위치를 리스트에 추가

    # 감옥 밖에서 시작하는 BFS를 수행하여 거리 계산
    dist1 = bfs((0, 0), prison_map, h, w)
    # 첫 번째 죄수 위치에서 시작하는 BFS를 수행하여 거리 계산
    dist2 = bfs(prisoners[0], prison_map, h, w)
    # 두 번째 죄수 위치에서 시작하는 BFS를 수행하여 거리 계산
    dist3 = bfs(prisoners[1], prison_map, h, w)

    result = float('inf')  # 최솟값을 저장하기 위해 초기값을 무한대로 설정

    # 감옥 전체를 탐색하면서 모든 위치에서의 문의 개수를 계산
    for i in range(h + 2):
        for j in range(w + 2):
            if prison_map[i][j] != '*':
                total_cost = dist1[i][j] + dist2[i][j] + dist3[i][j]  # 세 경로의 합산 값을 계산
                if prison_map[i][j] == '#':
                    total_cost -= 2  # 문이 겹치는 경우 중복 비용 제거
                result = min(result, total_cost)  # 최소값을 업데이트

    return result  # 최종적으로 계산된 최소 문의 개수를 반환

def main():
    T = int(input())  # 테스트 케이스의 개수를 입력받음
    results = []  # 결과를 저장할 리스트
    for _ in range(T):
        h, w = map(int, input().split())  # 감옥의 높이와 너비를 입력받음
        prison_map = ['.' * (w + 2)]  # 맵의 테두리를 .으로 초기화하여 외부를 표시
        for _ in range(h):
            prison_map.append('.' + input() + '.')  # 맵의 각 줄을 입력받아 양 옆에 .을 추가
        prison_map.append('.' * (w + 2))  # 맵의 테두리를 .으로 초기화하여 외부를 표시

        result = solve(prison_map, h, w)  # 주어진 맵에 대해 최소 문의 개수를 계산
        results.append(result)  # 결과를 리스트에 추가

    for result in results:
        print(result)  # 각 테스트 케이스의 결과를 출력

if __name__ == "__main__":
    main()  # 프로그램의 진입점
```
