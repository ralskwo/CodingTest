# 물통 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2251>

<https://mayquartet.com/python-백준-2251-물통/>

## 문제 이해

이 문제는 세 개의 물통에 대한 물의 이동을 관리하며, 특정 조건에서 가능한 물의 양을 계산하는 문제입니다. 문제에서 주어진 세 개의 물통 중 첫 번째와 두 번째 물통은 초기에는 비어 있고, 세 번째 물통은 가득 차 있습니다. 물통 간의 물을 이동시키는 과정에서 가능한 모든 상태를 탐색해야 하며, 최종적으로 첫 번째 물통이 비어 있을 때 세 번째 물통에 담길 수 있는 물의 모든 가능한 양을 구하는 것이 목표입니다.

문제를 해결하기 위해 각 물통의 상태를 상태 공간 탐색 문제로 바라볼 수 있습니다. 여기서 상태는 각 물통에 담긴 물의 양으로 표현할 수 있으며, 물통 간의 물을 옮길 수 있는 여러 가지 조합과 방법을 탐색하여 모든 가능한 상태를 만들어 나갑니다. 최종적으로 특정 조건을 만족하는 상태들을 집합으로 모아 결과를 반환하는 구조입니다.

## 입출력 조건

**입력 조건**

- 입력으로는 세 개의 정수 `A`, `B`, `C`가 공백으로 구분되어 주어집니다. 각각의 정수는 각 물통의 최대 용량을 의미하며, 이 값들은 `1 ≤ A, B, C ≤ 200` 범위 내에서 주어집니다.
- 세 번째 물통에는 `C`만큼의 물이 가득 차 있으며, 첫 번째와 두 번째 물통은 처음에 비어 있습니다.

**출력 조건**

- 출력은 첫 번째 물통이 비어 있을 때 세 번째 물통에 담길 수 있는 모든 가능한 물의 양을 오름차순으로 정렬하여 공백으로 구분해 출력합니다.

## 접근 방식

이 문제는 상태 공간 탐색을 통해 모든 가능한 물통의 상태를 찾아야 하므로, 그래프 탐색 알고리즘인 너비 우선 탐색(BFS) 또는 깊이 우선 탐색(DFS)을 사용하여 해결할 수 있습니다. 이 문제에서는 BFS를 사용하여 모든 상태를 효율적으로 탐색하는 방법이 적합합니다.

물통의 상태는 `(a, b, c)`로 정의할 수 있으며, 여기서 `a`, `b`, `c`는 각각 첫 번째, 두 번째, 세 번째 물통에 담긴 물의 양을 의미합니다. 문제에서 제공한 물통 간 물 옮기기 규칙을 기반으로 상태를 생성하고, 각 상태에 대해 다음을 수행해야 합니다.

1. **상태 공간 탐색**: 초기 상태 `(0, 0, C)`에서 시작하여, 가능한 모든 상태를 BFS로 탐색하며 중복되지 않은 상태만을 방문합니다.
2. **조건에 맞는 결과 저장**: 첫 번째 물통이 비어 있을 때 세 번째 물통의 물의 양을 `result` 집합에 저장합니다.
3. **방문 체크**: 이미 방문한 상태는 다시 탐색하지 않기 위해 `visited` 집합을 사용하여 상태 중복을 방지합니다.

이 문제에서 중요한 점은 가능한 모든 물의 이동 상태를 탐색하면서, 조건에 맞는 결과만을 저장하는 것입니다. 이렇게 하면 모든 가능한 답을 오름차순으로 반환할 수 있습니다.

<https://mayquartet.com/algorithm-bfs-너비-우선-탐색-알고리즘/>

<https://mayquartet.com/algorithm-알고리즘-dfs-깊이-우선-탐색-알고리즘-이해하기/>

## 풀이 과정

1. **필요한 모듈 가져오기**  
   `deque`를 사용하여 BFS 큐를 생성합니다. `deque`는 큐의 양 끝에서 빠르게 요소를 추가하거나 제거할 수 있어 BFS 탐색 시 효율적입니다.

2. **물 옮기기 함수 정의 (`pour` 함수)**  
   두 물통 사이에서 물을 옮길 때 최종 상태를 반환하는 `pour` 함수를 정의합니다. 이 함수는 출발 물통(`x`)과 목표 물통(`y`), 그리고 목표 물통의 최대 용량(`max_y`)을 매개변수로 받아 물을 옮긴 결과를 계산합니다.

   - 옮긴 후 목표 물통이 최대 용량을 초과하면 초과한 만큼만 출발 물통에 남기고, 목표 물통은 가득 찬 상태가 됩니다.
   - 초과하지 않는 경우에는 출발 물통의 물을 모두 목표 물통으로 옮기고 결과를 반환합니다.

3. **가능한 물의 양 계산 함수 정의 (`possible_amounts` 함수)**  
   가능한 모든 물통 상태를 탐색하여 첫 번째 물통이 비어 있을 때 세 번째 물통에 담길 수 있는 물의 양을 계산하는 `possible_amounts` 함수를 정의합니다.

   - `visited` 집합을 생성하여 중복된 상태의 탐색을 방지합니다.
   - `result` 집합을 생성하여 첫 번째 물통이 비어 있을 때 세 번째 물통의 물의 양을 저장합니다.
   - BFS 탐색을 위해 `queue`를 생성하고, 초기 상태 `(0, 0, C)`를 큐에 추가합니다.

4. **BFS 탐색 루프**

   - `while queue:` 루프를 통해 큐가 빌 때까지 BFS 탐색을 반복합니다. 각 반복에서 큐의 맨 앞에 있는 현재 상태 `(a, b, c)`를 가져옵니다.
   - 첫 번째 물통이 비어 있을 때(`a == 0`), 세 번째 물통의 물의 양 `c`를 `result` 집합에 추가합니다.
   - 현재 상태가 이미 방문한 상태인지 확인하여, 중복된 상태라면 `continue`로 스킵하고 새로운 상태는 `visited`에 추가합니다.

5. **물 옮기기 연산 추가**  
   각 물통 간의 물을 옮기는 연산을 여섯 가지 경우로 나눕니다:

   - `A → B`, `A → C`, `B → A`, `B → C`, `C → A`, `C → B`
   - `pour` 함수를 통해 각 경우의 최종 상태를 계산하고, 그 상태를 `queue`에 추가하여 다음 탐색을 준비합니다.

6. **결과 반환**  
   최종적으로 `result` 집합을 오름차순으로 정렬하여 반환하고, 출력 시 공백으로 구분하여 결과를 출력합니다.

## 코드 구현

```python
from collections import deque  # deque를 사용하여 BFS 큐를 생성합니다.

def pour(x, y, max_y):  # 두 물통 사이에서 물을 옮기는 함수입니다.
    if x + y > max_y:  # 옮길 물의 양이 max_y를 초과하는 경우
        return x + y - max_y, max_y  # 옮기고 남은 양과 가득 찬 상태를 반환합니다.
    else:
        return 0, x + y  # 아니면 x의 모든 물을 y에 옮긴 결과를 반환합니다.

def possible_amounts(A, B, C):  # 가능한 물의 양을 계산하는 메인 함수입니다.
    visited = set()  # 방문한 상태를 저장하기 위한 집합입니다.
    result = set()  # 결과로 반환할 물의 양을 저장하는 집합입니다.
    queue = deque([(0, 0, C)])  # 시작 상태 (0, 0, C)를 큐에 추가합니다.

    while queue:  # 큐가 빌 때까지 BFS를 반복합니다.
        a, b, c = queue.popleft()  # 현재 상태를 큐에서 꺼냅니다.

        if a == 0:  # 첫 번째 물통이 비어 있을 때
            result.add(c)  # 세 번째 물통의 물의 양을 결과에 추가합니다.

        if (a, b, c) in visited:  # 이미 방문한 상태라면
            continue  # 스킵하고 다음 상태로 넘어갑니다.
        visited.add((a, b, c))  # 현재 상태를 방문 처리합니다.

        na, nb = pour(a, b, B)  # A → B로 물을 옮기기
        queue.append((na, nb, c))  # 새 상태를 큐에 추가합니다.

        na, nc = pour(a, c, C)  # A → C로 물을 옮기기
        queue.append((na, b, nc))  # 새 상태를 큐에 추가합니다.

        nb, na = pour(b, a, A)  # B → A로 물을 옮기기
        queue.append((na, nb, c))  # 새 상태를 큐에 추가합니다.

        nb, nc = pour(b, c, C)  # B → C로 물을 옮기기
        queue.append((a, nb, nc))  # 새 상태를 큐에 추가합니다.

        nc, na = pour(c, a, A)  # C → A로 물을 옮기기
        queue.append((na, b, nc))  # 새 상태를 큐에 추가합니다.

        nc, nb = pour(c, b, B)  # C → B로 물을 옮기기
        queue.append((a, nb, nc))  # 새 상태를 큐에 추가합니다.

    return sorted(result)  # 결과를 오름차순으로 정렬하여 반환합니다.

A, B, C = map(int, input().split())  # 입력을 받아 A, B, C에 저장합니다.
result = possible_amounts(A, B, C)  # possible_amounts 함수를 호출하여 결과를 계산합니다.
print(" ".join(map(str, result)))  # 결과를 공백으로 구분하여 출력합니다.
```
