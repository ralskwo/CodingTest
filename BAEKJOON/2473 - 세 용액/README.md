# 세 용액 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2473>

<https://mayquartet.com/python-백준-2473-세-용액/>

## 문제 이해

이 문제는 주어진 산성 및 알칼리성 용액 중 세 개의 용액을 선택하여 혼합했을 때, 혼합된 용액의 특성값 합이 0에 가장 가까운 조합을 찾는 것입니다. 각 용액은 고유한 정수 값으로 표현되며, 산성 용액은 양수, 알칼리성 용액은 음수로 주어집니다. 세 용액의 특성값을 더한 값이 혼합 용액의 특성값으로 정의됩니다. 이 값이 0에 가까울수록 산성과 알칼리성의 중화가 잘 이루어진 조합이라 할 수 있습니다.

따라서 이 문제의 목표는 **세 가지 서로 다른 용액의 특성값의 합이 0에 가장 가까운 조합을 찾는 것**입니다. 용액의 특성값은 매우 큰 양수 및 음수 범위를 가질 수 있고, `N`의 범위가 최대 5000이므로 효율적인 탐색 방법이 필요합니다.

## 입출력 조건

- **입력 조건**
  - 첫 줄에는 전체 용액의 수 `N`이 주어집니다. 이 값은 3 이상 5000 이하의 정수입니다.
  - 두 번째 줄에는 `N`개의 용액 특성값이 공백으로 구분되어 입력됩니다. 각 특성값은 -1,000,000,000 이상 1,000,000,000 이하의 정수로 주어지며, 각 용액의 특성값은 고유합니다.
- **출력 조건**
  - 세 용액을 혼합하여 특성값이 0에 가장 가까운 조합을 찾은 후, 해당 용액의 특성값을 오름차순으로 한 줄에 출력합니다. 만약 0에 가장 가까운 조합이 여러 개라면 그 중 하나만 출력하면 됩니다.

## 접근 방식

1. **정렬과 두 포인터를 사용한 탐색**

   - 주어진 용액 리스트에서 세 개의 서로 다른 용액을 선택하여 합을 구해야 하는 문제이므로 모든 가능한 세 용액의 조합을 무작위로 비교하기에는 비효율적입니다. 따라서 리스트를 **오름차순으로 정렬**한 뒤, **두 포인터**를 활용하는 방식으로 세 용액의 합이 0에 가까운 조합을 찾아냅니다.

2. **첫 번째 용액 고정**

   - 첫 번째 용액을 리스트에서 하나씩 선택하여 고정하고, 나머지 두 개의 용액을 리스트 내에서 탐색하여 현재 조합의 합이 0에 얼마나 가까운지 비교합니다.

3. **두 포인터로 최적의 조합 찾기**

   - 고정된 첫 번째 용액을 기준으로 나머지 두 용액은 각각 리스트의 왼쪽 끝과 오른쪽 끝에서 출발하는 **두 포인터 방식**을 사용합니다. 왼쪽 포인터는 고정된 용액 이후의 인덱스에서 시작하고, 오른쪽 포인터는 리스트의 마지막 인덱스에서 시작합니다. 현재 조합의 합이 0보다 크거나 작으면 각 포인터를 조정하여 합이 0에 더 가까워지도록 이동합니다.

4. **0에 가장 가까운 합을 계속 갱신**
   - 현재 합이 0에 더 가까운 조합을 발견하면 해당 조합을 저장하고, 최종적으로 가장 가까운 조합을 출력합니다.

<https://mayquartet.com/algorithm-투-포인터two-pointer-알고리즘-이해하기/>

## 풀이 과정

1. **리스트 정렬**

   - 입력된 용액 리스트 `solutions`를 **오름차순으로 정렬**합니다. 이렇게 하면 두 포인터 방식을 효율적으로 사용할 수 있습니다.

2. **첫 번째 용액 고정**

   - `for` 반복문을 통해 첫 번째 용액을 리스트의 처음부터 `N-2`번째 용액까지 하나씩 고정하여 선택합니다. 각 반복에서 고정된 용액을 기준으로 두 포인터를 설정하고 탐색을 진행합니다.

3. **두 포인터 설정**

   - `left` 포인터는 고정된 용액 다음 인덱스에서 시작합니다.
   - `right` 포인터는 리스트의 마지막 인덱스에서 시작합니다.

4. **두 포인터 탐색 반복**

   - `while` 반복문을 사용하여 `left`가 `right`보다 작을 동안 계속 진행합니다.
     - 고정된 용액과 두 포인터가 가리키는 용액들의 합을 계산하여 `current_sum` 변수에 저장합니다.
     - `current_sum`이 현재 `closest_sum`보다 0에 가까우면 `closest_sum`을 `current_sum`으로 갱신하고, 이 조합을 `answer` 리스트에 저장합니다.

5. **포인터 이동**

   - 만약 `current_sum`이 0보다 크다면 합이 0에 더 가까워지기 위해 `right` 포인터를 왼쪽으로 한 칸 이동합니다.
   - `current_sum`이 0보다 작다면 합을 더 크게 만들기 위해 `left` 포인터를 오른쪽으로 한 칸 이동합니다.
   - `current_sum`이 정확히 0이면 가장 이상적인 조합이므로, `answer`를 바로 반환하여 종료합니다.

6. **결과 반환**
   - 최종적으로, `answer`에 저장된 세 용액의 특성값을 **오름차순으로 정렬**하여 출력합니다.

## 코드 구현

```python
def find_three_solutions_closest_to_zero(N, solutions):
    # 용액 리스트를 오름차순으로 정렬하여 두 포인터 접근을 용이하게 만듦
    solutions.sort()

    # 0에 가장 가까운 합을 저장할 변수로 초기에는 매우 큰 값으로 설정
    closest_sum = float('inf')

    # 조건을 만족하는 세 용액의 값을 저장할 리스트
    answer = []

    # 첫 번째 용액을 고정하여 두 번째와 세 번째 용액을 찾기 위한 반복문
    for i in range(N - 2):
        # 왼쪽 포인터는 고정된 용액 다음 인덱스로 설정
        left = i + 1
        # 오른쪽 포인터는 리스트의 마지막 인덱스로 설정
        right = N - 1

        # 왼쪽 포인터가 오른쪽 포인터보다 작을 때까지 반복
        while left < right:
            # 고정된 용액과 두 포인터가 가리키는 용액들의 합을 계산
            current_sum = solutions[i] + solutions[left] + solutions[right]

            # 현재 합이 0에 더 가까운 경우 closest_sum과 answer를 갱신
            if abs(current_sum) < abs(closest_sum):
                closest_sum = current_sum
                answer = [solutions[i], solutions[left], solutions[right]]

            # 합이 양수인 경우 합을 줄이기 위해 오른쪽 포인터를 왼쪽으로 이동
            if current_sum > 0:
                right -= 1
            # 합이 음수인 경우 합을 늘리기 위해 왼쪽 포인터를 오른쪽으로 이동
            elif current_sum < 0:
                left += 1
            # 합이 정확히 0인 경우 최적의 해이므로 바로 결과를 반환
            else:
                return sorted(answer)

    # 모든 경우를 다 확인한 후, 0에 가장 가까운 합을 이루는 세 용액을 오름차순으로 정렬하여 반환
    return sorted(answer)

# 전체 용액의 개수를 입력받음
N = int(input())
# 각 용액의 특성값을 리스트 형태로 입력받음
solutions = list(map(int, input().split()))

# 함수 호출을 통해 0에 가장 가까운 합을 이루는 세 용액의 값을 계산
result = find_three_solutions_closest_to_zero(N, solutions)
# 결과를 공백으로 구분하여 출력
print(" ".join(map(str, result)))
```
