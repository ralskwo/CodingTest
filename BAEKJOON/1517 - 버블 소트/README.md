# 버블 소트 문제 풀이 및 설명

https://www.acmicpc.net/problem/1517

https://mayquartet.com/python-%ed%8c%8c%ec%9d%b4%ec%8d%ac-%eb%b0%b1%ec%a4%80-1517-%eb%b2%84%eb%b8%94-%ec%86%8c%ed%8a%b8-%eb%ac%b8%ec%a0%9c-%ed%92%80%ec%9d%b4-%eb%b0%8f-%ec%84%a4%eb%aa%85/

## 문제 이해

이 문제는 주어진 수열을 버블 소트를 사용하여 정렬할 때, 발생하는 스왑(Swap)의 총 횟수를 계산하는 것입니다. 버블 소트는 인접한 두 수를 비교하여 큰 수가 뒤로 가도록 자리를 바꾸는 과정을 반복하는 정렬 알고리즘입니다. 문제에서 주어진 수열을 정렬할 때 얼마나 많은 스왑이 발생하는지를 계산해야 합니다. 문제의 핵심은 이 스왑 횟수를 효율적으로 계산하는 것입니다. 만약 주어진 수열의 길이가 작다면 직접 버블 소트를 구현하여 해결할 수 있지만, 주어진 입력 크기가 최대 500,000에 이를 수 있기 때문에 O(N^2) 복잡도를 가지는 단순한 버블 소트 알고리즘을 사용하는 것은 시간 초과를 초래할 것입니다.

## 입출력 조건

- **입력 조건:**

  1. 첫 번째 줄에 수열의 크기 N이 주어집니다. (1 ≤ N ≤ 500,000)
  2. 두 번째 줄에는 수열 A의 요소들이 공백으로 구분되어 주어집니다. 각각의 요소 A[i]는 정수이며, 0 ≤ |A[i]| ≤ 1,000,000,000의 범위에 속합니다.

- **출력 조건:**
  - 첫째 줄에 버블 소트 과정에서 발생하는 총 스왑 횟수를 출력합니다.

## 접근 방식

이 문제를 효율적으로 해결하기 위해서는 **병합 정렬(Merge Sort)** 알고리즘을 활용하는 것이 좋습니다. 병합 정렬은 배열을 재귀적으로 두 부분으로 나누고, 각 부분을 정렬한 뒤 병합하는 과정에서 역전(Inversion) 횟수를 세는 방식으로 문제를 해결할 수 있습니다. 역전이란 배열에서 앞에 있는 요소가 뒤에 있는 요소보다 큰 경우를 말하며, 버블 소트에서 발생하는 스왑 횟수와 동일합니다.

병합 정렬을 사용하면 배열을 정렬하는 과정에서 자연스럽게 역전 횟수를 효율적으로 계산할 수 있으며, 이는 O(N log N)의 시간 복잡도로 해결할 수 있습니다. 이 방법은 주어진 문제의 크기와 제한 사항을 고려했을 때 적합한 접근 방식입니다.

## 풀이 과정

1. **병합 정렬로 문제 분할:**

   - 수열을 재귀적으로 반으로 나누어 두 개의 하위 배열로 분할합니다. 각 하위 배열에 대해 병합 정렬을 수행하며, 각각의 정렬된 배열에서 역전 횟수를 계산합니다.
   - 이 과정에서 만약 배열이 더 이상 나눌 수 없는 단일 요소로 이루어지면, 역전이 발생할 수 없으므로 0을 반환합니다.

2. **병합 과정에서 역전 횟수 계산:**

   - 하위 배열들을 병합하면서, 왼쪽 하위 배열의 요소가 오른쪽 하위 배열의 요소보다 큰 경우 역전이 발생한 것입니다. 이때, 왼쪽 배열에서 남아있는 모든 요소들과 역전 관계가 성립하므로, 그 수만큼 역전 횟수를 증가시킵니다.
   - 병합된 배열을 임시 배열에 저장한 후, 원래 배열에 복사하여 정렬된 상태를 유지합니다.

3. **전체 스왑 횟수 계산:**
   - 병합 정렬이 완료되면, 그 과정에서 계산된 모든 역전 횟수를 더하여 총 스왑 횟수를 구할 수 있습니다.
   - 최종적으로 이 값을 출력하여 문제를 해결합니다.

## 코드 구현

```python
def merge_sort_and_count(arr, temp_arr, left, right):
    if left == right:  # 배열이 하나의 요소만 가지고 있다면, 역전이 발생할 수 없으므로 0을 반환
        return 0

    mid = (left + right) // 2  # 배열을 두 부분으로 나누기 위해 중간 인덱스를 계산

    inv_count = merge_sort_and_count(arr, temp_arr, left, mid)  # 왼쪽 절반에서 발생하는 역전 횟수를 계산
    inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)  # 오른쪽 절반에서 발생하는 역전 횟수를 계산
    inv_count += merge_and_count(arr, temp_arr, left, mid, right)  # 병합하면서 발생하는 역전 횟수를 계산

    return inv_count  # 총 역전 횟수를 반환

def merge_and_count(arr, temp_arr, left, mid, right):
    i = left  # 왼쪽 서브배열의 시작 인덱스
    j = mid + 1  # 오른쪽 서브배열의 시작 인덱스
    k = left  # 병합된 배열의 시작 인덱스
    inv_count = 0  # 역전 횟수를 저장할 변수

    while i <= mid and j <= right:  # 왼쪽과 오른쪽 배열의 요소를 비교하여 병합
        if arr[i] <= arr[j]:  # 왼쪽 배열의 요소가 작거나 같으면 그대로 병합
            temp_arr[k] = arr[i]
            i += 1
        else:  # 오른쪽 배열의 요소가 작다면 역전이 발생한 것
            temp_arr[k] = arr[j]
            inv_count += (mid - i + 1)  # 남은 왼쪽 배열의 요소 수만큼 역전 횟수 추가
            j += 1
        k += 1

    while i <= mid:  # 왼쪽 배열에 남은 요소가 있으면 병합
        temp_arr[k] = arr[i]
        i += 1
        k += 1

    while j <= right:  # 오른쪽 배열에 남은 요소가 있으면 병합
        temp_arr[k] = arr[j]
        j += 1
        k += 1

    for i in range(left, right + 1):  # 병합된 결과를 원래 배열에 복사
        arr[i] = temp_arr[i]

    return inv_count  # 병합 중 발생한 역전 횟수를 반환

def count_swaps(arr, n):
    temp_arr = [0]*n  # 임시 배열을 생성
    return merge_sort_and_count(arr, temp_arr, 0, n - 1)  # 전체 배열에 대해 역전 횟수를 계산

n = int(input())  # 배열의 크기 입력
arr = list(map(int, input().split()))  # 배열의 요소들을 입력받아 리스트로 변환

print(count_swaps(arr, n))  # 스왑 횟수를 계산하여 출력
```
