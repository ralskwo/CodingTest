# 캐슬 디펜스 문제 풀이 및 설명

<https://www.acmicpc.net/problem/17135>

<https://mayquartet.com/python-파이썬-백준-17135-캐슬-디펜스/>

## 문제 이해

이 문제는 성을 방어하기 위해 궁수를 배치하고, 궁수들이 적을 공격하여 최대한 많은 적을 제거하는 시뮬레이션 문제입니다. 격자판은 N×M 크기의 2차원 배열로 주어지며, 각 칸에는 적이 있을 수도 있고 없을 수도 있습니다. 궁수는 성이 있는 곳(격자판의 N번 행 아래인 N+1번 행)에 배치할 수 있습니다. 각 턴마다 궁수는 자신의 공격 범위(D 이하)에 있는 적 중 가장 가까운 적을 공격하며, 여러 적이 같은 거리에 있으면 가장 왼쪽에 있는 적을 우선적으로 공격합니다.

게임의 핵심은 궁수를 배치한 후 각 턴마다 적을 공격하고, 적들이 한 칸씩 아래로 이동하면서 성에 도달하면 제거되는 방식으로 진행됩니다. 목표는 적을 최대한 많이 제거하는 것이며, 궁수의 배치가 게임의 결과에 중요한 영향을 미칩니다. 따라서 궁수의 최적 배치를 찾아서 최대한 많은 적을 제거하는 것이 문제의 핵심입니다.

## 입출력 조건

### 입력

1. 첫 번째 줄에는 격자판의 크기를 나타내는 행의 수 `N`, 열의 수 `M`, 그리고 궁수의 공격 거리 제한 `D`가 주어집니다.

   - `N`과 `M`은 3 이상 15 이하의 정수입니다.
   - `D`는 1 이상 10 이하의 정수입니다.

2. 두 번째 줄부터 `N`개의 줄에는 격자판의 상태가 주어집니다. 각 줄은 M개의 숫자로 이루어져 있으며, 각 숫자는 0 또는 1입니다.
   - 0은 빈 칸을 의미하고, 1은 적이 있는 칸을 의미합니다.

### 출력

- 궁수의 공격을 통해 제거할 수 있는 적의 최대 수를 출력합니다.

## 접근 방식

이 문제를 해결하기 위해서는 다음과 같은 방식으로 접근해야 합니다.

1. **궁수의 배치 조합 탐색**  
   궁수는 성이 있는 행에만 배치할 수 있으며, 3명의 궁수를 배치해야 합니다. 이를 위해 성이 위치한 열에서 궁수 3명을 배치할 수 있는 모든 조합을 탐색해야 합니다. 이 문제에서 열의 최대 개수는 15이므로, 15개의 열에서 3개를 선택하는 경우의 수는 `C(15, 3)`입니다. 이 값은 455로 비교적 작기 때문에 가능한 모든 궁수 배치를 시도해도 성능에 큰 문제가 없습니다.
2. **공격 및 시뮬레이션 진행**  
   궁수가 배치된 후, 각 턴마다 궁수는 자신의 공격 범위 내에 있는 적을 공격합니다. 궁수는 동시에 공격하며, 공격할 적은 가장 가까운 적입니다. 거리가 같을 경우에는 왼쪽에 있는 적을 우선적으로 공격해야 합니다. 적을 제거한 후에는 적이 한 칸 아래로 이동하며, 성에 도달한 적은 게임에서 제외됩니다. 적이 모두 제거될 때까지 이 과정을 반복합니다.
3. **최대 적 제거 수 계산**  
   각 궁수 배치에 대해 위 과정을 시뮬레이션한 후, 제거할 수 있는 최대 적의 수를 기록합니다. 모든 배치에 대해 시뮬레이션을 진행한 후, 가장 많은 적을 제거할 수 있는 경우를 찾습니다.

이 문제는 궁수 배치의 가능한 모든 경우를 시도하고, 각 배치에서 적을 공격하는 방식을 시뮬레이션하는 완전 탐색 방식으로 해결할 수 있습니다. 시뮬레이션 과정에서 격자판 상태를 매번 복사하여 사용하면 원본 데이터가 변형되는 것을 막을 수 있습니다.

## 풀이 과정

1. **입력 처리**  
   먼저, 입력을 받아 격자판의 크기 `N`, `M`, 궁수의 공격 거리 `D`를 저장합니다. 이후, `N`개의 줄에 걸쳐 격자판의 상태를 입력받아 2차원 배열로 저장합니다.

2. **궁수 배치 조합 구하기**  
   성이 위치한 행의 M개의 열에서 궁수 3명을 배치할 수 있는 모든 조합을 구합니다. 이를 위해 `itertools`의 `combinations` 함수를 사용하여 M개의 열 중 3개의 열을 선택하는 모든 경우를 탐색합니다.

3. **적 공격 시뮬레이션**  
   각 궁수 배치에 대해 다음과 같은 과정을 시뮬레이션합니다.

   - 각 턴마다 궁수는 자신의 공격 범위(D 이하)에 있는 적 중 가장 가까운 적을 찾습니다. 가장 가까운 적이 여러 명일 경우, 열 번호가 작은 적을 우선적으로 공격합니다.
   - 공격받은 적은 게임에서 제거됩니다. 동일한 적이 여러 궁수에게 공격당할 수 있습니다.
   - 모든 궁수가 적을 공격한 후, 남은 적들은 한 칸씩 아래로 이동합니다. 성에 도달한 적은 게임에서 제거됩니다.
   - 적이 모두 사라질 때까지 이 과정을 반복합니다.

4. **최대 적 제거 수 기록**  
   각 궁수 배치에 대해 시뮬레이션을 완료한 후, 해당 배치에서 제거한 적의 수를 기록합니다. 모든 배치에 대해 시뮬레이션이 끝나면, 그 중 가장 많은 적을 제거할 수 있는 경우를 찾아서 출력합니다.

이 문제의 시간 복잡도는 궁수 배치의 경우의 수인 `C(M, 3)`에 각 배치에 대한 시뮬레이션(적의 수와 궁수의 공격에 대한 처리) 과정이 더해져 대략적으로 계산할 수 있습니다. 하지만 M과 N의 최대 크기가 15이므로, 전체 연산량은 제한 내에서 해결할 수 있습니다.

## 코드 구현

```python
from itertools import combinations  # 궁수 배치의 가능한 조합을 구하기 위해 combinations 함수 임포트
import copy  # 격자판 상태를 복사하기 위해 copy 모듈 사용

def simulate_attack(N, M, D, board, archers):
    count = 0  # 제거한 적의 수를 세는 변수
    enemies = [row[:] for row in board]  # 원본 격자판을 복사하여 게임 중 변형되지 않게 하기 위함

    while any(sum(row) for row in enemies):  # 적이 남아 있는 동안 반복
        targets = set()  # 이번 턴에 공격할 적의 좌표를 저장하는 집합

        for archer in archers:  # 각 궁수에 대해
            min_dist = D + 1  # 궁수가 공격 가능한 최대 거리를 설정 (처음엔 무한대처럼 큰 값으로 시작)
            target = None  # 공격할 적의 위치를 저장할 변수

            for r in range(N):  # 모든 행에 대해
                for c in range(M):  # 모든 열에 대해
                    if enemies[r][c] == 1:  # 적이 있는 경우
                        dist = abs(N - r) + abs(archer - c)  # 궁수와 적 사이의 거리 계산 (맨해튼 거리)
                        if dist <= D:  # 궁수의 공격 범위 내에 있는 적이라면
                            if dist < min_dist or (dist == min_dist and c < target[1]):  # 가장 가까운 적 또는 왼쪽에 있는 적을 선택
                                min_dist = dist  # 가장 가까운 거리로 갱신
                                target = (r, c)  # 공격할 적의 위치 갱신

            if target:  # 공격할 적이 있으면
                targets.add(target)  # 해당 적의 위치를 이번 턴 공격 대상에 추가

        for r, c in targets:  # 이번 턴에 공격받을 적들에 대해
            if enemies[r][c] == 1:  # 적이 아직 남아 있는 경우
                enemies[r][c] = 0  # 적을 제거
                count += 1  # 제거한 적의 수 증가

        enemies.pop()  # 마지막 행의 적들은 성에 도착했으므로 제거
        enemies.insert(0, [0] * M)  # 적들이 한 칸 아래로 이동 (첫 행은 빈 칸으로 추가)

    return count  # 제거한 적의 수 반환

def castle_defense(N, M, D, board):
    max_kills = 0  # 최대 제거할 수 있는 적의 수를 저장하는 변수
    for archers in combinations(range(M), 3):  # M개의 열에서 궁수 3명을 배치하는 모든 조합에 대해
        kills = simulate_attack(N, M, D, board, archers)  # 각 궁수 배치에 대해 시뮬레이션 수행
        max_kills = max(max_kills, kills)  # 제거한 적의 최대 수를 갱신

    return max_kills  # 최대 제거한 적의 수 반환

N, M, D = map(int, input().split())  # 격자판의 크기와 궁수의 공격 거리 입력 받기
board = [list(map(int, input().split())) for _ in range(N)]  # 격자판 상태 입력 받기

print(castle_defense(N, M, D, board))  # 궁수 배치 후 제거할 수 있는 최대 적의 수 출력
```
