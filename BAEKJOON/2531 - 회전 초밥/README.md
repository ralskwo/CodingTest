# 회전 초밥 문제 풀이 및 설명

<https://www.acmicpc.net/problem/2531>

<https://mayquartet.com/python-백준-2531-회전-초밥/>

## 문제 이해

이 문제는 회전 초밥 벨트에서 연속된 접시를 선택해 가능한 한 다양한 종류의 초밥을 먹는 경우를 찾는 것입니다. 초밥을 연속해서 `k`개 선택할 때, 추가적으로 쿠폰에 명시된 초밥을 무료로 제공받을 수 있습니다. 이때 가능한 최대 초밥 종류의 개수를 구해야 합니다. 중요한 점은 벨트가 원형으로 연결되어 있다는 점이며, 이를 고려하지 않으면 문제를 정확히 해결할 수 없습니다.

문제를 풀기 위해 다음 관점에서 접근해야 합니다:

1. 연속된 구간에서 초밥 종류를 파악해야 하므로 슬라이딩 윈도우 기법이 적합합니다.
2. 벨트가 원형으로 연결되어 있으므로 배열을 확장하여 선형으로 다룰 수 있도록 만들어야 합니다.
3. 쿠폰으로 추가 제공되는 초밥을 항상 포함하도록 처리하여 최대 초밥 종류를 계산합니다.

---

## 입출력 조건

### 입력 조건

1. 첫 번째 줄에는 네 개의 정수 `N`, `d`, `k`, `c`가 주어집니다.

   - `N`: 벨트에 놓인 접시의 수 (`2 ≤ N ≤ 30,000`).
   - `d`: 초밥의 가짓수 (`2 ≤ d ≤ 3,000`).
   - `k`: 연속해서 먹는 접시의 수 (`2 ≤ k ≤ N`).
   - `c`: 쿠폰으로 제공되는 초밥 번호 (`1 ≤ c ≤ d`).

2. 두 번째 줄부터 `N`개의 줄에 벨트에 놓인 초밥의 종류가 순서대로 주어집니다. 각 줄은 `1 ≤ 초밥 번호 ≤ d` 범위의 정수입니다.

### 출력 조건

1. 손님이 먹을 수 있는 최대 초밥 종류의 개수를 하나의 정수로 출력합니다.

---

## 접근 방식

1. **슬라이딩 윈도우 기법 사용**:

   - 연속된 `k`개의 초밥을 처리해야 하므로 슬라이딩 윈도우를 사용하여 효율적으로 계산합니다.
   - 초밥 벨트의 첫 번째 위치부터 마지막 위치까지 `k`-길이의 윈도우를 이동하며 최대 초밥 종류를 추적합니다.

2. **원형 배열 처리**:

   - 벨트는 원형으로 연결되어 있으므로 배열의 처음 `k-1`개를 끝에 추가하여 선형 배열처럼 처리합니다.
   - 이를 통해 원형 구조를 선형 구조로 쉽게 변환하고, 슬라이딩 윈도우 알고리즘을 적용할 수 있습니다.

3. **초밥 종류 관리**:

   - 현재 윈도우에서 어떤 종류의 초밥이 몇 개 있는지 빠르게 확인하기 위해 딕셔너리(또는 해시맵)를 사용합니다.
   - 윈도우가 이동할 때 추가 및 제거되는 초밥을 실시간으로 반영하여 종류를 추적합니다.

4. **쿠폰 초밥 처리**:

   - 쿠폰 초밥은 항상 포함된다고 가정합니다. 현재 윈도우에 쿠폰 초밥이 없을 경우, 종류를 하나 더 추가하여 최댓값을 계산합니다.

5. **효율성 고려**:
   - `N`이 최대 30,000이므로 `O(N)` 복잡도를 유지해야 합니다. 슬라이딩 윈도우 기법은 한 번의 선형 탐색으로 문제를 해결할 수 있어 효율적입니다.

<https://mayquartet.com/algorithm-투-포인터two-pointer-알고리즘-이해하기/>

---

## 풀이 과정

1. **입력 처리**:

   - `N`, `d`, `k`, `c` 값을 읽고 벨트 위 초밥 정보를 리스트로 저장합니다.
   - 리스트를 확장하여 처음 `k-1`개의 초밥을 끝에 추가하여 원형 구조를 선형으로 만듭니다.

2. **초기 윈도우 설정**:

   - 첫 `k`개의 초밥을 윈도우에 추가하며, 종류와 개수를 기록합니다.
   - 쿠폰 초밥이 포함되지 않았다면 종류를 추가로 증가시켜 초기 최대값을 계산합니다.

3. **슬라이딩 윈도우 수행**:

   - 윈도우를 한 칸씩 이동하며, 다음을 반복합니다:
     - 윈도우의 가장 왼쪽에 있는 초밥을 제거합니다. 만약 제거로 인해 특정 초밥의 개수가 0이 되면 종류를 감소시킵니다.
     - 윈도우의 오른쪽에 새로 추가되는 초밥을 포함합니다. 만약 새로운 초밥이라면 종류를 증가시킵니다.
     - 현재 종류와 쿠폰 초밥을 포함한 종류의 합계를 계산하여 최대값을 갱신합니다.

4. **결과 출력**:
   - 계산된 최대 초밥 종류를 출력합니다. 이 값은 손님이 먹을 수 있는 가장 다양한 초밥의 가짓수입니다.

## 코드 구현

```python
from collections import defaultdict


# 최대 초밥 가짓수를 계산하는 함수
def max_sushi_variety():
    import sys

    input = sys.stdin.read  # 표준 입력을 읽는 함수 정의
    data = input().split()  # 입력 데이터를 공백 기준으로 분리하여 리스트로 저장

    # 첫 번째 줄에서 벨트 길이(N), 초밥 가짓수(d), 연속 먹기(k), 쿠폰 번호(c)를 읽음
    N, d, k, c = map(int, data[:4])

    # 벨트 위 초밥 종류를 리스트로 저장
    sushi = list(map(int, data[4:]))

    # 원형 벨트를 처리하기 위해 벨트를 2배로 확장
    sushi += sushi[: k - 1]

    # 현재 윈도우의 초밥 종류를 기록할 딕셔너리 생성
    sushi_count = defaultdict(int)
    current_variety = 0  # 현재 초밥 종류의 수

    # 초기 윈도우 설정: 첫 k개의 접시를 윈도우에 추가
    for i in range(k):
        if sushi_count[sushi[i]] == 0:  # 새로운 종류의 초밥이면
            current_variety += 1  # 종류 개수 증가
        sushi_count[sushi[i]] += 1  # 초밥 개수 증가

    # 쿠폰 초밥을 포함한 최대 종류 계산
    max_variety = current_variety + (1 if sushi_count[c] == 0 else 0)

    # 슬라이딩 윈도우를 이용해 벨트를 순회
    for i in range(k, len(sushi)):
        # 윈도우에서 벗어난 초밥 제거
        leaving_sushi = sushi[i - k]
        sushi_count[leaving_sushi] -= 1  # 초밥 개수 감소
        if sushi_count[leaving_sushi] == 0:  # 초밥 종류가 완전히 사라졌다면
            current_variety -= 1  # 종류 개수 감소

        # 윈도우에 새로 들어온 초밥 추가
        entering_sushi = sushi[i]
        if sushi_count[entering_sushi] == 0:  # 새로운 종류의 초밥이면
            current_variety += 1  # 종류 개수 증가
        sushi_count[entering_sushi] += 1  # 초밥 개수 증가

        # 쿠폰 초밥을 고려하여 최대 종류 갱신
        max_variety = max(
            max_variety, current_variety + (1 if sushi_count[c] == 0 else 0)
        )

    # 최종 계산된 최대 초밥 종류 출력
    print(max_variety)


# 프로그램 시작점 설정
if __name__ == "__main__":
    max_sushi_variety()
```
