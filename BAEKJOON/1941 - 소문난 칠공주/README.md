# 소문난 칠공주 문제 풀이 및 설명

<https://www.acmicpc.net/problem/1941>

<https://mayquartet.com/python-백준-1941-소문난-칠공주/>

## 문제 이해

이 문제는 5×5 크기의 격자에서 특정 조건을 만족하는 7명의 학생 그룹을 찾는 문제입니다. 격자는 두 종류의 학생, 즉 '이다솜파' 학생을 나타내는 S와 '임도연파' 학생을 나타내는 Y로 이루어져 있습니다. 문제는 다음 조건을 만족하는 7명의 학생 그룹, 즉 '소문난 칠공주'를 찾는 것입니다.

1. 그룹은 정확히 7명의 학생으로 구성되어야 합니다.
2. 선택된 7명의 학생들은 서로 가로나 세로로 연결되어 있어야 합니다.
3. 그룹 내 S 학생의 수가 최소 4명 이상이어야 합니다.
4. 그룹은 반드시 연속된 공간에서 선택되어야 하므로, 상하좌우로만 인접해야 합니다.

이 문제는 조합론과 그래프 탐색이 결합된 문제로, 25개의 격자 칸에서 7개를 선택하고 이들 중 조건을 만족하는 경우의 수를 계산해야 합니다. 문제의 핵심은 조합과 탐색 과정을 효율적으로 처리하는 데 있습니다.

## 입출력 조건

### 입력 조건

- 입력은 5줄로 주어지며, 각 줄은 5개의 문자로 구성됩니다.
- 각 문자는 공백 없이 주어지며, S 또는 Y로만 이루어져 있습니다.
- 총 25개의 칸으로 구성된 격자가 주어지며, 각 칸은 학생의 위치를 나타냅니다.

### 출력 조건

- 조건을 만족하는 '소문난 칠공주'를 결성할 수 있는 모든 경우의 수를 정수로 출력합니다.

## 접근 방식

1. **조합을 생성하여 부분 문제 해결**  
   5×5 격자에서 총 25개의 칸이 있으므로, 이 중 7개의 칸을 선택하는 모든 조합을 생성해야 합니다. 이를 위해 Python의 itertools.combinations를 활용할 수 있습니다.

2. **조건 검증**  
   조합으로 생성된 7개의 칸이 서로 인접해야 하므로, 인접성 검사를 수행해야 합니다. 이는 BFS나 DFS를 사용해 탐색하여 해결할 수 있습니다. 그룹 내 '이다솜파' 학생(S)의 수가 최소 4명 이상이어야 합니다. 선택된 조합에서 S의 개수를 세어 조건을 검증합니다.

3. **효율성 고려**  
   총 조합의 수는 약 48만 가지입니다. 각 조합에 대해 두 가지 조건을 검증해야 하므로, BFS 탐색과 조건 검증이 효율적으로 설계되어야 합니다. 인접성 검사는 BFS를 통해 선택된 7개의 칸이 연결되어 있는지 확인하는 방식으로 처리합니다.

<https://mayquartet.com/algorithm-bfs-너비-우선-탐색-알고리즘/>

<https://mayquartet.com/algorithm-알고리즘-dfs-깊이-우선-탐색-알고리즘-이해하기/>

## 풀이 과정

### 1. 입력 처리

5줄로 구성된 격자 데이터를 입력받아 각 줄을 리스트 형태로 저장합니다. 이를 통해 각 칸에 접근할 수 있습니다. 모든 칸의 좌표를 `(행, 열)` 형식으로 리스트에 저장합니다. 이 리스트는 조합 생성에 사용됩니다.

### 2. 조합 생성

itertools.combinations를 사용하여 25개의 칸 중 7개의 칸을 선택하는 모든 조합을 생성합니다.

### 3. 조건 검증 - '이다솜파' 학생 수 확인

선택된 조합에서 각 칸을 확인하며, 해당 칸에 위치한 학생이 S인지 확인합니다. S의 개수가 4개 이상인 경우에만 다음 조건 검증을 진행합니다.

### 4. 조건 검증 - 인접성 검사

선택된 조합이 서로 인접한지 확인하기 위해 BFS를 수행합니다. BFS 탐색은 다음과 같이 진행됩니다.

- 선택된 조합의 첫 번째 칸을 시작점으로 설정합니다.
- 큐를 사용하여 상하좌우로 이동 가능한 칸을 탐색합니다.
- 탐색된 칸이 선택된 조합에 포함되어 있고, 방문하지 않은 칸이라면 큐에 추가합니다.
- 탐색이 완료된 후, 방문한 칸의 수가 7개라면 선택된 조합이 모두 인접한 것입니다.

### 5. 결과 계산 및 출력

조건을 만족하는 조합의 수를 카운트하여 결과를 저장합니다. 모든 조합에 대해 검증이 완료된 후 최종 결과를 출력합니다.

## 코드 구현

```python
from itertools import combinations
from collections import deque

# 5x5 격자를 입력 받는다. 각 줄은 문자열로 구성된다.
grid = [input().strip() for _ in range(5)]

# 상하좌우 이동을 위한 방향 벡터를 정의한다.
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# 5x5 격자의 모든 좌표를 리스트로 생성한다.
positions = [(i, j) for i in range(5) for j in range(5)]

# 선택된 7개의 좌표가 모두 인접해 있는지를 확인하는 함수
def is_adjacent(selected):
    # BFS를 수행하기 위해 초기 큐에 첫 번째 좌표를 넣는다.
    queue = deque([selected[0]])
    # 방문한 좌표를 기록하기 위해 집합에 첫 번째 좌표를 추가한다.
    visited = set([selected[0]])
    # 현재 연결된 좌표의 수를 초기화한다.
    count = 1

    # BFS 탐색을 시작한다.
    while queue:
        # 큐에서 하나의 좌표를 꺼낸다.
        x, y = queue.popleft()
        # 상하좌우로 이동하면서 연결된 좌표를 확인한다.
        for d in range(4):
            nx, ny = x + dx[d], y + dy[d]
            # 선택된 좌표 중 방문하지 않은 좌표라면 방문 처리 후 큐에 추가한다.
            if (nx, ny) in selected and (nx, ny) not in visited:
                visited.add((nx, ny))
                queue.append((nx, ny))
                count += 1
    # 연결된 좌표의 수가 7개라면 True를 반환한다.
    return count == 7

# 선택된 좌표 중 'S' 학생의 수를 세는 함수
def count_s(selected):
    # 선택된 좌표에서 해당 좌표의 값이 'S'인 경우를 세어 반환한다.
    return sum(1 for x, y in selected if grid[x][y] == 'S')

# 가능한 경우의 수를 저장할 변수를 초기화한다.
result = 0

# 25개의 좌표에서 7개의 좌표를 선택하는 모든 조합을 생성한다.
for comb in combinations(positions, 7):
    # 선택된 조합이 'S' 학생 4명 이상을 포함하고, 모두 인접해 있는 경우를 확인한다.
    if count_s(comb) >= 4 and is_adjacent(comb):
        # 조건을 만족하면 경우의 수를 증가시킨다.
        result += 1

# 모든 경우의 수를 출력한다.
print(result)
```
