# 박성원 문제 풀이 및 설명

https://www.acmicpc.net/problem/1086

## 문제 이해

이 문제는 주어진 서로 다른 정수 집합의 모든 순열을 고려하여, 해당 순열로 만든 큰 정수가 특정 정수 `K`로 나누어떨어지는 경우를 찾는 것입니다. 주어진 집합에 속한 숫자들을 조합하여 순서를 바꾸면 새로운 큰 정수를 만들 수 있으며, 이 정수가 `K`로 나누어떨어질 확률을 계산해야 합니다. 이 확률은 올바른 순열의 개수를 전체 순열의 개수로 나눈 값으로 표현되며, 결과는 기약분수 형태로 출력해야 합니다.

문제를 해결하기 위해서는 각 순열을 개별적으로 계산하여 나머지를 구하는 방식으로 접근할 수 있지만, 숫자의 길이가 길고 집합의 크기가 클 수 있기 때문에, 효율적인 방법을 사용하는 것이 중요합니다. 이를 위해 비트마스크와 동적 계획법(DP)을 활용하여 모든 순열을 고려하면서 중복 계산을 피하고 최적화된 방식으로 문제를 해결할 수 있습니다.

## 입출력 조건

- **입력**:

  - 첫 번째 줄에는 집합에 포함된 숫자의 개수 `N`이 주어집니다. (`N`은 15 이하의 자연수)
  - 두 번째 줄부터 `N`개의 줄에는 집합에 포함된 각 숫자가 주어집니다. 각 숫자는 길이가 최대 50인 자연수입니다.
  - 마지막 줄에는 `K`가 주어집니다. (`K`는 100 이하의 자연수)

- **출력**:
  - 첫 번째 줄에 확률을 기약분수 형태로 출력합니다. `p/q` 꼴로 출력하며, `p`는 분자, `q`는 분모입니다. 정답이 0인 경우는 `0/1`, 1인 경우는 `1/1`로 출력합니다.

## 접근 방식

이 문제는 비트마스크와 동적 계획법(DP)을 결합한 방법으로 해결할 수 있습니다. 각각의 숫자를 사용했는지를 비트마스크로 표현하고, 나머지 값들을 DP 테이블에 저장하여 중복된 계산을 피하면서 최적의 해결책을 찾는 것입니다.

1. **비트마스크**: 비트마스크는 주어진 숫자들의 사용 여부를 이진수로 나타내는 방식입니다. `N`개의 숫자가 있을 때, `2^N`개의 가능한 상태가 존재하며, 각 상태는 특정 숫자들이 사용되었는지를 나타냅니다.
2. **DP 테이블**: DP 테이블은 각 비트마스크 상태와 나머지 값에 대해 가능한 경우의 수를 저장합니다. DP 테이블의 크기는 `(2^N) x K`로 설정되며, `dp[mask][rem]`은 비트마스크 `mask`가 나타내는 상태에서 `K`로 나눈 나머지가 `rem`인 경우의 수를 의미합니다.
3. **상태 전이**: 각 상태에서 사용하지 않은 숫자를 추가하여 새로운 상태로 전이합니다. 이 과정에서 나머지를 갱신하고, 가능한 모든 상태를 탐색하여 최종적으로 모든 숫자를 사용했을 때 나머지가 0인 경우의 수를 계산합니다.

4. **결과 계산**: 가능한 모든 순열 중에서 나머지가 0인 경우의 수를 전체 순열의 개수로 나누어 확률을 계산하고, 이를 기약분수 형태로 출력합니다.

## 풀이 과정

1. **입력 처리 및 초기화**:
   - `N`, `numbers`, `K`를 입력받고, 각 숫자를 `K`로 나눈 나머지를 계산하여 저장합니다.
   - 최대 50자리의 숫자에 대해 `10^i % K`를 미리 계산하여 자리수 변환에 필요한 값을 준비합니다.
2. **DP 테이블 초기화**:
   - `dp` 테이블을 `0`으로 초기화하고, 초기 상태로 아무 숫자도 사용하지 않은 상태(`mask = 0`)에서 나머지가 `0`인 경우의 수를 `1`로 설정합니다.
3. **상태 전이**:
   - 모든 비트마스크 상태(`mask`)와 나머지(`rem`)에 대해 순회하면서, 아직 사용되지 않은 숫자를 추가하여 새로운 상태(`new_mask`)와 새로운 나머지(`new_rem`)를 계산합니다.
   - DP 테이블을 갱신하면서, 모든 가능한 순열을 고려합니다.
4. **결과 계산**:
   - 모든 숫자를 사용한 상태(`mask = (1 << N) - 1`)에서 나머지가 `0`인 경우의 수를 `p`로 저장합니다.
   - 전체 순열의 개수(`N!`)를 계산하여 분모 `q`를 설정합니다.
   - 최종적으로 `p/q`를 기약분수 형태로 출력합니다. 만약 `p`가 `0`인 경우 `0/1`을 출력하고, `p`와 `q`가 같다면 `1/1`을 출력합니다.

## 코드 구현

```python
from math import gcd

def solve():
    N = int(input().strip())  # 집합의 수의 개수를 입력받습니다.
    numbers = [input().strip() for _ in range(N)]  # 집합에 포함된 수들을 입력받아 리스트에 저장합니다.
    K = int(input().strip())  # 정수 K를 입력받습니다.

    mod_numbers = []  # 각 숫자를 K로 나눈 나머지를 저장할 리스트입니다.
    for num in numbers:
        mod_numbers.append(int(num) % K)  # 각 숫자를 K로 나눈 나머지를 리스트에 추가합니다.

    power_of_10 = [1] * 51  # 10의 거듭제곱을 K로 나눈 나머지를 저장할 리스트입니다.
    for i in range(1, 51):
        power_of_10[i] = (power_of_10[i-1] * 10) % K  # 10^i % K를 계산하여 리스트에 저장합니다.

    dp = [[0] * K for _ in range(1 << N)]  # DP 테이블을 초기화합니다. 크기는 (2^N) x K입니다.
    dp[0][0] = 1  # 초기 상태: 아무 숫자도 사용하지 않았을 때 나머지가 0인 경우의 수는 1입니다.

    for mask in range(1 << N):  # 모든 비트마스크(숫자의 사용 여부를 나타내는 상태)를 순회합니다.
        for rem in range(K):  # 모든 나머지 값에 대해 순회합니다.
            if dp[mask][rem] == 0:  # 현재 상태에서 가능한 경우의 수가 0이라면, 스킵합니다.
                continue
            for i in range(N):  # 집합의 각 숫자에 대해 반복합니다.
                if not (mask & (1 << i)):  # i번째 숫자가 사용되지 않았다면,
                    new_mask = mask | (1 << i)  # i번째 숫자를 사용한 새로운 비트마스크를 만듭니다.
                    new_rem = (rem * power_of_10[len(numbers[i])] + mod_numbers[i]) % K  # 새로운 나머지를 계산합니다.
                    dp[new_mask][new_rem] += dp[mask][rem]  # 새로운 상태에서의 경우의 수를 갱신합니다.

    p = dp[(1 << N) - 1][0]  # 모든 숫자를 사용했을 때 나머지가 0인 경우의 수를 p로 설정합니다.
    q = 1  # 전체 경우의 수를 계산하기 위해 초기값 1로 설정합니다.
    for i in range(2, N + 1):
        q *= i  # 전체 순열의 개수 (N!)을 계산합니다.

    if p == 0:  # 만약 나머지가 0인 경우의 수가 없다면,
        print("0/1")  # 0/1을 출력합니다.
    else:
        divisor = gcd(p, q)  # 기약분수를 만들기 위해 p와 q의 최대공약수를 계산합니다.
        print(f"{p // divisor}/{q // divisor}")  # 기약분수 형태로 출력합니다.

solve()  # 함수 실행
```
