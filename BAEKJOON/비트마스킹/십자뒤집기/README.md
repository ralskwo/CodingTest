# 십자뒤집기 문제 풀이 및 설명 

https://www.acmicpc.net/problem/10472

## 문제 이해

이 문제는 3x3 크기의 보드에서 각 칸을 클릭하면 해당 칸과 상하좌우 인접한 칸의 색상이 반전되는 상황에서, 모든 칸을 흰색으로 만들기 위한 최소 클릭 수를 구하는 것입니다. 각 칸의 색상은 흰색('.') 또는 검은색('*')으로 주어집니다. 클릭하는 칸과 그 주변 칸이 모두 반전되므로, 효과적으로 모든 가능한 클릭 조합을 고려해야 합니다. 문제의 핵심은 각 칸을 클릭했을 때 변화하는 패턴을 이해하고, 최소 클릭 수를 찾는 것입니다.

## 입출력 조건

**입력:**
- 첫 번째 줄에 테스트 케이스의 수 \( P \)가 주어집니다.
- 각 테스트 케이스마다 3x3 크기의 보드가 주어집니다. 보드의 각 줄은 세 글자의 문자열로 표현됩니다.
- '*'은 검은색을 의미하고, '.'은 흰색을 의미합니다.

**출력:**
- 각 테스트 케이스에 대해 모든 칸을 흰색으로 만들기 위한 최소 클릭 수를 출력합니다.

## 접근 방식

이 문제는 모든 가능한 클릭 조합을 시도하여 최적의 클릭 수를 찾는 브루트포스(Brute Force) 방식으로 접근해야 합니다. 구체적으로는, 3x3 보드의 각 칸에 대해 클릭할지 말지를 결정하는 모든 경우의 수를 탐색합니다. 총 9개의 칸에 대해 각각 클릭 여부를 결정해야 하므로, 총 \( 2^9 = 512 \)가지의 조합을 시도하게 됩니다. 각 조합마다 보드를 복사하고 클릭을 적용한 후, 모든 칸이 흰색이 되는지를 확인합니다.

## 풀이 과정

1. **모든 클릭 조합 생성:**
   - `itertools.product`를 사용하여 3x3 보드의 각 칸에 대해 클릭할지 말지의 모든 조합을 생성합니다. 총 512가지의 조합이 생성됩니다.
   
2. **보드 복사 및 클릭 적용:**
   - 각 클릭 조합에 대해 보드를 복사하고, 조합에 따라 각 칸을 클릭하여 보드를 반전시킵니다. 클릭할 칸을 클릭하면 해당 칸과 상하좌우 인접한 칸의 색상을 반전시키는 `flip` 함수를 사용합니다.
   
3. **모든 칸이 흰색인지 확인:**
   - 클릭을 적용한 후, 보드의 모든 칸이 흰색인지 확인합니다. 만약 모든 칸이 흰색이라면, 현재 조합의 클릭 수를 최소 클릭 수와 비교하여 업데이트합니다.
   
4. **결과 출력:**
   - 모든 테스트 케이스에 대해 최소 클릭 수를 계산한 후 결과를 출력합니다.

## 코드 구현
```python
def flip(board, x, y):
    # 주어진 좌표 (x, y)를 클릭했을 때 보드를 반전시키는 함수
    for dx, dy in [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]:
        # 현재 위치 (0, 0)과 상하좌우 위치를 표현하는 (dx, dy) 쌍을 순회
        nx, ny = x + dx, y + dy
        # 새로운 좌표 (nx, ny)가 보드의 범위 안에 있는지 확인
        if 0 <= nx < 3 and 0 <= ny < 3:
            # 해당 좌표의 색상을 반전 ('*'는 '.'로, '.'는 '*'로)
            board[nx][ny] = '*' if board[nx][ny] == '.' else '.'

def min_clicks_to_all_white(board):
    from itertools import product  # 모든 조합을 생성하기 위해 itertools 모듈에서 product를 가져옴
    
    min_clicks = float('inf')  # 최소 클릭 수를 큰 값으로 초기화 (무한대)
    
    # 3x3 보드의 각 칸에 대해 클릭할지 말지의 모든 조합을 생성
    for clicks in product([0, 1], repeat=9):
        temp_board = [row[:] for row in board]  # 현재 보드를 복사
        click_count = 0  # 현재 조합의 클릭 횟수를 초기화
        
        # 클릭 조합을 적용
        for idx, click in enumerate(clicks):
            # 클릭하는 경우
            if click:
                x, y = divmod(idx, 3)  # idx를 3으로 나눈 몫과 나머지를 좌표로 변환
                flip(temp_board, x, y)  # 해당 좌표를 클릭하여 보드를 반전시킴
                click_count += 1  # 클릭 횟수 증가
        
        # 모든 칸이 흰색인지 확인
        if all(temp_board[i][j] == '.' for i in range(3) for j in range(3)):
            # 현재 클릭 조합이 최소 클릭 수인지 확인하고 갱신
            min_clicks = min(min_clicks, click_count)
    
    return min_clicks  # 최소 클릭 수를 반환

# 입력 처리
import sys
input = sys.stdin.read  # 표준 입력을 읽어옴
data = input().split()  # 입력 데이터를 공백을 기준으로 분할

P = int(data[0])  # 첫 번째 줄은 테스트 케이스 수 P

results = []  # 결과를 저장할 리스트
index = 1  # 데이터의 현재 위치 인덱스 (첫 번째 테스트 케이스 시작 위치)
for _ in range(P):
    # 보드를 입력 데이터에서 추출
    board = [list(data[index]), list(data[index + 1]), list(data[index + 2])]
    index += 3  # 다음 테스트 케이스로 인덱스를 이동
    results.append(min_clicks_to_all_white(board))  # 최소 클릭 수를 계산하여 결과에 추가

# 결과 출력
for result in results:
    print(result)  # 각 테스트 케이스의 결과를 출력
